unit uWPOpers;

interface
uses
  Windows, sysutils, ActiveX, Classes, ComObj, StdVcl,
  uBaseObjService, variants,
  Winpos_ole_TLB, POSBase, graphics, Forms, uBaseObj, uBaseObjMng, NativeXML,
  uEventList, dialogs, uCommonMath,
  uCommonTypes, uLogFile, uSetList, inifiles, mathfunction,
  uWPEvents, Messages,
  math;

type
  TUnits = (u_Abs, u_percent, u_10Lg, u_20Lg);

  tgraphstruct = record
    hpage, hgraph, haxis, hline: integer;
  end;


function getSignalViewRangeY(s:iwpsignal):point2d;
function GetGraphStructByHLine(hline:integer):tgraphstruct;
function createline(Signal: iwpsignal): tgraphstruct; overload;
// g,a - график и ось
function createline(Signal: iwpsignal; g, a: integer): tgraphstruct; overload;
// в новый график на той же странице
function createline(Signal: iwpsignal; p: integer): tgraphstruct; overload;
// закидывает на выбраный график сигнал в новую ось и нормирует ее. при необходимости нормируется x графика
function createlineNewAx(Signal: iwpsignal; g: integer): tgraphstruct; overload;
procedure normaliseGraph(g: integer);
// Найти страницу по графику. Возвращает hpage
function FindPageByGraph(graph: integer): integer;
// мин макс по оси X для графика
function Getgraphminmax(g: integer): point2d;
function activeGraph:tgraphstruct;
// получить диапазон выбранного графика
function GetActiveGraphX: point2d;
function GetActiveCursorX: point2d;
function GetGraphX(g: integer): point2d;
function GetGraphCursorX(p,g: integer): point2d;
function findNode(inst:integer):iwpnode;overload;
function findNode(node:iwpnode;inst:integer):iwpnode;overload;
function findSignal(path:string):iwpsignal;
function isHelpChannel(s:string):boolean;overload;
function isHelpChannel(s:iwpsignal):boolean;overload;

implementation

function getSignalViewRangeY(s:iwpsignal):point2d;
var
  range:double;
begin
  result.x:=s.MinY;
  result.y:=s.MaxY;
  range:=result.y-result.x;
  result.x := result.x - range*0.05;
  result.y := result.y + range*0.05;
end;

function GetGraphStructByHLine(hline:integer):tgraphstruct;
var
  hg, ha, hp, hl:integer;
  i, j, k, numax:integer;
begin
  result.hpage:=0;
  result.hgraph:=0;
  result.haxis:=0;
  result.hline:=0;

  IWPGraphs(WP.GraphApi).SetLineOpt(hline, LNOPT_HIST, LNOPT_HIST, 0, 0);
  for I := 0 to IWPGraphs(WP.GraphApi).GetPageCount - 1 do
  begin
    hp:=IWPGraphs(WP.GraphApi).GetPage(i);
    for j := 0 to IWPGraphs(WP.GraphApi).GetGraphCount(hp) - 1 do
    begin
      hg:=IWPGraphs(WP.GraphApi).GetGraph(hp, j);
      for k := 0 to IWPGraphs(WP.GraphApi).GetLineCount(hg) - 1 do
      begin
        hl:=IWPGraphs(WP.GraphApi).GetLine(hg, k);
        if hl=hline then
        begin
          numax := IWPGraphs(WP.GraphApi).GetYAxisNum(hline);
          ha := IWPGraphs(WP.GraphApi).GetYAxis(hg, numax);
          result.hpage:=hp;
          result.hgraph:=hg;
          result.haxis:=ha;
          result.hline:=hl;
          exit;
        end;
      end;
    end;
  end;
end;

function createline(Signal: iwpsignal): tgraphstruct;
var
  x1, x2, range: double;
  y1y2:point2d;
begin
  // строим графику
  result.hpage := IWPGraphs(wp.GraphApi).CreatePage;
  result.hgraph := IWPGraphs(wp.GraphApi).GetGraph(result.hpage, 0);
  result.haxis := IWPGraphs(wp.GraphApi).GetYAxis(result.hgraph, 0);
  result.hline := IWPGraphs(wp.GraphApi).createline(result.hgraph,
    result.haxis, Signal.Instance);

  x1 := Signal.MinX;
  x2 := Signal.MaxX;

  y1y2:=getSignalViewRangeY(signal);

  IWPGraphs(wp.GraphApi).SetXMinMax(result.hgraph, x1, x2);
  IWPGraphs(wp.GraphApi).SetYAxisMinMax(result.haxis, y1y2.x, y1y2.y);
  IWPGraphs(wp.GraphApi).SetGraphOpt(result.hgraph, GROPT_AUTONORM,
    GROPT_AUTONORM);

  IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, 0, AXOPT_RANGE, AXOPT_RANGE,
    x1, x2, '', ' ', 0);
  IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, result.haxis, AXOPT_RANGE,
    AXOPT_RANGE, y1y2.x, y1y2.y, '', '', 0);
end;

function createline(Signal: iwpsignal; g, a: integer): tgraphstruct;
var
  opt, color:integer;
  s1,s2:widestring;
  y1,y2:double;
  y1y2:point2d;
begin
  result.hgraph := g;
  result.haxis := a;
  result.hpage := FindPageByGraph(g);
  result.hline := IWPGraphs(wp.GraphApi).createline(result.hgraph,
    result.haxis, Signal.Instance);
  IWPGraphs(wp.GraphApi).GetAxisOpt(g,a,opt,y1,y2,s1,s2,color);
  y1y2:=getSignalViewRangeY(signal);
  if y1y2.x>y1 then
    y1y2.x:=y1;
  if y1y2.y<y2 then
    y1y2.y:=y2;
  IWPGraphs(wp.GraphApi).SetYAxisMinMax(result.haxis, y1y2.x, y1y2.y);
  IWPGraphs(wp.GraphApi).SetGraphOpt(result.hgraph, GROPT_AUTONORM,
    GROPT_AUTONORM);
  IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, result.haxis, AXOPT_RANGE,
    AXOPT_RANGE, y1y2.x, y1y2.y, s1, s2, 0);
end;

function createline(Signal: iwpsignal; p: integer): tgraphstruct;
var
  x1, x2: double;
  y1y2:point2d;
begin
  result.hpage := p;
  result.hgraph := IWPGraphs(wp.GraphApi).CreateGraph(p);
  result.haxis := IWPGraphs(wp.GraphApi).GetYAxis(result.hgraph, 0);
  result.hline := IWPGraphs(wp.GraphApi).createline(result.hgraph,
    result.haxis, Signal.Instance);

  x1 := Signal.MinX;
  x2 := Signal.MaxX;
  y1y2:=getSignalViewRangeY(signal);

  IWPGraphs(wp.GraphApi).SetXMinMax(result.hgraph, x1, x2);
  IWPGraphs(wp.GraphApi).SetYAxisMinMax(result.haxis, y1y2.x, y1y2.y);
  IWPGraphs(wp.GraphApi).SetGraphOpt(result.hgraph, GROPT_AUTONORM,
    GROPT_AUTONORM);

  IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, 0, AXOPT_RANGE, AXOPT_RANGE,
    x1, x2, '', ' ', 0);
  IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, result.haxis, AXOPT_RANGE,
    AXOPT_RANGE, y1y2.x, y1y2.y, '', '', 0);
end;

function createlineNewAx(Signal: iwpsignal; g: integer): tgraphstruct;
var
  x1,x2:double;
  bx:boolean;
  y1y2:point2d;
begin
  result.hgraph := g;
  result.hpage := FindPageByGraph(g);
  result.haxis:=IWPGraphs(wp.GraphApi).CreateYAxis(g);
  result.hline := IWPGraphs(wp.GraphApi).createline(result.hgraph,
                  result.haxis, Signal.Instance);

  y1y2:=getSignalViewRangeY(signal);
  bx:=false;
  IWPGraphs(wp.GraphApi).GetXMinMax(result.hgraph, x1, x2);
  if x1>Signal.minx then
  begin
    x1:=Signal.minx;
    bx:=true;
  end;
  if x2<Signal.maxx then
  begin
    x2:=Signal.maxx;
    bx:=true;
  end;
  if bx then
  begin
    IWPGraphs(wp.GraphApi).SetXMinMax(result.hgraph, x1, x2);
    IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, 0, AXOPT_RANGE, AXOPT_RANGE,
      x1, x2, '', ' ', 0);
  end;

  IWPGraphs(wp.GraphApi).SetYAxisMinMax(result.haxis, y1y2.x, y1y2.y);
  IWPGraphs(wp.GraphApi).SetGraphOpt(result.hgraph, GROPT_AUTONORM,
    GROPT_AUTONORM);
  IWPGraphs(wp.GraphApi).SetAxisOpt(result.hgraph, result.haxis, AXOPT_RANGE,
    AXOPT_RANGE, y1y2.x, y1y2.y, '', '', 0);
end;

function GetGraphStructByHLine(hline:integer):tgraphstruct;
var
  hg, ha, hp, hl:integer;
  i, j, k, numax:integer;
begin
  result.hpage:=0;
  result.hgraph:=0;
  result.haxis:=0;
  result.hline:=0;

  IWPGraphs(WP.GraphApi).SetLineOpt(hline, LNOPT_HIST, LNOPT_HIST, 0, 0);
  for I := 0 to IWPGraphs(WP.GraphApi).GetPageCount - 1 do
  begin
    hp:=IWPGraphs(WP.GraphApi).GetPage(i);
    for j := 0 to IWPGraphs(WP.GraphApi).GetGraphCount(hp) - 1 do
    begin
      hg:=IWPGraphs(WP.GraphApi).GetGraph(hp, j);
      for k := 0 to IWPGraphs(WP.GraphApi).GetLineCount(hg) - 1 do
      begin
        hl:=IWPGraphs(WP.GraphApi).GetLine(hg, k);
        if hl=hline then
        begin
          numax := IWPGraphs(WP.GraphApi).GetYAxisNum(hline);
          ha := IWPGraphs(WP.GraphApi).GetYAxis(hg, numax);
          result.hpage:=hp;
          result.hgraph:=hg;
          result.haxis:=ha;
          result.hline:=hl;
          exit;
        end;
      end;
    end;
  end;
end;

procedure normaliseGraph(g: integer);
var
  x1, x2, y1, y2: double;
  axCount, lCount, ax, line, axNum, opt, color: integer;
  i, j: integer;
  str1, str2: widestring;
  s: iwpsignal;
begin
  axCount := IWPGraphs(wp.GraphApi).GetYAxisCount(g);
  lCount := IWPGraphs(wp.GraphApi).GetLineCount(g);
  IWPGraphs(wp.GraphApi).GetAxisOpt(g, 0, opt, x1, x2, str1, str2, color);
  for j := 0 to lCount - 1 do
  begin
    line := IWPGraphs(wp.GraphApi).GetLine(g, j);
    s := IWPGraphs(wp.GraphApi).GetSignal(line) as iwpsignal;
    if s.MinX < x1 then
      x1 := s.MinX;
    if s.MaxX > x2 then
      x2 := s.MaxX;
  end;

  IWPGraphs(wp.GraphApi).SetXMinMax(g, x1, x2);
  IWPGraphs(wp.GraphApi).SetGraphOpt(g, GROPT_AUTONORM, GROPT_AUTONORM);
  IWPGraphs(wp.GraphApi).SetAxisOpt(g, 0, AXOPT_RANGE, AXOPT_RANGE, x1, x2, '',
    ' ', 0);
  for i := 0 to axCount - 1 do
  begin
    ax := IWPGraphs(wp.GraphApi).GetYAxis(g, i);
    IWPGraphs(wp.GraphApi).GetAxisOpt(g, ax, opt, y1, y2, str1, str2, color);
    for j := 0 to lCount - 1 do
    begin
      line := IWPGraphs(wp.GraphApi).GetLine(g, j);
      axNum := IWPGraphs(wp.GraphApi).GetYAxisNum(line);
      if axNum = i then
      begin
        s := IWPGraphs(wp.GraphApi).GetSignal(line) as iwpsignal;
        if s.MinY < y1 then
          y1 := s.MinY;
        if s.MaxY > y2 then
          y2 := s.MaxY;
      end;
      IWPGraphs(wp.GraphApi).SetYAxisMinMax(ax, y1, y2);
      IWPGraphs(wp.GraphApi).SetAxisOpt(g, ax, AXOPT_RANGE, AXOPT_RANGE, y1,
        y2, '', '', 0);
    end;
  end;
end;

function FindPageByGraph(graph: integer): integer;
var
  i, j, p: integer;
begin
  result := 0;
  for i := 0 to IWPGraphs(wp.GraphApi).GetPageCount - 1 do
  begin
    p := IWPGraphs(wp.GraphApi).GetPage(i);
    for j := 0 to IWPGraphs(wp.GraphApi).GetGraphCount(p) - 1 do
    begin
      if IWPGraphs(wp.GraphApi).GetGraph(p, j) = graph then
      begin
        result := p;
        exit;
      end;
    end;
  end;
end;

function Getgraphminmax(g: integer): point2d;
var
  i, hline: integer;

  s: iwpsignal;
  x1, x2: double;
begin
  result.x := 0;
  result.y := 0;
  for i := 0 to IWPGraphs(wp.GraphApi).GetLineCount(g) - 1 do
  begin
    hline := IWPGraphs(wp.GraphApi).GetLine(g, i);
    s := IWPGraphs(wp.GraphApi).GetSignal(hline) as iwpsignal;
    x1 := s.MinX;
    x2 := s.MaxX;
    if x1 < result.x then
      result.x := x1;
    if x2 > result.y then
      result.y := x2;
  end;
end;

function GetSignalFolder(s:iwpsignal):string;
var
  n:iwpnode;
  i,len:integer;
  str:string;
begin
  n:=winpos.GetNode(s) as iwpnode;
  str:=n.AbsolutePath;
  len:=length(str);
  result:='';
  for I := len downto 1 do
  begin
    if str[i]='/' then
    begin
      result:=copy(str,1, i-1);
      exit;
    end;
  end;
end;


function findSignal(path:string):iwpsignal;
var
  d:idispatch;
begin
  d:=WP.GetObject(path);
  result:=TypeCastToIWSignal(d);
end;

function findNode(node:iwpnode;inst:integer):iwpnode;
var
  I: Integer;
  n:iwpnode;
begin
  result:=nil;
  if node.Instance=inst then
  begin
    result:=node;
    exit;
  end;
  for I := 0 to node.childCount - 1 do
  begin
    n:=node.At(i) as iwpnode;
    result:=findNode(n,inst);
  end;
end;

function findNode(inst:integer):iwpnode;
var
  root, n:iwpnode;
  I: Integer;
begin
  root:=WP.Get('Signals') as iwpnode;
  for I := 0 to root.ChildCount - 1 do
  begin
    n:=root.at(i) as iwpnode;
    if n.Instance=inst then
      result:=n
    else
    begin
      result:=findNode(n, inst);
      if result<>nil then
        exit;
    end;
  end;
end;

function isHelpChannel(s:string):boolean;
var
  t:ctrig;
  I: Integer;
begin
  result:=false;
  for I := 0 to mng.TrigList.Count - 1 do
  begin
    t:=mng.getTrig(i);
    if t.TrigName=s then
    begin
      if t.m_helpChannel then
      begin
        result:=true;
        exit;
      end;
    end;
  end;
end;

function isHelpChannel(s:iwpsignal):boolean;
var
  t:ctrig;
  I: Integer;
begin
  result:=isHelpChannel(s.sname);
end;

function isHelpChannel(s:cwpsignal):boolean;
var
  t:ctrig;
  I: Integer;
begin
  result:=isHelpChannel(s.name);
end;


end.
