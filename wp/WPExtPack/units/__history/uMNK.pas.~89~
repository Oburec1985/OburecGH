unit uMNK;

interface
uses
  math, Generics.Collections ;

type
  d2array = array of array of double;

  procedure Gram (n,m:integer; const x,f:array of double; var a:d2array);overload;
  procedure Gram (n,m:integer; const x,f:olevariant; var a:d2array);overload;
  // m - степень полинома; c - массив коэффициентов полинома; x, y входные данные
  procedure buildMNK(m:integer; const x, y: array of double; var сi:array of double);overload;
  procedure buildMNK(m:integer; x, y: olevariant; size:integer; var сi:array of double);overload;
  //procedure buildMNK(m:integer; const x, y: olevariant; var сi:array of double);
  // посчитать значение полинома в точке x
  function fi (m:integer; var c:array of double; x:real):real;

implementation

//  показательна€ функци€ дл€ формировани€ матрицы √рамма
// нужна дл€ решени€ системы уравнений
function ex (a:real; n:integer):real;
var i:integer;
    e:real;
begin
 e:=1;
 for i:=1 to n do
  e:=e*a;
 ex:=e;
end;

procedure Gram (n,m:integer; const x,f:olevariant; var a:d2array);
var
  i,j:integer;
  p,q,r,s:real;
begin
 for j:=0 to m do
 begin
   s:=0; r:=0; q:=0;
   for i:=0 to n-1 do
   begin
     p:=ex(x[i],j);
     s:=s+p;
     r:=r+p*f[i];
     // сумма x
     q:=q+p*ex(x[i],m);
   end;
   a[0,j]:=s;
   a[j,m]:=q;
   a[j,m+1]:=r;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
end;

procedure Gram (n,m:integer; const x,f:array of double; var a:d2array);
var
  i,j:integer;
  p,q,r,s:real;
begin
 for j:=0 to m do
 begin
   s:=0; r:=0; q:=0;
   for i:=0 to n-1 do
   begin
     p:=ex(x[i],j);
     s:=s+p;
     r:=r+p*f[i];
     // сумма x
     q:=q+p*ex(x[i],m);
   end;
   a[0,j]:=s;
   a[j,m]:=q;
   a[j,m+1]:=r;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
end;

// решение симметричной матрицы методом гаусса. x - решение вектор 0..n
// a - матрица грамма, n - степень полинома
procedure Gauss(n:integer; var a:d2array; var x:array of double);
var
  i,j,k,l,k1,n1:integer;
  r,s:real;
begin
  n1:=n+1;
  for k:=0 to n do
  begin
    k1:=k+1;
    s:=a[k,k];
    for j:=k1 to n1 do a[k,j]:=a[k,j]/s;
    for i:=k1 to n do
    begin
      r:=a[i,k];
      for j:=k1 to n1 do
        a[i,j]:=a[i,j]-a[k,j]*r;
    end;
  end;
  for i:=n downto 0 do
  begin
    s:=a[i,n1];
    for j:=i+1 to n do
      s:=s-a[i,j]*x[j];
    x[i]:=s;
  end;
end;

// значение полинома c - значени€ полинома x1  - x вычисл€емого узла
// m - степень полинома
function fi (m:integer; var c:array of double; x:real):real;
var i:integer; p:real;
begin
 p:=c[m];
 for i:=m-1 downto 0 do
   p:=c[i]+x*p;
 fi:=p;
end;

procedure buildMNK(m:integer; const x, y: array of double; var сi:array of double);
var
  // загадочный член обозначающий число узлов (»Ќ“≈–ѕќЋя÷»»????!!!!)
  n:integer;
  // матрица к грамма
  a:d2array;
  I, j: Integer;
begin
  n:=length(x);
  setlength(a,m+1,m+1);
  // в программе с которой списано всегда 10 почему то
  Gram (n, m, x, y, a);
  // заполнение своб коэф.
  for I := 0 to m do
  begin
    for j := 0 to n - 1 do
    begin
      сi[i]:=сi[i]+Power(x[j],i)*y[j];
    end;
  end;
  Gauss (m,a,сi);
end;

procedure buildMNK(m:integer; x, y: olevariant; size:integer; var сi:array of double);
var
  // загадочный член обозначающий число узлов (»Ќ“≈–ѕќЋя÷»»????!!!!)
  n:integer;
  // матрица к грамма
  a:d2array;
  I, j: Integer;
begin
  n:=size;
  setlength(a,m+1,m+1);
  // в программе с которой списано всегда 10 почему то
  Gram (n, m, x, y, size, a);
  // заполнение своб коэф.
  for I := 0 to m do
  begin
    for j := 0 to n - 1 do
    begin
      сi[i]:=сi[i]+Power(x[j],i)*y[j];
    end;
  end;
  Gauss (m,a,сi);
end;

end.
