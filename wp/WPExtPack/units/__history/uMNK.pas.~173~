unit uMNK;

interface
uses
  math, Generics.Collections ;

type
  d2array = array of array of double;
  // матрицы записываютс€ по столбцам, т.е. Vcol1 ,..Vcoln где вектор компонентов состо€щий из элементов row m[0] = колонка V0
  // “ранспонирование
  // кажда€ строка становитс€ строкой
  function transpondmatrix(m:d2array):d2array;
  // ƒетерминант. ќпределен только дл€ квадратной матрицы
  function DeterminantGauss(a:d2array):double;
  //function Determinant(A:d2array):extended;
  procedure InversA(A:d2array;var Inv:d2array);
  procedure MultMatrix(m1,m2:d2array; var m3:d2array);

  // n - число точек в сигнале m - пор€док интерпол€ции
  procedure Gram (n,m:integer; const x,f:array of double; var a:d2array);overload;
  procedure Gram (n,m:integer; const x,f:olevariant; var a:d2array);overload;
  // m - степень полинома; c - массив коэффициентов полинома; x, y входные данные
  procedure buildMNK(m:integer; const x, y: array of double; var сi:array of double);overload;
  procedure buildMNK(m:integer; x, y: olevariant; size:integer; var сi:array of double);overload;
  //procedure buildMNK(m:integer; const x, y: olevariant; var сi:array of double);
  // посчитать значение полинома в точке x
  function fi (m:integer; var c:array of double; x:real):real;

implementation

// a11 = m1_row1*m2_col1
procedure MultMatrix(m1,m2:d2array; var m3:d2array);
var
  i, j, k,
  // размерность матриц
  m1d1, m1d2, m2d1, m2d2:integer;
begin
  m1d1:=length(m1);
  m1d2:=length(m1[0]);
  m2d1:=length(m2);
  m2d2:=length(m2[0]);
  // у результата число строк равно числу строк первой матрицы и числу колонок второй
  setlength(m3, m2d1, m1d2);
  // цикл по колонкам
  for i:=0 to m1d2-1 do
  begin
    // цикл по строкам
    for j:=0 to m2d1-1 do
    begin
      m3[i,j]:=0;
      for k:=0 to m1d1-1 do
      begin
        m3[i,j]:=m3[i,j] + m1[k,i] * m2[j,k];
      end;
    end;
  end;
end;

procedure InversA(A:d2array;var Inv:d2array);
var
  minor:d2array;
  detmin,det:Extended;
  n,i,j,kx,ky:Integer;
begin
  n:=High(A);
  SetLength(minor,n,n);
  for i:=0 to n do
  for j:=0 to n do
  begin
    for kx:=0 to i-1 do
    begin
      for ky:=0 to j-1 do
        minor [kx,ky]:=A[i,j];
      for ky:=j to n-1 do
        minor[kx,ky]:=A[i,j+1];
    end;
    for kx:=i to n-1 do
    begin
      for ky:=0 to j-1 do minor[kx,ky]:=A[i+1,j] ;
      for ky:=0 to n do minor[kx,ky]:=A[i+1,j+1];
    end;
    det:=DeterminantGauss(A);
    detmin:=DeterminantGauss(minor);
    if Odd(i+1) then
      Inv[j,i]:=-detmin/det
    else
      Inv[j,i]:=detmin/det;
  end;
end;

procedure Swap(k,n:integer;var a:d2array; var p:integer);
//перестановка строк, если главный элемент=0
var
  z:Real;j,i:integer;
begin
  z:=abs(a[k,k]);i:=k;p:=0;
  for j:=k+1 to n-1 do
  begin
     if abs(a[j,k])>z then
     begin
       z:=abs(a[j,k]);i:=j;
       p:=p+1;//счетчик перестановок
     end;
  end;
  if i>k then
  begin
    for j:=k to n-1 do
    begin
      z:=a[i,j];
      a[i,j]:=a[k,j];
      a[k,j]:=z;
    end;
  end;
end;

function Znak(p:integer):integer;
//при перестановке мен€етс€ знак определител€, надо его отследить
begin
  if p mod 2=0 then
    result:=1
  else
    result:=-1;
end;

function DeterminantGauss(a:d2array):double;
var
  k,i,j,p,n:integer;r:real;
  buf:d2array;
begin
  result:=1.0;
  n:=length(a);
  for I := 0 to n - 1 do
  begin
    for j := 0 to n - 1 do
    begin
      buf[i,j]:=a[i,j];
    end;
  end;

  for k:=0 to n-1 do
  begin
    if buf[k,k]=0 then
      swap(k,n,buf,p);//перестановка строк
    result:=znak(p)*result*buf[k,k];//вычисление определител€
    for j:=k+1 to n-1 do //пересчет коэффициентов
    begin
      r:=buf[j,k]/buf[k,k];
      for i:=k to n-1 do
        buf[j,i]:=buf[j,i]-r*buf[k,i];
    end;
  end;
end;

function transpondmatrix(m:d2array):d2array;
var
  r, c,dim1,dim2: Integer;
begin
  dim1:=length(m);
  dim2:=length(m[0]);
  setlength(result, dim2, dim1);
  for r := 0 to dim1-1 do
  begin
    for c := 0 to dim2 - 1 do
    begin
      result[c,r]:=m[r,c];
    end;
  end;
end;

//  показательна€ функци€ дл€ формировани€ матрицы √рамма
// нужна дл€ решени€ системы уравнений
function ex (a:real; n:integer):real;
var i:integer;
    e:real;
begin
 e:=1;
 for i:=1 to n do
  e:=e*a;
 ex:=e;
end;

procedure Gram (n,m:integer; const x,f:olevariant; var a:d2array);
var
  i,j:integer;
  p,q,r,s:real;
begin
 for j:=0 to m do
 begin
   s:=0; r:=0; q:=0;
   for i:=0 to n-1 do
   begin
     p:=ex(x[i],j);
     s:=s+p;
     r:=r+p*f[i];
     // сумма x
     q:=q+p*ex(x[i],m);
   end;
   a[0,j]:=s;
   a[j,m]:=q;
   a[j,m+1]:=r;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
end;

procedure Gram (n,m:integer; const x,f:array of double; var a:d2array);
var
  i,j:integer;
  p,q,r,s:real;
begin
 for j:=0 to m do
 begin
   s:=0; r:=0; q:=0;
   for i:=0 to n-1 do
   begin
     p:=ex(x[i],j);
     s:=s+p;
     r:=r+p*f[i];
     // сумма x
     q:=q+p*ex(x[i],m);
   end;
   a[0,j]:=s;
   a[j,m]:=q;
   a[j,m+1]:=r;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
 for i:=1 to m do
 begin
   for j:=0 to m-1 do
   begin
     a[i,j]:=a[i-1,j+1];
   end;
 end;
end;

// решение симметричной матрицы методом гаусса. x - решение вектор 0..n
// a - матрица грамма, n - степень полинома
procedure Gauss(n:integer; var a:d2array; var x:array of double);
var
  i,j,k,l,k1,n1:integer;
  r,s:real;
begin
  n1:=n+1;
  for k:=0 to n do
  begin
    k1:=k+1;
    s:=a[k,k];
    for j:=k1 to n1 do a[k,j]:=a[k,j]/s;
    for i:=k1 to n do
    begin
      r:=a[i,k];
      for j:=k1 to n1 do
        a[i,j]:=a[i,j]-a[k,j]*r;
    end;
  end;
  for i:=n downto 0 do
  begin
    s:=a[i,n1];
    for j:=i+1 to n do
      s:=s-a[i,j]*x[j];
    x[i]:=s;
  end;
end;

// значение полинома c - значени€ полинома x1  - x вычисл€емого узла
// m - степень полинома
function fi (m:integer; var c:array of double; x:real):real;
var i:integer; p:real;
begin
 p:=c[m];
 for i:=m-1 downto 0 do
   p:=c[i]+x*p;
 fi:=p;
end;

procedure buildMNK(m:integer; const x, y: array of double; var сi:array of double);
var
  // загадочный член обозначающий число узлов (»Ќ“≈–ѕќЋя÷»»????!!!!)
  n:integer;
  // матрица к грамма
  a:d2array;
  I, j: Integer;
begin
  n:=length(x);
  // непон€тно почему но поставил +2 а не +1 с запасом. иначе вываливаетс€ инвалид поинтер на домашней делфи
  // на работе норм работает с +1
  setlength(a,m+2,m+2);
  // n - длина массива
  Gram (n, m, x, y, a);
  // заполнение своб коэф.
  for I := 0 to m do
  begin
    for j := 0 to n - 1 do
    begin
      сi[i]:=сi[i]+Power(x[j],i)*y[j];
    end;
  end;
  Gauss (m,a,сi);
end;

procedure buildMNK(m:integer; x, y: olevariant; size:integer; var сi:array of double);
var
  // загадочный член обозначающий число узлов (»Ќ“≈–ѕќЋя÷»»????!!!!)
  n:integer;
  // матрица к грамма
  a:d2array;
  I, j: Integer;
begin
  n:=size;
  setlength(a,m+2,m+2);
  // в программе с которой списано всегда 10 почему то
  Gram (n, m, x, y, a);
  // заполнение своб коэф.
  for I := 0 to m do
  begin
    for j := 0 to n - 1 do
    begin
      сi[i]:=сi[i]+Power(x[j],i)*y[j];
    end;
  end;
  Gauss (m,a,сi);
end;

end.
