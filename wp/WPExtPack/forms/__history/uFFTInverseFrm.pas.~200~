unit uFFTInverseFrm;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms, uCommonMath,
  Dialogs, StdCtrls, DCL_MYOWN, uExtFFTInverse, posbase, Winpos_ole_TLB, uBaseObjService,
  VirtualTrees, uVTServices, ImgList, uWPOpers, uWPservices, uCommonTypes, uComponentservises,
  ComCtrls, CommCtrl, uBtnListView, ExtCtrls;

type
  // возвращает - нужно ли продолжать перечисление
  wpenumProc = function(obj: iwpnode; data: pointer): boolean;

  tNodeData = class
  public
    inst:integer;
  public
    function signal:iwpsignal;
  end;

  TFFTInverseFrm = class(TForm)
    NumPointsCB: TComboBox;
    NumPointsLabel: TLabel;
    Label1: TLabel;
    nBlocksIE: TIntEdit;
    GroupBox1: TGroupBox;
    CancelBtn: TButton;
    ApplyBtn: TButton;
    dFfe: TFloatEdit;
    Label3: TLabel;
    ImageList16: TImageList;
    Panel1: TPanel;
    SigTV: TVTree;
    ChannelsLV: TBtnListView;
    FltEdit: TEdit;
    Label2: TLabel;
    procedure ApplyBtnClick(Sender: TObject);
    procedure SrcLVDragDrop(Sender, Source: TObject; X, Y: Integer);
    procedure NumPointsCBDragOver(Sender, Source: TObject; X, Y: Integer;
      State: TDragState; var Accept: Boolean);
    procedure ChannelsLVDragOver(Sender, Source: TObject; X, Y: Integer;
      State: TDragState; var Accept: Boolean);
    procedure FltEditChange(Sender: TObject);
  public
    m_createThread:cardinal;
  private
    m_oper:TExtFFTInverse;
  private
    function CheckFlt(nd: tnodedata; HideParent:boolean): boolean;
    procedure cleartv;
    function GetNotifyStr(p_opts:string):string;
    procedure ShowSignalsInTV(tv:tvtree);
  public
    procedure link(eo:TExtFFTInverse);
    function EditOper:string;
    function GetPropStr:string;
    Procedure SetPropStr(str:string);
  end;


var
  FFTInverseFrm: TFFTInverseFrm;

implementation
uses
  uWpExtPack;


{$R *.dfm}

{ TFFTInverseFrm }
function EnumGroupMembers(proc: wpenumProc; node: iwpnode; data: pointer;
  var continue: boolean): boolean;
var
  i: integer;
  obj: iwpnode;
  childNode: iwpnode;
begin
  result := true;
  if continue then
  begin
    continue := proc(node, data);
    if continue then
    begin
      for i := 0 to node.ChildCount - 1 do
      begin
        childNode := iwpnode(node.at(i));
        EnumGroupMembers(proc, childNode, data, continue);
        if not continue then
          exit;
      end;
    end;
  end;
end;

function GetParentNodeByIdisp(tv:tvtree; disp:idispatch):pvirtualnode;
var
  n:pvirtualnode;
  d:PNodeData;
  I: Integer;
begin
  result:=nil;
  for I := 0 to tv.TotalCount - 1 do
  begin
    if I <> 0 then
      n := tv.GetNext(n)
    else
      n := tv.GetFirst;
    d:=tv.GetNodeData(n);
    if d<>nil then
    begin
      if iwpnode(d.data).Instance=(disp as iwpnode).Instance then
      begin
        result:=n;
        break;
      end;
    end;
  end;
end;

procedure AddUsmlNode(tv:tvtree; d:idispatch);
var
  n:pvirtualnode;
  inode:iwpnode;
  nd:pnodedata;
  m:iwpusml;
begin
  n:=tv.AddChild(nil);
  nd:=tv.GetNodeData(n);
  nd.Caption:=(d as iwpnode).Name;
  nd.ImageIndex:=0;
  nd.color:=tv.normalcolor;

  nd.data:=tNodeData.Create;
  inode:=TypeCastToIWNode(d);
  tNodeData(nd.data).inst:=inode.Instance;
  nd.data:=pointer(d);
end;

procedure AddSignalNode(tv:tvtree; s:iwpnode);
var
  n:pvirtualnode;
  nd:pnodedata;
  parent:iwpnode;
  pnode:pvirtualnode;
begin
  parent:=s.Parent as iwpnode;
  pnode:=GetParentNodeByIdisp(tv,parent);
  if pnode<>nil then
  begin
    n:=tv.AddChild(pnode, nil);
    nd:=tv.GetNodeData(n);
    nd.Caption:=s.Name;
    nd.ImageIndex:=1;
    nd.color:=tv.normalcolor;

    nd.data:=tNodeData.Create;
    tNodeData(nd.data).inst:=s.Instance;
  end;
end;

// wpenumProc = function(obj:iwpnode; data:pointer):boolean;
function enumReadSRC(obj: iwpnode; data: pointer): boolean;
begin
  result := true;
  // ЕСЛИ УЗЕЛ СОДЕРЖИТ УЗЛЫ СИГНАЛЫ
  if IsSrc(obj) or IsUSML(obj) then
  begin
    AddUsmlNode(TVTree(data),obj);
  end;
  if IsSignal(obj) then
  begin
    AddSignalNode(TVTree(data),obj);
  end;
end;

procedure TFFTInverseFrm.ShowSignalsInTV(tv:tvtree);
var
  node: iwpnode;
  b: boolean;
begin
  node := iwpnode((posbase.winpos.Get('/signals')));
  b := true;
  cleartv;
  EnumGroupMembers(enumReadSRC, node, tv, b);
end;

procedure TFFTInverseFrm.ApplyBtnClick(Sender: TObject);
var
  i, start, stop:integer;
  param:olevariant;
  wstr:widestring;
  str:string;
  s:iwpsignal;
  li:tlistitem;
  nd:tnodedata;
begin
  for I := 0 to ChannelsLV.count - 1 do
  begin
    li:=ChannelsLV.items[i];

    s := iwpsignal(pointer(SignalLB.Items.Objects[I]));
    // установка свойств
    m_oper.Execute(s);
  end;
  BringToFront;
  str:=GetNotifyStr(m_oper.GetPropStrF(wstr));
  param:=str;
  // вызов уведомления
  TExtPack(extPack).NotifyPlugin($000F0001, param);
end;

procedure TFFTInverseFrm.SrcLVDragDrop(Sender, Source: TObject; X,
  Y: Integer);
var
  screenLeftTopLV, P, p1:TPoint;
  li:TListItem;
  liInd,I, w, colind: Integer;

  s:iwpsignal;
  n:pvirtualnode;
  d:pNodeData;


  col:TListColumn;
  parent:twincontrol;
begin
  GetCursorPos(P);

  // получить итем под курсором
  P1:=TBtnListView(sender).ScreenToClient(P);
  y:=p.y;
  li:=nil;
  if TListView(Sender).TopItem<>nil then
  begin
    li:=TListView(Sender).GetItemAt(TListView(Sender).TopItem.Position.X,p1.y);
    liInd:=li.index;
  end;

  w:=0;
  colind:=-1;
  parent:=TBtnListView(Sender).parent;
  screenLeftTopLV:=parent.ClientToScreen(point(TBtnListView(Sender).left,TBtnListView(Sender).top));
  for I := 0 to TBtnListView(Sender).Columns.Count - 1 do
  begin
    col:=TBtnListView(Sender).Columns[i];
    if (p.x-screenLeftTopLV.x)<w+col.width then
    begin
      colind:=i;
      break;
    end
    else
    begin
      w:=w+col.width;
    end;
  end;
  n:=tvtree(source).GetFirstSelected(true);
  for I := 0 to tvtree(source).SelectedCount - 1 do
  begin
    if i=0 then
    begin
      if li=nil then
      begin
        li:=TListView(Sender).Items.Add;
      end
      else
      begin

      end;
      inc(liInd);
    end
    else
    begin
      if liInd<TListView(Sender).items.count then
      begin
        li:=TListView(Sender).items[liInd];
      end
      else
      begin
        li:=TListView(Sender).Items.Add;
      end;
      inc(liInd);
    end;
    if i=0 then
    begin

    end
    else
    begin
      n:=tvtree(source).GetNextSelected(n,true);
    end;
    d:=tvtree(source).GetNodeData(n);
    s:=tnodedata(d.data).signal;
    li.Data:=tnodedata(d.data);
    case colind of
      0:
      begin
        TBtnListView(Sender).SetSubItemByColumnName('Re', s.sname, li);
      end;
      1:
      begin
        TBtnListView(Sender).SetSubItemByColumnName('Im', s.sname, li);
      end;
    end;
  end;
  lvchange(ChannelsLV);
end;

procedure TFFTInverseFrm.ChannelsLVDragOver(Sender, Source: TObject; X,
  Y: Integer; State: TDragState; var Accept: Boolean);
begin
  if source=SigTV then
  begin
    Accept:=true;
  end
  else
  begin
    Accept:=false;
  end;
end;

procedure TFFTInverseFrm.cleartv;
var
  I: Integer;
  n:pvirtualnode;
  d:pnodedata;
  nd:tnodedata;
  tv:tvtree;
begin
  tv:=sigTV;
  if tv.TotalCount<>0 then
  begin
    for I := 0 to tv.TotalCount - 1 do
    begin
      if I <> 0 then
        n := tv.GetNext(n)
      else
      begin
        n := tv.GetFirst;
      end;
      d:=tv.GetNodeData(n);
      nd:=tnodedata(d.data);
      nd.Destroy;
    end;
    tv.Clear;
  end;
  ChannelsLV.clear;
end;

function TFFTInverseFrm.EditOper: string;
var
  res:integer;
  I: Integer;
begin
  // переносим свойства в форму
  ShowSignalsInTV(sigtv);
  if GetCurrentThreadId<>m_createThread then
    exit;
  res:=showmodal;
  if res=mrok then
  begin
    // переносим свойства в оператор
    m_oper.SetPropStr(GetPropStr);
    ApplyBtnClick(nil);
  end;
end;

// Рекурсивный обход дерева
procedure FindInTree( Tree: TVirtualStringTree; Node: PVirtualNode; var Hide: boolean );
var
  childNode:pvirtualNode;
  str:string;
  d: pnodedata;
  nd:tnodedata;
  hideChild,
  // Если false то будет отображаться даже если все дочерние элементы спрятаны
  HideThisNode,
  // один из потомков видимый
  childVisible:boolean;
begin
  childVisible:=false;
  d := Tree.GetNodeData(Node);
  if Assigned( d ) then
  begin
    nd:=tnodedata(d.data);
    // Проверка на соответствие фильтру
    Hide :=not FFTInverseFrm.checkflt(nd, hide);
    HideThisNode:=hide;
    if (Node.ChildCount > 0) then
    begin
      childNode:=Tree.GetFirstChild(Node);
      while childNode<>nil do
      begin
        hideChild:=true;
        FindInTree( Tree, childNode, hideChild );
        if not hideChild then
        begin
          childVisible:=true;
        end;
        childnode:=childnode.NextSibling;
      end;
    end;
    if (not hideThisNode) or (childVisible)
    then
    begin
      Node.States := Node.States + [vsVisible];
      hide:=false;
    end
    else
    begin
      Node.States := Node.States - [vsVisible]
    end;
    // не корневые узлы и так перебираются
    if tree.GetNodeLevel(node)=0 then
    begin
      Node := Node.NextSibling;
      if node<>nil then
      begin
        FindInTree(tree,node, hide);
      end;
    end;
  end;
end;

procedure TFFTInverseFrm.FltEditChange(Sender: TObject);
var
  b:boolean;
begin
  b:=true;
  FindInTree(sigtv, sigtv.GetFirstChild(nil), b);
  sigtv.Invalidate;
end;

function TFFTInverseFrm.CheckFlt(nd: tnodedata; HideParent:boolean): boolean;
var
  s:iwpsignal;
  str:string;
begin
  if fltedit.text='' then
  begin
    result:=true;
    exit;
  end;
  result:=false;
  s:=nd.signal;
  if s<>nil then
  begin
    str:=s.sname;
    result:=pos(fltedit.text,str)>0;
  end
  else
  begin
    result:=true;
  end;
end;

function TFFTInverseFrm.GetNotifyStr(p_opts: string): string;
var
  i:integer;
  str, numstr:string;
begin
//'o="/Operators/АвтоСпектр";p="kindFunc=4, numPoints=16384, nBlocks=530, nLines=0, typeWindow=1, ofsNextBlock=16384, typeMagnitude=1, type=0, method=0, isMO=1, isCorrectFunc=0, isMonFase=0, isFill0=0, fMaxVal=0, fLog=0, fPrSpec=0, f3D=0, fSwapXZ=0, iStandart=1, fFlt=0, fQual=6, log_kind=0, log_OpZn=2e-005, log_fOpZn=0, prs_kind=1, prs_loFreq=1, prs_s2n=100, prs_fCorr=0, prs_strCorr=, prs_typeCorr=0";
//s1_000="/Signals/signal0436.mera/3- 1";i1_000=0;c1_000=8694000;d1_000="/Signals/Результаты/signal0436.mera_СA/3- 1_СA";dp1_000=1e9a008d;
//s1_001="/Signals/signal0436.mera/18- 1_Taho";i1_001=0;c1_001=8715600;d1_001="/Signals/Результаты/signal0436.mera_СA/18- 1_Taho_СA";
//dp1_001=1e95690d;
//s1_002="/Signals/signal0436.mera/18- 3_Stop";i1_002=0;c1_002=8715600;d1_002="/Signals/Результаты/signal0436.mera_СA/18- 3_Stop_СA";dp1_002=1e96a90d;s1_003="/Signals/signal0436.mera/18- 4_Start";i1_003=0;c1_003=8715600;d1_003="/Signals/Результаты/signal0436.mera_СA/18- 4_Start_СA";dp1_003=1e98248d;'

//'o="/Operators/ПоискЭкстремумов";
// p="BandCount=1,bx_0=5,by_0=2000,L_pos_0=90,L_neg_0=10,N_pos_0=5,N_neg_0=5,N_Max_0=+,N_Neg_0=+,Units_0=%";
// s1_001="3- 1_СA"i1_001=0;c1_001=2048;d1_001="3- 1_СA_AFlg" s2_002="18- 1_Taho_СA"i2_002=0;c2_002=2048;d2_002="3- 1_СA_AFlg"s3_003="18- 3_Stop_СA"i3_003=0;c3_003=2048;d3_003="18- 3_Stop_СA_AFlg"s4_004="18- 4_Start_СA"i4_004=0;c4_004=2048;d4_004="18- 4_Start_СA_AFlg"'
  result:='o="/Расширения/'+'FFTInverse'+'";p="'+p_opts+'";';
  {for I := 0 to SignalLB.Count - 1 do
  begin
    //signal:=cwpsignal(SignalLB.Items.Objects[i]);
    numstr:=inttostr(i);
    str:=numstr;
    if length(str)<3 then
    begin
      while length(str)<>3 do
      begin
        str:='0'+str;
      end;
    end;
    // важно писать полный путь, т.к. по нему потом определяется источник
    // и соответствующий ID
    result:=result+'s1'+'_'+str+'="'//signal.node.AbsolutePath+'";'
          +'i1'+'_'+str+'='+'0'+';'
          +'c1'+'_'+str+'='//inttostr(signal.Signal.size)+';'
          +'d1'+'_'+str+'="'//+m_oper.resfolder+'/'+
          //signal.name+HilbExtName+'";';
          ;
  end;}
end;

function TFFTInverseFrm.GetPropStr: string;
var
  pars: tstringlist;
  b: boolean;
  str: string;
begin
  pars := tstringlist.create;
  addParam(pars, 'FFTCount', (NumPointsCB.Text));
  addParam(pars, 'dX', dFfe.text);
  addParam(pars, 'BCount', nBlocksIE.Text);
  result := ParsToStr(pars);
  delpars(pars);
  pars.destroy;
end;

procedure TFFTInverseFrm.SetPropStr(str: string);
var
  s:iwpsignal;
  p:TStringList;
begin
  p:=ParsStrParamNoSort(str, ',');

  NumPointsCB.text:=GetParsValue(p,'FFTCount');
  nBlocksIE.text:=GetParsValue(p,'BCount');
  dFfe.text:=GetParsValue(p,'dX');

  p.Destroy;
end;

procedure TFFTInverseFrm.link(eo: TExtFFTInverse);
begin
  m_oper:=eo;
end;

procedure TFFTInverseFrm.NumPointsCBDragOver(Sender, Source: TObject; X,
  Y: Integer; State: TDragState; var Accept: Boolean);
begin
  Accept:=true;
end;

{ tNodeData }

function tNodeData.signal: iwpsignal;
var
  n:iwpnode;
begin
  n:=findNode(inst);
  if n<>nil then
  begin
    result:=TypeCastToIWSignal(n);
  end;
end;

end.
