unit uMBaseControl;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  inifiles, uCommonMath, uStringGridExt,
  Dialogs, StdCtrls, ExtCtrls, Grids, ComCtrls,
  uBtnListView, uRecBasicFactory, pluginclass, uRecorderEvents,
  uComponentServises,
  uRCFunc, recorder, PathUtils, uDownloadregsfrm, urcclientfrm,
  uMeasureBase, uMdbFrm, DB, DBClient, uRcClient, Sockets, ImgList, Buttons,
  plugin,  Menus, ScktComp, ShlObj, uPathMng;

type

  cString = Class
  public
    str: string;
  End;

  TMBaseControl = class(TRecFrm)
    ObjGB: TGroupBox;
    TestGB: TGroupBox;
    RegGB: TGroupBox;
    ActionPanel: TPanel;
    Splitter1: TSplitter;
    Splitter2: TSplitter;
    Splitter3: TSplitter;
    RegPanel: TPanel;
    Label1: TLabel;
    RegistratorsLV: TBtnListView;
    TestPanel: TPanel;
    ObjPanel: TPanel;
    TestTypeCB: TComboBox;
    TestTypeLabel: TLabel;
    TestSelectBtn: TButton;
    Label2: TLabel;
    TestDateNameCB: TCheckBox;
    ObjNameLabel: TLabel;
    ObjRenameBtn: TButton;
    BaseFolderEdit: TEdit;
    Label3: TLabel;
    Button1: TButton;
    ObjNameCB: TComboBox;
    TestNameCB: TComboBox;
    mdbBtn: TButton;
    ObjPropSG: TStringGridExt;
    TestPropSG: TStringGridExt;
    RegPropSG: TStringGridExt;
    TcpClient1: TTcpClient;
    ImageList1: TImageList;
    Splitter4: TSplitter;
    Splitter5: TSplitter;
    Splitter6: TSplitter;
    Timer1: TTimer;
    ViewBtnGl: TSpeedButton;
    RecordBtnGl: TSpeedButton;
    StopBtnGl: TSpeedButton;
    DownloadRegsBtn: TSpeedButton;
    MainMenu1: TMainMenu;
    PropertiesMenu: TMenuItem;
    AlarmCB: TCheckBox;
    AlarmPanel: TPanel;
    AlarmDscLabel: TLabel;
    AlarmDsc: TEdit;
    AlarmTypeLabel: TLabel;
    AlarmType: TComboBox;
    RegNameEdit: TComboBox;
    Splitter7: TSplitter;
    MdbPathBtn: TButton;
    OpenDialog1: TOpenDialog;
    OpenDialog1vista: TFileOpenDialog;
    CfgSB: TSpeedButton;
    procedure Button1Click(Sender: TObject);
    procedure mdbBtnClick(Sender: TObject);
    procedure ObjPropSGEndEdititng(Sender: TObject; ACol, ARow: Integer;
      var CanSelect: Boolean);
    procedure ViewBtnClick(Sender: TObject);
    procedure RecordBtnClick(Sender: TObject);
    procedure StopBtnClick(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
    procedure DownloadRegsBtnClick(Sender: TObject);
    procedure ObjPropSGKeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure ObjNameCBChange(Sender: TObject);
    procedure ObjRenameBtnClick(Sender: TObject);
    procedure RegistratorsLVDblClickProcess(item: TListItem; lv: TListView);
    procedure AlarmCBClick(Sender: TObject);
    procedure TestTypeCBChange(Sender: TObject);
    procedure TestNameCBChange(Sender: TObject);
    procedure RegNameEditChange(Sender: TObject);
    procedure Splitter4Moved(Sender: TObject);
    procedure SpeedButton1Click(Sender: TObject);
    procedure MdbPathBtnClick(Sender: TObject);
    procedure CfgSBClick(Sender: TObject);
  private

    m_rstate: dword;
    // форма посчитана фабрикой класса. Ќужно дл€ ограничени€ числа форм
    m_counted: Boolean;
    finit: Boolean;
    fLoaded: Boolean;
    m_base: cMBase;
    // текуща€ регистраци€
    m_reg: cregFolder;
    rc_pan: cRegController;
    curObj, curTest, curReg: cXmlFolder;
  public
    fOnStopRec, fSaveCfg: tnotifyevent;
  protected
    procedure doStopRec(Sender: TObject);
    procedure doAddPropertie(Sender: TObject);
    procedure synchroniseSplitters(Sender: TObject);
    procedure setcurObj(o: cObjFolder);
    procedure setcurTest(t: cTestFolder);
    procedure setcurReg(r: cregFolder);
    procedure ShowObjProps(o: cXmlFolder);
    // формирует путь к регистрации на основании текущего каталога и настроек формы
    function createRegName(basepath: string; t: cTestFolder): string;
    procedure CreateEvents;
    procedure DestroyEvents;
    function EmptyReg: cregFolder;
    procedure doSaveCfg(Sender: TObject);
    procedure doChangeRCState(Sender: TObject);
    procedure doCreateConnection(Sender: TObject);
    procedure doDeleteRConnection(Sender: TObject);
    procedure showRegistrators;
    // происходит при обновленнии данных
    procedure doUpdateData(Sender: TObject);
    procedure doOnRead(connection: TRConnection; msg: tmsgHeader);
    procedure createReg;
    // создание описателей в базе с ссылками на записи регистраторов
    procedure createSubRegs;
    procedure settestsettings(t: cTestFolder);
    // заполнить список доступных дл€ выбора объектов
    procedure FillObjectsCB;
    procedure FillTestsCB(o: cObjFolder);
    procedure FillRegCB(t: cTestFolder);
    procedure UpdateXmlDescr;
  public
    function GetSelectObj: cObjFolder;
    function GetSelectTest: cTestFolder;
    function GetSelectReg: cregFolder;

    procedure DoGetNotify(data: dword);
    procedure SaveSettings(a_pIni: TIniFile; str: LPCSTR); override;
    procedure LoadSettings(a_pIni: TIniFile; str: LPCSTR); override;
    constructor Create(Aowner: tcomponent); override;
    destructor destroy; override;
  end;

  IMBaseControl = class(cRecBasicIFrm)
  public
    function doGetName: LPCSTR; override;
    procedure doClose; override;
    function doCreateFrm: TRecFrm; override;
  end;

  cMBaseFactory = class(cRecBasicFactory)
  private
    m_counter: Integer;
  protected
    procedure AddEvents;
    procedure doDestroyForms; override;
    procedure doUpdateTags(Sender: TObject);
    procedure doStatusNONE(Sender: TObject);
  public
    procedure decFrmCounter;
    procedure incFrmCounter;
    constructor Create;
    destructor destroy; override;
    function doCreateForm: cRecBasicIFrm; override;
    procedure doSetDefSize(var pSize: SIZE); override;
  end;

var
  v_NotifyMBaseSetProperties: Integer = VSN_USER + 1;
  // «агрузка и запуск плагина
  g_MBaseControl: TMBaseControl;
  function mBaseControl: TMBaseControl;


const
  c_Pic = 'MBASECONTROL';
  c_Name = '”правление базой данных';

const

  c_Control_defXSize = 509;
  c_Control_defYSize = 641;
  // ctrl+shift+G
  // ['{78AE7E7B-774B-46CF-8A49-33D352684760}']
  IID_ControlFactory: TGuid = (D1: $78AE7E7B; D2: $774B; D3: $46CF;
    D4: ($8A, $49, $33, $D3, $52, $68, $47, $60));

  c_img_view = 2;
  c_img_rec = 3;
  c_img_stop = 4;
  c_col_propName = 0;
  c_col_propVal = 1;
  c_col_regname = '–егистратор';
  c_col_folder = 'ѕодкаталог';

procedure InitPropSG(sg: tstringgrid);

implementation

uses
  uControlsNP, uCreateComponents;
{$R *.dfm}
{ IMBaseControl }

function mBaseControl: TMBaseControl;
begin
  result:=g_MBaseControl;
end;

procedure IMBaseControl.doClose;
begin
  m_lRefCount := 1;
end;

function IMBaseControl.doCreateFrm: TRecFrm;
var
  np: cMBaseNP;
begin
  result := TMBaseControl.Create(nil);
  np := cMBaseNP(getNP('MBaseControlNP'));
  if np <> nil then
  begin
    if result = nil then
      LogRecorderMessage('Ќе удалось создать нотификации Ѕƒ»')
    else
      np.init(TMBaseControl(result));
  end;
end;

function IMBaseControl.doGetName: LPCSTR;
begin
  result := 'Ѕƒ»';
end;

{ cMBaseFactory }

procedure cMBaseFactory.AddEvents;
begin

end;

constructor cMBaseFactory.Create;
begin
  m_lRefCount := 1;
  m_counter := 0;
  m_name := c_Name;
  m_picname := c_Pic;
  m_Guid := IID_ControlFactory;
  AddEvents;
end;

destructor cMBaseFactory.destroy;
begin
  // m_lRefCount:=0; // добавлено от 13.03.18
  inherited;
end;

procedure cMBaseFactory.incFrmCounter;
begin
  inc(m_counter);
end;

procedure cMBaseFactory.decFrmCounter;
begin
  dec(m_counter);
end;

function cMBaseFactory.doCreateForm: cRecBasicIFrm;
begin
  result := nil;
  if m_counter < 1 then
  begin
    result := IMBaseControl.Create();
    incFrmCounter;
  end;
end;

procedure cMBaseFactory.doDestroyForms;
begin
  inherited;
  // decFrmCounter;
end;

procedure cMBaseFactory.doSetDefSize(var pSize: SIZE);
begin
  pSize.cx := c_Control_defXSize;
  pSize.cy := c_Control_defYSize;
end;

procedure cMBaseFactory.doStatusNONE(Sender: TObject);
begin

end;

procedure cMBaseFactory.doUpdateTags(Sender: TObject);
begin

end;

{ TMBaseControl }
procedure TMBaseControl.Button1Click(Sender: TObject);
var
  objFolder, testFolder, regFolder: cXmlFolder;
begin
  if BaseFolderEdit.text <> m_base.m_BaseFolder.Absolutepath then
  begin
    m_base.InitBaseFolder(BaseFolderEdit.text);
    FillObjectsCB;
  end;
  // создаем объекты по кнопке применить
  objFolder := GetSelectObj;
  if objFolder = nil then
  begin
    if ObjNameCB.text <> '' then
    begin
      objFolder := cObjFolder.Create;
      // дл€ вновь создаваемых нет смысла что то искать внутри
      objFolder.fscanFolders := false;
      objFolder.fscanFiles := false;
      m_base.m_BaseFolder.AddChild(objFolder);
      objFolder.path := ObjNameCB.text;
      // создаем описатели и каталог
      objFolder.CreateFiles;
      ObjNameCB.AddItem(objFolder.name, objFolder);
      setComboBoxItem(objFolder.name, ObjNameCB);
    end;
  end;
  if objFolder = nil then
    exit;
  testFolder := GetSelectTest;
  if testFolder = nil then
  begin
    if TestNameCB.text <> '' then
    begin
      testFolder := cTestFolder.Create;
      cTestFolder(testFolder).m_testType := TestTypeCB.text;
      testFolder.name := TestNameCB.text;
      // дл€ вновь создаваемых нет смысла что то искать внутри
      testFolder.fscanFolders := false;
      testFolder.fscanFiles := false;
      objFolder.AddChild(testFolder);
      testFolder.path := TestNameCB.text;
      testFolder.caption := TestNameCB.text;
      testFolder.CreateFiles;

      TestNameCB.AddItem(testFolder.name, testFolder);
      setComboBoxItem(testFolder.caption, TestNameCB);
    end;
  end
  else
  begin
    settestsettings(cTestFolder(testFolder));
  end;
  if testFolder = nil then
    exit;
  // добавл€ем новый тип испытани€
  if cTestFolder(testFolder).m_testType <> '' then
    cBaseMeaFolder(m_base.m_BaseFolder).m_TestTypes.Add
      (cTestFolder(testFolder).m_testType);
  cregFolder(regFolder) := GetSelectReg;
  // regFolder := m_reg;
  // свойства регистрации
  cregFolder(regFolder).m_alarm := AlarmCB.Checked;
  cregFolder(regFolder).m_alarmType := AlarmType.text;
  cregFolder(regFolder).m_alarmDsc := AlarmDsc.text;
  // дл€ вновь создаваемых нет смысла что то искать внутри
  UpdateXmlDescr;
  if regFolder <> nil then
  begin
    if regFolder is cregFolder then
    begin
      RegNameEdit.AddItem(regFolder.caption, regFolder);
      setComboBoxItem(regFolder.caption, RegNameEdit);
    end;
  end;
end;

procedure TMBaseControl.UpdateXmlDescr;
var
  o: cObjFolder;
  t: cTestFolder;
  r: cregFolder;
begin
  o := GetSelectObj;
  if o <> nil then
  begin
    o.CreateXMLDesc;
  end;
  t := GetSelectTest;
  if t <> nil then
  begin
    t.CreateXMLDesc;
  end;
  r := GetSelectReg;
  if r <> nil then
  begin
    r.CreateXMLDesc;
  end;
end;

procedure TMBaseControl.AlarmCBClick(Sender: TObject);
begin
  AlarmPanel.Visible := AlarmCB.Checked;
end;

procedure TMBaseControl.CfgSBClick(Sender: TObject);
var
  lastcfg: cxmlfolder;
  cfgpath:string;
  pstr:pansichar;
  ir:irecorder;
begin
  if curtest<>nil then
  begin
    lastcfg := cxmlfolder(curtest.getChildrenByCaption('Lastcfg'));
    if lastcfg <> nil then
    begin
      cfgpath:=extractfiledir(lastcfg.Absolutepath);
      cfgpath:=FindFile('*.rcfg', cfgpath, 1);
      if not RStateConfig then
      begin
        ecm;
        ir:=getIR;
        pstr:=lpcstr(StrToAnsi(cfgpath));
        ir.ImportSettings(pstr, //IESF_DEFAULTSETTINGS+
                                IESF_LOCAL_MODE);
        GPluginInstance.Notify(PN_RCLOADCONFIG, 0);
        lcm;
      end;
    end;
  end;
end;

constructor TMBaseControl.Create(Aowner: tcomponent);
var
  c: TRConnection;
begin
  inherited;

  g_MBaseControl := self;
  curObj := nil;
  curTest := nil;
  curReg := nil;

  m_counted := false;
  finit := false;
  fLoaded:=false;
  InitPropSG(ObjPropSG);
  InitPropSG(TestPropSG);
  InitPropSG(RegPropSG);

  m_base := cMBase.Create;

  rc_pan := cRegController.Create;
  rc_pan.OnCreateConnection := doCreateConnection;
  c := rc_pan.createConnection('LocalRC', 'LocalRC', localhost,
    DEF_PORT_RECORDER);
  c.OnDelete := doDeleteRConnection;
  // showRegistrators;
  rc_pan.OnReceive := doOnRead;
  if RcClientFrm<>nil then
  begin
    RcClientFrm.init(rc_pan);
  end;

  CreateEvents;
  CallPlgEvents(E_MDBCreate);

end;

destructor TMBaseControl.destroy;
begin
  g_MBaseControl:=nil;

  if m_base <> nil then
  begin
    m_base.destroy;
    m_base := nil;
  end;
  if rc_pan <> nil then
  begin
    rc_pan.destroy;
    rc_pan := nil;
  end;

  cMBaseFactory(m_f).decFrmCounter;
  DestroyEvents;
  inherited;
end;

procedure TMBaseControl.CreateEvents;
begin
  AddPlgEvent('MDBSaveXmlDscFiles', c_RC_SaveCfg, doSaveCfg);
  AddPlgEvent('TMBaseControl_doChangeRState', c_RC_DoChangeRCState,
    doChangeRCState);
  m_base.Events.AddEvent('TMBaseControl_AddPropertieEvent',
                          E_AddNotifyPropertieEvent
                          + E_ChangePropertieEvent
                          ,
                          doAddPropertie);
end;

procedure TMBaseControl.DestroyEvents;
begin
  RemovePlgEvent(doSaveCfg, c_RC_SaveCfg);
  RemovePlgEvent(doChangeRCState, c_RC_DoChangeRCState);
  if m_base <> nil then
    m_base.Events.removeEvent(doAddPropertie,
                              E_AddNotifyPropertieEvent
                              + E_ChangePropertieEvent
                              )
end;

procedure TMBaseControl.doAddPropertie(Sender: TObject);
begin
  ShowObjProps(cXmlFolder(Sender));
end;

procedure TMBaseControl.doChangeRCState(Sender: TObject);
var
  newstate, statechange: dword;
  rcStateChange: TRCstateChange;
begin
  LogRecorderMessage('TMBaseControl.doChangeRCState_enter');
  newstate := RState;
  case m_rstate of
    RS_STOP:
      begin
        case newstate of
          RS_VIEW:
            rcStateChange := RSt_StopToView;
          RS_REC:
            rcStateChange := RSt_StopToRec;
        end;
      end;
    RS_VIEW:
      begin
        case newstate of
          RS_VIEW:
            rcStateChange := RSt_ViewToStop;
          RS_REC:
            rcStateChange := RSt_ViewToRec;
        end;
      end;
    RS_REC:
      begin
        case newstate of
          RS_VIEW:
            rcStateChange := RSt_RecToView;
          RS_STOP:
            rcStateChange := RSt_RecToStop;
        end;
      end;
    0:
      begin
        case newstate of
          RS_VIEW:
            rcStateChange := RSt_initToView;
          RS_STOP:
            rcStateChange := RSt_initToStop;
          RS_REC:
            rcStateChange := RSt_initToRec;
        end;
      end;
  end;
  m_rstate := newstate;
  case rcStateChange of
    RSt_Init:
      ;
    RSt_StopToView:
      ;
    RSt_StopToRec:
      createReg;
    RSt_ViewToStop:
      ;
    RSt_ViewToRec:
      createReg;
    RSt_initToRec:
      createReg;
    RSt_RecToStop:
      begin
        createSubRegs;
        setcurReg(m_reg);
        doStopRec(self);
      end;
    RSt_RecToView:
      begin
        createSubRegs;
        setcurReg(m_reg);
      end;
  end;
  rc_pan.Read;
  showRegistrators;
  LogRecorderMessage('TMBaseControl.doChangeRCState_exit');
end;

procedure TMBaseControl.doCreateConnection(Sender: TObject);
begin
  showRegistrators;
end;

procedure TMBaseControl.doOnRead(connection: TRConnection; msg: tmsgHeader);
var
  index: Integer;
  li: TListItem;
begin
  LogRecorderMessage('TMBaseControl.doOnRead_enter');
  index := rc_pan.getConnectionIndex(connection);
  li := RegistratorsLV.Items[index];
  if li = nil then
    exit;
  case msg.code of
    CODE_NOTIFY_STATE:
      begin
        case connection.state of
          CODE_COMMAND_STOP:
            begin
              li.ImageIndex := c_img_stop;
              RegistratorsLV.SetSubItemByColumnName('ѕуть',
                rc_pan.getConnectionPath(index), li);
              LVChange(RegistratorsLV);
            end;
          CODE_COMMAND_VIEW:
            li.ImageIndex := c_img_view;
          CODE_COMMAND_RECORD:
            li.ImageIndex := c_img_rec;
          CODE_COMMAND_PLAY:
            li.ImageIndex := c_img_view;
        end;
      end;
    CODE_NOTIFY_FILE:
      begin
        RegistratorsLV.SetSubItemByColumnName('ѕуть',
          rc_pan.getConnectionPath(index), li);
        LVChange(RegistratorsLV);
      end;
  end;
  LogRecorderMessage('TMBaseControl.doOnRead_exit');
end;

procedure TMBaseControl.doSaveCfg(Sender: TObject);
begin
  m_base.UpdateXMLDescriptors;
  if assigned(fSaveCfg) then
  begin
    fSaveCfg(self);
  end;
end;

procedure TMBaseControl.doStopRec(Sender: TObject);
var
  t, lastcfg: cxmlfolder;
  b:boolean;
  cfgpath:string;
begin
  if assigned(fOnStopRec) then
  begin
    fOnStopRec(Sender);
  end;
  t := TMBaseControl(sender).GetSelectTest;
  lastcfg := cxmlfolder(t.getChildrenByCaption('Lastcfg'));
  if lastcfg = nil then
  begin
    lastcfg := cLastCfgFolder.create;
    // lastcfg.path := path;
    lastcfg.name := 'Lastcfg';
    t.AddChild(lastcfg);
  end;
  cfgpath := lastcfg.getProperty('PrevCfg', b);
  if not b then
  begin
    cfgpath := extractfiledir(getRConfig);
    copydir(cfgpath, lastcfg.Absolutepath, 0);
    lastcfg.addpropertie('PrevCfg', getRConfig);
    lastcfg.CreateFiles;
  end
  else
  begin
    if cfgpath <> getRConfig then
    begin
      cfgpath := extractfiledir(getRConfig);
      if cfgpath<>lastcfg.absolutepath then
      begin
        copydir(cfgpath, lastcfg.Absolutepath, 0);
        lastcfg.addpropertie('PrevCfg', getRConfig);
      end;
    end;
  end;
end;

procedure TMBaseControl.doUpdateData(Sender: TObject);
begin

end;

procedure TMBaseControl.DownloadRegsBtnClick(Sender: TObject);
begin
  if DownloadRegsFrm<>nil then
    DownloadRegsFrm.ShowDB(m_base);
end;

function TMBaseControl.EmptyReg: cregFolder;
var
  I: Integer;
  r: cregFolder;
begin
  result := nil;
  for I := 0 to RegNameEdit.Items.Count - 1 do
  begin
    r := cregFolder(RegNameEdit.Items.Objects[I]);
    if r.empty then
    begin
      result := r;
      exit;
    end;
  end;
end;

procedure TMBaseControl.FillObjectsCB;
var
  I: Integer;
  o: cXmlFolder;
  p: tnotifyevent;
begin
  ObjNameCB.Clear;
  p := ObjNameCB.OnChange;
  ObjNameCB.OnChange := nil;
  for I := 0 to m_base.Count - 1 do
  begin
    o := cXmlFolder(m_base.getobj(I));
    if o is cObjFolder then
    begin
      ObjNameCB.Items.AddObject(o.caption, o);
    end;
  end;
  ObjNameCB.OnChange := p;
end;

procedure TMBaseControl.FillRegCB(t: cTestFolder);
var
  r: TObject;
  I: Integer;
  p: tnotifyevent;
begin
  p := RegNameEdit.OnChange;
  RegNameEdit.OnChange := nil;
  RegNameEdit.Items.Clear;
  if t = nil then
  begin
  end
  else
  begin
    for I := 0 to t.ChildCount - 1 do
    begin
      r := (t.getChild(I));
      if r is cregFolder then
        RegNameEdit.Items.AddObject(cregFolder(r).caption, r);
    end;
  end;
  RegNameEdit.OnChange := p;
  setComboBoxItem(RegNameEdit.text, RegNameEdit);
end;

procedure TMBaseControl.FillTestsCB(o: cObjFolder);
var
  t: cTestFolder;
  I: Integer;
  p: tnotifyevent;
begin
  p := TestNameCB.OnChange;
  TestNameCB.OnChange := nil;
  TestNameCB.Items.Clear;
  if o = nil then
  begin
  end
  else
  begin
    for I := 0 to o.ChildCount - 1 do
    begin
      t := cTestFolder(o.getChild(I));
      TestNameCB.Items.AddObject(t.caption, t);
    end;
  end;
  TestNameCB.OnChange := p;
  setComboBoxItem(TestNameCB.text, TestNameCB);
end;

procedure TMBaseControl.createReg;
var
  test: cTestFolder;
  date: tdatetime;
  path: string;
begin
  test := GetSelectTest;
  if test <> nil then
  begin
    path := createRegName(test.Absolutepath, test);
    if m_reg <> nil then
    begin
      if m_reg.Absolutepath <> path then
      begin
        m_reg := nil
      end
      else
      begin
        // нельз€ писать в регистрацию котора€ уже содержит данные
        if not m_reg.empty then
          m_reg := nil;
      end;
    end;
    if m_reg = nil then
    begin
      m_reg := cregFolder.Create;
      // m_reg.name:=extractfilename(createRegName(test.Absolutepath));

      m_reg.path := path;

      test.AddChild(m_reg);
      m_reg.fscanFolders := false;
      m_reg.fscanFiles := false;
      m_reg.CreateFiles;
      RegNameEdit.AddItem(m_reg.caption, m_reg);
      setcurReg(m_reg);
    end;
  end;
end;

function TMBaseControl.createRegName(basepath: string; t: cTestFolder): string;
var
  fld: string;
  date: tdatetime;
  lmodname: Boolean;
  reg: cregFolder;
begin
  if RegNameEdit.text <> '' then
  begin
    fld := RegNameEdit.text;
  end
  else
  begin
    date := now;
    fld := DateTimeToStr(date);
    fld := replaceChar(fld, ':', '.');
    fld := 'Reg';
  end;
  basepath := AddSlashToPath(basepath);
  result := basepath + fld;
  lmodname := false;
  while DirectoryExists(result) do
  begin
    reg := cregFolder(m_base.getchildbypath(result));
    if reg <> nil then
    begin
      if reg.empty then
      begin
        result := reg.Absolutepath;
        exit;
      end;
    end;
    result := modname(result, false);
    lmodname := true;
  end;
  if lmodname then
  begin
    // RegNameEdit.text := extractDirName(result);
  end;
end;

procedure TMBaseControl.createSubRegs;
var
  I: Integer;
  lname, lpath, lfolder: string;
begin
  if m_reg <> NIL then
  BEGIN
    for I := 0 to rc_pan.Count - 1 do
    begin
      lname := rc_pan.getConnectionName(I);
      lpath := rc_pan.getConnectionPath(I);
      lfolder := rc_pan.getConnectionFolder(I);
      m_reg.AddSignal(lname, lpath, lfolder);
    end;
    m_reg.CreateFiles;
  END;
end;

function TMBaseControl.GetSelectObj: cObjFolder;
begin
  result := cObjFolder(m_base.m_BaseFolder.getChildrenByName(ObjNameCB.text));
end;

function TMBaseControl.GetSelectReg: cregFolder;
var
  t: cTestFolder;
begin
  result := nil;
  t := GetSelectTest;
  if t <> nil then
  begin
    result := cregFolder(t.getChildrenByCaption(RegNameEdit.text));
    if result = nil then
    begin
      createReg;
      result := m_reg;
    end;
  end;
end;

function TMBaseControl.GetSelectTest: cTestFolder;
var
  o: cObjFolder;
  t: cXmlFolder;
begin
  result := nil;
  o := GetSelectObj;
  if o <> nil then
  begin
    if (o is cObjFolder) then
    begin
      t := cXmlFolder(o.getChildrenByCaption(TestNameCB.text));
      if t is cTestFolder then
      begin
        result := cTestFolder(t);
      end;
    end;
  end;
end;

procedure TMBaseControl.mdbBtnClick(Sender: TObject);
begin
  if MDBFrm<>nil then
    MDBFrm.ShowMDB(m_base);
end;

function GetOsVersion: integer;
var
  str: string;
  VersionInformation: OSVERSIONINFO;
begin
  VersionInformation.dwOSVersionInfoSize := sizeof(VersionInformation);
  GetVersionEx(VersionInformation);
  // str:='OS Version '+
  // intToStr(VersionInformation.dwMajorVersion)+'.'+
  // intToStr(VersionInformation.dwMinorVersion)+' '+VersionInformation.szCSDVersion;
  // Result:=str;
  result := VersionInformation.dwMajorVersion;
end;

function SelectDirectoryLoc(const Title: string; var Path: string): boolean;
var
  lpItemID, start: PItemIDList;
  BrowseInfo: TBrowseInfo;
  DisplayName: array [0 .. MAX_PATH] of char;
  TempPath: array [0 .. MAX_PATH] of char;
begin
  FillChar(BrowseInfo, sizeof(TBrowseInfo), #0);
  BrowseInfo.pszDisplayName := @Path[1];
  BrowseInfo.hwndOwner := 0;
  BrowseInfo.lpszTitle := PChar(Title);

  // BrowseInfo.pidlRoot:=start;
  BrowseInfo.ulFlags := BIF_RETURNONLYFSDIRS;
  lpItemID := SHBrowseForFolder(BrowseInfo);
  result := lpItemID <> nil;
  if result then
  begin
    SHGetPathFromIDList(lpItemID, TempPath);
    Path := TempPath;
    GlobalFreePtr(lpItemID);
  end;
end;

procedure TMBaseControl.MdbPathBtnClick(Sender: TObject);
var
  str:string;
begin
  if GetOsVersion >= 6 then
  begin
    OpenDialog1vista.filename := BaseFolderEdit.Text;
    OpenDialog1vista.Options := [fdoPickFolders, fdoForceFileSystem];
    if OpenDialog1vista.Execute() then
    begin
      BaseFolderEdit.Text := OpenDialog1vista.filename;
    end;
  end
  else
  begin
    // OpenDialog1.Options := [ofOldStyleDialog, fdoForceFileSystem];
    str := BaseFolderEdit.Text;
    // if SelectDirectory('¬ыбор базового каталога', '',str) then
    if SelectDirectoryLoc('¬ыбор базового каталога', str) then
    begin
      BaseFolderEdit.Text := str;
    end;
  end;
end;

procedure TMBaseControl.ObjPropSGEndEdititng(Sender: TObject;
  ACol, ARow: Integer; var CanSelect: Boolean);
var
  obj: cXmlFolder;
  sg: TStringGridExt;
  prop, val: string;
  I, ind: Integer;
begin
  obj := nil;
  sg := TStringGridExt(Sender);
  if (ARow = sg.rowcount - 1) then
  begin
    // добавить строку
    if not sg.rowempty(ARow) then
    begin
      sg.rowcount := sg.rowcount + 1;
      sg.eraseRow(sg.rowcount - 1);
    end;
  end;
  if (ARow = sg.rowcount - 2) then
  begin
    // удалить строку
    if sg.rowempty(ARow) then
    begin
      if sg.rowempty(ARow + 1) then
      begin
        sg.rowcount := sg.rowcount - 1;
      end;
    end;
  end;

  if Sender = ObjPropSG then
  begin
    obj := GetSelectObj;
  end;
  if Sender = TestPropSG then
  begin
    obj := GetSelectTest;
  end;
  if Sender = RegPropSG then
  begin
    obj := GetSelectReg;
  end;
  prop := '';
  val := '';
  if obj <> nil then
  begin
    prop := sg.Cells[c_col_propName, ARow];
    val := sg.Cells[c_col_propVal, ARow];
    if ACol = c_col_propName then
    begin
      ind := obj.FindPropertie(prop);
      // модифицируем им€ только в том случае если вписано свойство с повторившимс€ именем в новую €чейку
      if ind <> -1 then
      begin
        if ind <> ARow - 1 then
        begin
          while obj.FindPropertie(prop) <> -1 do
          begin
            prop := modname(prop, false);
          end;
          sg.Cells[c_col_propName, ARow] := prop;
        end;
      end;
    end;
    if (prop <> '') and (val <> '') then
    begin
      obj.addpropertie(prop, val);
    end;
    if (prop = '') and (val = '') then
    begin
      if ind <> -1 then
      begin
        obj.delpropertie(ARow - 1);
        sg.deleteRow(ARow);
      end;
    end;
  end;
  SGChange(sg);
end;

procedure TMBaseControl.ObjNameCBChange(Sender: TObject);
var
  o: cObjFolder;
  b: Boolean;
begin
  b := CheckCBItemInd(ObjNameCB);
  if b then
  begin
    o := cObjFolder(ObjNameCB.Items.Objects[ObjNameCB.itemindex]);
    setcurObj(o);
  end
  else
  begin
    o := nil;
    FillTestsCB(o);
  end;
  CheckCBItemInd(TestNameCB);
  TestNameCBChange(nil);
end;

procedure TMBaseControl.RegNameEditChange(Sender: TObject);
var
  r: cregFolder;
  b: Boolean;
begin
  b := CheckCBItemInd(RegNameEdit);
  if b then
  begin
    r := cregFolder(RegNameEdit.Items.Objects[RegNameEdit.itemindex]);
    setcurReg(r);
  end
  else
  begin
    r := nil;
    setcurReg(r);
  end;
end;

procedure TMBaseControl.ObjPropSGKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
var
  sg: TStringGridExt;
  obj: cXmlFolder;
begin

  obj := nil;

  sg := TStringGridExt(Sender);
  if sg.row = 0 then
    exit;
  if Key = VK_DELETE then
  begin
    if Sender = ObjPropSG then
    begin
      obj := GetSelectObj;
    end;
    if Sender = TestPropSG then
    begin
      obj := GetSelectTest;
    end;
    if Sender = RegPropSG then
    begin
      obj := GetSelectReg;
    end;
    if obj <> Nil then
    begin
      if not sg.EditorMode then
        obj.delpropertie(sg.row - 1);
    end;
    if sg.rowcount = 1 then
      sg.rowcount := 2;
  end;
end;

procedure TMBaseControl.ObjRenameBtnClick(Sender: TObject);
var
  I: Integer;
  o: TObject;
begin
  if curObj <> nil then
  begin
    curObj.name := ObjNameCB.text;
    curObj.renameDirAndDsc(ObjNameCB.text);
    RenameComboBoxItem(ObjNameCB.text, curObj, ObjNameCB);
  end;
end;

procedure TMBaseControl.SaveSettings(a_pIni: TIniFile; str: LPCSTR);
var
  section: string;
  I: Integer;
  c: TRConnection;
begin
  inherited;
  section := String(str);
  a_pIni.WriteInteger(section, 'MBaseSetPropertiesNotify',
    v_NotifyMBaseSetProperties);
  a_pIni.WriteString(section, 'BaseFolder', BaseFolderEdit.text);
  a_pIni.WriteString(section, 'ObjName', ObjNameCB.text);
  a_pIni.WriteString(section, 'TestType', TestTypeCB.text);
  a_pIni.WriteString(section, 'TestName', TestNameCB.text);
  a_pIni.WriteString(section, 'RegName', RegNameEdit.text);
  if rc_pan.Count > 1 then
  begin
    a_pIni.WriteInteger(section, 'ConnectionCount', rc_pan.Count);
    for I := 0 to rc_pan.Count - 1 do
    begin
      c := rc_pan.getconnection(I);
      a_pIni.WriteString(section, 'ConName' + inttostr(I),
        rc_pan.getConnectionName(I));
      a_pIni.WriteString(section, 'ConFld' + inttostr(I), c.folder);
      a_pIni.WriteString(section, 'ConHost' + inttostr(I), c.Address);
      a_pIni.WriteInteger(section, 'ConPort' + inttostr(I), c.port);
    end;
  end;
end;

procedure TMBaseControl.setcurObj(o: cObjFolder);
begin
  curObj := o;
  ShowObjProps(o);
  FillTestsCB(cObjFolder(o));
end;

procedure TMBaseControl.setcurReg(r: cregFolder);
var
  lemptyreg: cregFolder;
  t: cTestFolder;
  emtyname: string;
begin
  m_reg := r;
  if r = nil then
  begin
    t := GetSelectTest;
    if t <> nil then
    begin
      emtyname := extractfilename(createRegName(t.Absolutepath, t));
      RegNameEdit.Hint := '—ледующа€ регистраци€: ' + emtyname;
      RegNameEdit.ShowHint := true;
    end;
    exit;
  end;
  RegNameEdit.text := r.caption;
  setComboBoxItem(r.caption, RegNameEdit);
  ShowObjProps(r);
  AlarmCB.Checked := r.m_alarm;
  AlarmCBClick(nil);
  if r.m_alarm then
  begin
    AlarmDsc.text := r.m_alarmDsc;
    setComboBoxItem(r.m_alarmType, AlarmType);
  end;
  if not r.empty then
  begin
    lemptyreg := EmptyReg;
    RegNameEdit.ShowHint := true;
    if lemptyreg = nil then
    begin
      t := GetSelectTest;
      emtyname := extractfilename(createRegName(t.Absolutepath, t));
    end
    else
      emtyname := lemptyreg.caption;
    RegNameEdit.Hint :=
      'Ќевозможно записать в завершенную регистрацию. «апись будет произведена в регистрацию: ' + emtyname;
    RegNameEdit.Color := clGray;
  end
  else
  begin
    RegNameEdit.ShowHint := false;
    RegNameEdit.Color := clWindow;
  end;
end;

procedure TMBaseControl.setcurTest(t: cTestFolder);
var
  lastcfg: cxmlfolder;
  b:boolean;
  cfgpath:string;
begin
  curTest := t;
  if t=nil then exit;

  ShowObjProps(t);

  FillRegCB(cTestFolder(t));

  lastcfg := cxmlfolder(t.getChildrenByCaption('Lastcfg'));
  if lastcfg <> nil then
  begin
    cfgpath:=extractfiledir(lastcfg.Absolutepath);
    cfgpath:=FindFile('*.rcfg', cfgpath, 1);
    CfgSB.Hint:=' онфигураци€ испытани€: '+cfgpath;
  end
  else
  begin
    CfgSB.Hint:=' онфигураци€ испытани€:';
  end;
end;

procedure TMBaseControl.settestsettings(t: cTestFolder);
begin
  t.name := TestNameCB.text;
  t.m_testType := TestTypeCB.text;
end;

procedure TMBaseControl.LoadSettings(a_pIni: TIniFile; str: LPCSTR);
var
  lstr, section, host, conname, folder: string;
  I, port, ccount: Integer;
  obj, t: cXmlFolder;
  con: TRConnection;
  localR: Boolean;
  c: TRConnection;
begin
  //exit;
 inherited;
  if fLoaded then exit;
  logrecordermessage('TMBaseControl.LoadSettings_enter');

  section := String(str);
  v_NotifyMBaseSetProperties := a_pIni.ReadInteger(section,
    'MBaseSetPropertiesNotify', 101);
  BaseFolderEdit.text := a_pIni.ReadString(section, 'BaseFolder', '');

  m_base.InitBaseFolder(BaseFolderEdit.text);

  FillObjectsCB;
  lstr := a_pIni.ReadString(section, 'ObjName', '');
  setComboBoxItem(lstr, ObjNameCB);
  obj := cXmlFolder(m_base.m_BaseFolder.getChild(lstr));
  setcurObj(cObjFolder(obj));

  lstr := a_pIni.ReadString(section, 'TestName', '');
  setComboBoxItem(lstr, TestNameCB);
  TestTypeCB.text := a_pIni.ReadString(section, 'TestType', '');
  t:=GetSelectTest;
  if t<>nil then
    setcurTest(ctestfolder(t));

  RegNameEdit.text := a_pIni.ReadString(section, 'RegName', '');
  obj := GetSelectTest;
  if obj <> nil then
  begin
    ShowObjProps(obj);
  end;
  FillRegCB(cTestFolder(obj));

  ccount := a_pIni.ReadInteger(section, 'ConnectionCount', 0);
  if ccount > 0 then
  begin
    for I := 0 to ccount - 1 do
    begin
      localR := false;
      conname := a_pIni.ReadString(section, 'ConName' + inttostr(I), '');
      folder := a_pIni.ReadString(section, 'ConFld' + inttostr(I), '');
      host := a_pIni.ReadString(section, 'ConHost' + inttostr(I), '');
      port := a_pIni.ReadInteger(section, 'ConPort' + inttostr(I), 0);
      // если прочитали дефолтный регистратор
      if (host = '127.0.0.1') or (lowercase(host) = 'localhost') then
      begin
        if port = DEF_PORT_RECORDER then
        begin
          localR := true;
          con := rc_pan.getconnection(0);
          con.folder := folder;
        end;
      end;
      if not localR then
      begin
        c := rc_pan.createConnection(conname, folder, host, port);
        c.OnDelete := doDeleteRConnection;
      end;
    end;
  end;
  showRegistrators;
  fLoaded:=true;
  logrecordermessage('TMBaseControl.LoadSettings_exit');
end;

procedure TMBaseControl.ShowObjProps(o: cXmlFolder);
var
  sg: TStringGridExt;
  I: Integer;
begin
  exit;
  sg:=nil;
  if o = nil then
    exit;
  if o is cObjFolder then
  begin
    sg := ObjPropSG;
  end;
  if o is cTestFolder then
  begin
    sg := TestPropSG;
  end;
  if o is cregFolder then
  begin
    sg := RegPropSG;
  end;
  if sg<>nil then
  begin
    sg.rowcount := 2;
    sg.rowcount := o.PropCount + 2;
    for I := 0 to o.PropCount - 1 do
    begin
      sg.Cells[c_col_propName, I + 1] := o.getPropertyName(I);
      sg.Cells[c_col_propVal, I + 1] := o.getProperty(I);
    end;
    sg.Cells[c_col_propName, sg.rowcount - 1] := '';
    sg.Cells[c_col_propVal, sg.rowcount - 1] := '';
  end;
end;

procedure TMBaseControl.doDeleteRConnection(Sender: TObject);
begin
  showRegistrators;
end;

procedure TMBaseControl.DoGetNotify(data: dword);
var
  MBaseNotify: TMBaseNotify;
  pars: TStringList;
  I, j, p, PropCount: Integer;
  str, param: string;

  obj: cXmlFolder;
  callevent: Boolean;
begin
  callevent := false;
  MBaseNotify := TMBaseNotify(pointer(data)^);

  // парсим значени€ в tstringlist
  I := 0;
  pars := TStringList.Create;
  if MBaseNotify.ObjID = 'curobj' then
  begin
    obj := GetSelectObj;
  end
  else
  begin
    if MBaseNotify.ObjID = 'curtest' then
    begin
      obj := GetSelectTest;
    end
    else
    begin
      if MBaseNotify.ObjID = 'curreg' then
      begin
        obj := GetSelectReg;
      end;
    end;
  end;
  if obj = nil then
    exit;

  while I <= length(MBaseNotify.Operation) do
  begin
    str := GetSubString(MBaseNotify.Operation, ';', I, I);
    pars.Add(str);
    str := GetSubString(MBaseNotify.Operation, ';', I + 1, I);
    pars.Add(str);
    if I = -1 then
      break;
  end;

  if MBaseNotify.OperType = 0 then
  begin
    PropCount := round(pars.Count / 2);
    for I := 0 to PropCount - 1 do
    begin
      obj.addpropertie(pars.Strings[I * 2], pars.Strings[(I * 2 + 1)]);
      callevent := true;
    end;
  end;
  if MBaseNotify.OperType = 1 then
  begin
    for I := 0 to pars.Count - 1 do
    begin
      obj.delpropertie(pars.Strings[I]);
      callevent := true;
    end;
  end;
  if callevent then
    m_base.Events.CallAllEventsWithSender(E_AddNotifyPropertieEvent, obj);
end;

procedure TMBaseControl.showRegistrators;
var
  I: Integer;
  s: string;
  li: TListItem;
begin
  RegistratorsLV.Clear;
  for I := 0 to rc_pan.Count - 1 do
  begin
    li := RegistratorsLV.Items.Add;

    s := rc_pan.getConnectionName(I);
    li.data := rc_pan.getconnection(I);
    RegistratorsLV.SetSubItemByColumnName(c_col_regname, s, li);
    s := rc_pan.getConnectionFolder(I);
    RegistratorsLV.SetSubItemByColumnName(c_col_folder, s, li);
    if rc_pan.Connected(I) then
    begin
      // 1 - connected
      li.ImageIndex := 1;
      case rc_pan.getConnectionState(I) of
        CODE_COMMAND_STOP:
          li.ImageIndex := c_img_stop;
        CODE_COMMAND_VIEW:
          li.ImageIndex := c_img_view;
        CODE_COMMAND_RECORD:
          li.ImageIndex := c_img_rec;
        CODE_COMMAND_PLAY:
          li.ImageIndex := c_img_view;
      end;
    end
    else
    begin
      li.ImageIndex := 0;
    end;
  end;
  LVChange(RegistratorsLV);
end;

procedure TMBaseControl.SpeedButton1Click(Sender: TObject);
var
  n: TMBaseNotify;
begin
  rc_pan.stop;

  n.ObjID := 'curobj';
  // обавление свойств
  n.OperType := 1;
  n.Operation := 'TestNotify';
  sendMDBNotifyMessage(n);
end;

procedure TMBaseControl.Splitter4Moved(Sender: TObject);
begin
  synchroniseSplitters(Sender);
end;

procedure TMBaseControl.StopBtnClick(Sender: TObject);
// var
// n:TMBaseNotify;
begin
  rc_pan.stop;

  // n.ObjID:='curobj';
  // обавление свойств
  // n.OperType:=0;
  // n.Operation:='TestNotify;1';
  // sendNotifyMessage(n);
end;

procedure TMBaseControl.synchroniseSplitters(Sender: TObject);
var
  w: Integer;
begin
  if Sender = Splitter6 then
  begin
    w := ObjPanel.Width;
  end;
  if Sender = Splitter5 then
  begin
    w := TestPanel.Width;
  end;
  if Sender = Splitter4 then
  begin
    w := RegPanel.Width;
  end;
  RegPanel.Width := w;
  ObjPanel.Width := w;
  TestPanel.Width := w;
end;

procedure TMBaseControl.TestNameCBChange(Sender: TObject);
var
  t: cTestFolder;
  b: Boolean;
  r: cregFolder;
begin
  b := CheckCBItemInd(TestNameCB);
  if b then
  begin
    t := cTestFolder(TestNameCB.Items.Objects[TestNameCB.itemindex]);
    setcurTest(t);
    r := EmptyReg;
    setcurReg(r);
  end
  else
  begin
    t := nil;
    FillRegCB(t);
  end;
  CheckCBItemInd(TestNameCB);
end;

procedure TMBaseControl.TestTypeCBChange(Sender: TObject);
var
  t: cTestFolder;
begin
  FillRegCB(t);
end;

procedure TMBaseControl.Timer1Timer(Sender: TObject);
begin
  //LogRecorderMessage('TMBaseControl.Timer1Timer_enter');
  if rc_pan <> nil then
  begin
    rc_pan.connect;
    rc_pan.Read;
  end;
  //LogRecorderMessage('TMBaseControl.Timer1Timer_exit');
end;

procedure TMBaseControl.ViewBtnClick(Sender: TObject);
begin
  //logmessage(' TMBaseControl.ViewBtnClick_enter');
  rc_pan.start;
  //logmessage(' TMBaseControl.ViewBtnClick_exit');
end;

procedure TMBaseControl.RecordBtnClick(Sender: TObject);
begin
  rc_pan.rec;
end;

procedure TMBaseControl.RegistratorsLVDblClickProcess(item: TListItem;
  lv: TListView);
var
  c: TRConnection;
begin
  if RStateStop then
  begin
    if RcClientFrm<>nil then
    begin
      RcClientFrm.editConnection(TRConnection(item.data));
      c := RcClientFrm.m_curConnection;
      c.OnDelete := doDeleteRConnection;
    end;
  end;
end;

procedure InitPropSG(sg: tstringgrid);
begin
  sg.FixedCols := 0;
  sg.FixedRows := 1;
  sg.Options := sg.Options + [goediting] + [gocolsizing];
  sg.rowcount := 2;
  sg.ColCount := 2;
  sg.Cells[c_col_propName, 0] := '—войство';
  sg.Cells[c_col_propVal, 0] := '«начение';
end;

end.
