unit uBaseAlg;

interface

uses
  classes, Windows, tags, uBaseObj, uBaseObjMng, activeX, nativexml, uRCFunc,
  pluginclass, blaccess, sysutils, uCommonTypes, uFFT, ap, fft,
  urecorderevents,
  uCommonMath,
  uMyMath,
  mathfunction,
  math,
  uHardwareMath,
  complex,
  u2dmath;

type
  // для добавления алгоритма
  // 1) TAlgFrm.create() зарегить фрейм
  // 2) cAlgMng.regObjClasses зарегить алгоритм;
  // * связывание алгоритма и фрейма происходит по сравнению classname и algClass фрейма
  // компонент расчета частотной полосы k1*f1+kn*fn
  BandTag = class
  protected
    m_it: itag;
    m_id: TAGID;
    m_t: string;
  protected
    procedure settagname(s: string);
  public
    k: double;
  public
    Constructor create;
    destructor destroy;
    property tagname: string read m_t write settagname;
  end;

  tBand = class
  private
    m_TagsList: tstringlist;
  public
    m_owner: tstringlist;
    m_f1f2: point2d;
    m_resultBand: point2d;
    // расчетное значение максимальной частоты
    m_MainFreq: double;
    // относительный абсолютный
    valtype: integer;
    name: string;
  public
    function tagCount:integer;
    procedure eval;
    procedure clearTags;
    procedure addBandTag(bt: BandTag);
    function getbandtag(i: integer): BandTag;
    constructor create(owner: tstringlist);
    destructor destroy;
  end;
  // список мест установки датчиков
  // каждое место установки датчиков знает список полос частотных tBand
  TPlace = class
  public
    owner: tlist;
    name: string;
    bands: tlist;
  public
    function Bandcount: integer;
    procedure addband(b: tBand);
    procedure delband(b: tBand);
    function getBand(i: integer): tBand;
    constructor create(p_owner: tlist);
    destructor destroy;
  end;

  // список мест куда установлены датчики
  TPlaces = class(tlist)
  public
    procedure addplace(p: TPlace);
    function getplace(str: string): TPlace; overload;
    function getplace(i: integer): TPlace; overload;
    destructor destroy;
  end;

  TTagBandPair = class
  protected
    m_places: tlist;
    m_owner: tlist;
    m_t: string;
    m_it: itag;
    m_id: TAGID;
  public
    m_p: TPlace;
  protected
    function getname: string;
    procedure setname(s: string);
    procedure setId(id: TAGID);
  public
    procedure settag(t: itag);
    procedure addplace(p: TPlace);
    function removeplace(p: TPlace): boolean;
    function getplace(i: integer): TPlace;
    function placeCount: integer;
    property id: TAGID read m_id write setId;
    property name: string read getname write setname;
    constructor create;
    destructor destroy;
  end;

  TTagBandPairList = class(tlist)
  public
    function newPair: TTagBandPair;
    function getPair(i: integer): TTagBandPair; overload;
    function getPair(tagname: string): TTagBandPair; overload;
    destructor destroy;
  end;

  tAHUnit = (AHmult, // множитель на который надо домножить значение
    AH10db, // units=10lg(Ares/A)
    AH20db, // units=20lg(Ares/A)
    AHpercent); // scale=(1-percent/100)

  cAHgrad = class
  public
    m_name: string;
    m_points: array of point2d;
    m_units: tAHUnit;
  protected
    function getsize: integer;
    procedure setsize(s: integer);
    function getUnitString: string;
  public
    Function CorrectValue(v, freq: double): double;
    Function GetMultDsc(i: integer): string; overload;
    Function GetMultDsc(freq: double): string; overload;
    property size: integer read getsize write setsize;
    property units: string read getUnitString;
    constructor create(name: string);
    destructor destroy;
  end;

  TBaseAlgContainerClass = class of cBaseAlgContainer;

  cBaseAlgContainer = class(cBaseObj)
  public
    // список алгоритмов кот передают данные по подписке сюда
    m_refList: tlist;
  protected
    m_errors: tstringlist;
    m_properties: string;
    // список алгоритмов кот подписаны на обновлеение данных
    m_SubscribeList: tlist;
  protected
    procedure doAfterload; virtual;
    procedure UpdatePropStr; virtual;
    procedure SetProperties(str: string); virtual;
    function GetProperties: string; virtual; abstract;
    procedure Setdx(d: double); virtual; abstract;
    function Getdx: double; virtual; abstract;
    procedure LoadObjAttributes(xmlNode: txmlNode; mng: tobject); override;
    procedure SaveObjAttributes(xmlNode: txmlNode); override;
    procedure saveTags(node: txmlNode); virtual; abstract;
    procedure LoadTags(node: txmlNode); virtual; abstract;
    function genTagName: string; virtual;
    procedure doGetData; virtual; abstract;
    // происходит при переходе в просмотр/ запись
    procedure doOnStart; virtual; abstract;
    function GetResName: string; virtual;
    procedure SetResName(s: string); virtual;
    procedure DoSetProperties(sender: tobject); virtual;
    procedure doUpdateSrcData(sender: tobject); virtual;
    procedure doEndEvalBlock(sender: tobject); virtual;
    procedure CallUpdateDataEvent; virtual;
    // Вызывается при завершении расчета блока данных. За одно обновление Recorder может быть расчитано несколько блоков данных.
    // здесь сбрасываем счетчик номера блоков или другие действия завершения расчета блока
    procedure CallEndEvalBlock; virtual;
  public
    procedure setfirstchannel(t:itag);virtual;
    procedure subscribe(dst: cBaseObj); virtual;
    // отписать алгоритм от источника
    // функция завиртуалена на случай если у приемника несколько источников.
    // соответственно если ранее алгоритм был подписан на другой источник, то его сперва надо отписать от источника при этом понять от какого именно
    procedure unsubscribe(src: cBaseObj); virtual;
    // убрать у алгоритма ссылку на его источник данных
    procedure delRef(a: cBaseObj);
    function ready: boolean; virtual;
    // шаг по времени. Может быть не кратен периоду рекордера (например за период рекордера
    // получаем несколько отсчетов)
    property dX: double read Getdx write Setdx;
    class function getdsc: string; virtual;
    property Properties: string read GetProperties write SetProperties;
    property resname: string read GetResName write SetResName;
    constructor create; override;
    destructor destroy; override;
  end;

  cBaseAlg = class(cBaseAlgContainer)
  protected
    m_inpTags: tstringlist;
    m_outTags: tstringlist;
  protected
    procedure doOnStart; override;
    procedure destroyTagsList;
    function getInpTag(index: integer): cTag;
    function getOutTag(index: integer): cTag;
    procedure doEval(intag: cTag; time: double); virtual;
    procedure addInputTag(t: cTag);
    procedure addOutTag(t: cTag);
    procedure doGetData; override;
    procedure saveTags(node: txmlNode); override;
    procedure LoadTags(node: txmlNode); override;
  public
    function InpTagsCount: integer;
    function OutTagsCount: integer;
    property InputTag[index: integer]: cTag read getInpTag;
    property OutputTag[index: integer]: cTag read getOutTag;
  public
    constructor create; override;
    destructor destroy; override;
  end;

  cSrcList = class(cBaseObj)
  protected
  public
    constructor create; override;
    destructor destroy; override;
  end;

  cSrcAlg = class(cBaseAlgContainer);


  cAlgMng = class(cBaseObjMng)
  public
    m_FFTPlanList:array of TFFTProp;
    // привязки тегов к ГХ. ключ - имя тега, объект - ГХ
    m_AHNames: tstringlist;
    // список ГХ
    m_AHList: tlist;

    m_srcList: cSrcList;
    m_bands: tstringlist;
    m_places: TPlaces;
    // список TTagBandPair
    m_TagBandPairList: TTagBandPairList;
  protected
    function getplace(str: string): TPlace;
    // происходит при переходе в просмотр/запись
    procedure doStart;
    procedure doStopRecord;
    procedure doChangeRState(sender: tobject);
    procedure createEvents;
    procedure DestroyEvents;
    procedure doUpdateTags(sender: tobject);
    procedure doGetData;
    procedure regObjClasses; override;
    procedure AddBaseObjInstance(obj: cBaseObj); override;
    procedure removeObj(obj: cBaseObj); override;
    procedure doRenameObj(sender: tobject); override;
    function SpmCount: integer;
    procedure doAfterLoadXML; override;
    procedure XMLSaveMngAttributes(node: txmlNode); override;
    procedure XMLlOADMngAttributes(node: txmlNode); override;

    function getBand(i: integer): tBand; overload;
    function getBand(str: string): tBand; overload;
    procedure UpdateBands;
    procedure clearbands;
  public
    function GetFFTPlan(fftCount:integer):TFFTProp;
    function getAH(i: integer): cAHgrad; overload;
    function getAH(p_name: string): cAHgrad; overload;
    function newAH(name: string): cAHgrad;
    procedure clearahlist;

    procedure AddAHName(tagname: string; AHGrad: cAHgrad);
    procedure DelAHNames(AHGrad: cAHgrad);
    function GetAHGradByTagName(tagname: string): cAHgrad;
  public
    constructor create; override;
    destructor destroy; override;
    function getSpm(str: string): cBaseAlgContainer;
    function getSpmByTagName(str: string): cBaseAlgContainer;
    function getAlg(i: integer): cBaseAlg; overload;
    function getAlg(s: string): cBaseAlg; overload;
  end;

function TAHUnToInt(u: tAHUnit): integer;
function IntToAHUn(u: integer): tAHUnit;

const
  c_wiki_spm = 0;
  c_alglib_cpxSpm = 1;
  c_abs = 0;
  c_rate = 1;
  e_OnSetAlgProperties = $00002000;
  e_OnUpdateSrcData = $00004000;
  c_debugAlg = false;
  c_fftPlan_blockLength = 10;



var
  g_algMng: cAlgMng;

implementation

uses
  uCounterAlg, uTahoAlg, uGrmsAlg, uGrmsSrcAlg, uPhaseAlg, uFillingFactorAlg,
  uSynchroPhaseAlg, uSpm, uExcessAlg;

function TAHUnToInt(u: tAHUnit): integer;
begin
  case u of
    AHmult:
      result := 0;
    AH10db:
      result := 1;
    AH20db:
      result := 2;
    AHpercent:
      result := 3;
  end;
end;

function IntToAHUn(u: integer): tAHUnit;
begin
  case u of
    0:
      result := AHmult;
    1:
      result := AH10db;
    2:
      result := AH20db;
    3:
      result := AHpercent;
  end;
end;


procedure cBaseAlgContainer.CallEndEvalBlock;
var
  i: integer;
  a: cBaseAlgContainer;
begin
  for i := 0 to m_SubscribeList.Count - 1 do
  begin
    a := cBaseAlgContainer(m_SubscribeList.items[i]);
    a.doEndEvalBlock(self);
  end;
end;

procedure cBaseAlgContainer.CallUpdateDataEvent;
var
  i: integer;
  a: cBaseAlgContainer;
begin
  for i := 0 to m_SubscribeList.Count - 1 do
  begin
    a := cBaseAlgContainer(m_SubscribeList.items[i]);
    a.doUpdateSrcData(self);
  end;
end;

constructor cBaseAlgContainer.create;
begin
  inherited;
  m_SubscribeList := tlist.create;
  m_refList := tlist.create;
  m_errors := tstringlist.create;
end;

destructor cBaseAlgContainer.destroy;
var
  i: integer;
  a: cBaseAlgContainer;
begin
  m_SubscribeList.destroy;
  m_SubscribeList := nil;

  for i := 0 to m_refList.Count - 1 do
  begin
    a := cBaseAlgContainer(m_refList.items[i]);
    a.unsubscribe(self);
  end;
  m_refList.destroy;
  m_refList := nil;

  m_errors.destroy;
  m_errors := nil;
  inherited;
end;

procedure cBaseAlgContainer.doAfterload;
begin

end;

procedure cBaseAlgContainer.doEndEvalBlock(sender: tobject);
begin

end;

procedure cBaseAlgContainer.DoSetProperties(sender: tobject);
begin
  g_algMng.Events.CallAllEventsWithSender(e_OnSetAlgProperties, sender);
end;

procedure cBaseAlgContainer.doUpdateSrcData(sender: tobject);
begin

end;

function cBaseAlgContainer.genTagName: string;
begin
  result := classname + '_Не перекрыт метод genTagName'
end;

class function cBaseAlgContainer.getdsc: string;
begin

end;

function cBaseAlgContainer.GetResName: string;
begin
  result := genTagName;
end;

procedure cBaseAlgContainer.SetProperties(str: string);
begin
  m_properties := str;
end;

procedure cBaseAlgContainer.SetResName(s: string);
begin

end;

procedure cBaseAlgContainer.subscribe(dst: cBaseObj);
var
  prevsrc: cBaseAlgContainer;
begin
  cBaseAlgContainer(dst).m_refList.add(self);
  m_SubscribeList.add(dst);
end;

procedure cBaseAlgContainer.unsubscribe(src: cBaseObj);
begin
  delRef(src);
end;

procedure cBaseAlgContainer.delRef(a: cBaseObj);
var
  i: integer;
begin
  for i := 0 to m_refList.Count - 1 do
  begin
    if m_refList.items[i] = a then
    begin
      m_refList.Delete(i);
      break;
    end;
  end;
end;

procedure cBaseAlgContainer.UpdatePropStr;
begin

end;

procedure cBaseAlgContainer.SaveObjAttributes(xmlNode: txmlNode);
begin
  inherited;
  saveTags(xmlNode);
  xmlNode.WriteAttributeString('Properties', Properties);
end;

procedure cBaseAlgContainer.setfirstchannel(t: itag);
begin

end;

procedure cBaseAlgContainer.LoadObjAttributes(xmlNode: txmlNode; mng: tobject);
begin
  inherited;
  LoadTags(xmlNode);
  Properties := xmlNode.ReadAttributeString('Properties', '');
end;

function cBaseAlgContainer.ready: boolean;
begin
  result := true;
end;

{ cBaseAlg }

procedure cBaseAlg.addInputTag(t: cTag);
var
  i: integer;
  lt: cTag;
begin
  for i := 0 to m_inpTags.Count - 1 do
  begin
    lt := InputTag[i];
    if lt = t then
      exit;
  end;
  m_inpTags.AddObject(t.tagname, t);
end;

procedure cBaseAlg.addOutTag(t: cTag);
var
  i: integer;
  lt: cTag;
begin
  for i := 0 to m_outTags.Count - 1 do
  begin
    lt := OutputTag[i];
    if lt = t then
      exit;
  end;
  m_outTags.AddObject(t.tagname, t);
end;

constructor cBaseAlg.create;
begin
  inherited;
  m_inpTags := tstringlist.create;
  m_outTags := tstringlist.create;
end;

destructor cBaseAlg.destroy;
begin
  destroyTagsList;
  inherited;
end;

procedure cBaseAlg.destroyTagsList;
var
  i: integer;
  t: cTag;
begin
  for i := 0 to InpTagsCount - 1 do
  begin
    t := InputTag[i];
    t.destroy;
  end;
  m_inpTags.Clear;
  m_inpTags.destroy;
  m_inpTags := nil;
  for i := 0 to OutTagsCount - 1 do
  begin
    t := OutputTag[i];
    t.destroy;
  end;
  m_outTags.destroy;
  m_outTags := nil;
end;

procedure cBaseAlg.doEval(intag: cTag; time: double);
begin

end;

procedure cBaseAlg.doGetData;
begin

end;

procedure cBaseAlg.doOnStart;
var
  i: integer;
  t: cTag;
begin
  for i := 0 to m_inpTags.Count - 1 do
  begin
    t := getInpTag(i);
    t.m_readyBlock := 0;
  end;
  for i := 0 to m_outTags.Count - 1 do
  begin
    t := getOutTag(i);
    t.m_readyBlock := 0;
  end;
end;

function cBaseAlg.getInpTag(index: integer): cTag;
begin
  result := cTag(m_inpTags.Objects[index]);
end;

function cBaseAlg.getOutTag(index: integer): cTag;
begin
  result := cTag(m_outTags.Objects[index]);
end;

function cBaseAlg.InpTagsCount: integer;
begin
  result := m_inpTags.Count;
end;

function cBaseAlg.OutTagsCount: integer;
begin
  result := m_outTags.Count;
end;

procedure cBaseAlg.saveTags(node: txmlNode);
var
  tnode, tagnode: txmlNode;
  i: integer;
  t: cTag;
begin
  tnode := node.NodeNew('InputTags');
  for i := 0 to m_inpTags.Count - 1 do
  begin
    t := InputTag[i];
    tagnode := tnode.NodeNew('Tag_' + inttostr(i));
    saveTag(t, tagnode);
  end;
  tnode := node.NodeNew('OutputTags');
  for i := 0 to m_outTags.Count - 1 do
  begin
    t := OutputTag[i];
    tagnode := tnode.NodeNew('Tag_' + inttostr(i));
    saveTag(t, tagnode);
  end;
end;

procedure cBaseAlg.LoadTags(node: txmlNode);
var
  tnode, tagnode: txmlNode;
  i: integer;
  t: cTag;
begin
  tnode := node.FindNode('InputTags');
  if tnode <> nil then
  begin
    for i := 0 to tnode.NodeCount - 1 do
    begin
      tagnode := tnode.FindNode('Tag_' + inttostr(i));
      t := loadTag(tagnode);
      if t <> nil then
        addInputTag(t);
    end;
  end;
  tnode := node.NodeNew('OutputTags');
  if tnode <> nil then
  begin
    for i := 0 to tnode.NodeCount - 1 do
    begin
      tagnode := tnode.FindNode('Tag_' + inttostr(i));
      t := loadTag(tagnode);
      if t <> nil then
        addOutTag(t);
    end;
  end;
end;

{ cAlgMng }
procedure cAlgMng.AddAHName(tagname: string; AHGrad: cAHgrad);
begin
  m_AHNames.AddObject(tagname, AHGrad);
end;

procedure cAlgMng.AddBaseObjInstance(obj: cBaseObj);
begin
  inherited;
  if obj is cSrcAlg then
  begin
    obj.parent := m_srcList;
  end;
end;

procedure cAlgMng.clearbands;
var
  i: integer;
  b: tBand;
begin
  while m_bands.Count>0 do
  begin
    b := tBand(m_bands.Objects[0]);
    b.destroy;
  end;
  Clear;
end;

constructor cAlgMng.create;
begin
  inherited;
  createEvents;
  m_AHNames := tstringlist.create;
  m_AHNames.Sorted := true;
  m_AHNames.Duplicates := dupIgnore;
  m_AHList := tlist.create;

  m_srcList := cSrcList.create;
  m_srcList.autocreate := true;
  add(m_srcList);

  m_bands := tstringlist.create;
  m_places := TPlaces.create;
  m_TagBandPairList := TTagBandPairList.create;
end;

destructor cAlgMng.destroy;
var
  I: Integer;
begin
  DestroyEvents;

  clearahlist;
  m_AHList.destroy;
  m_AHNames.destroy;

  clearbands;
  m_bands.destroy;

  m_places.destroy;
  m_TagBandPairList.destroy;

  for I := 0 to length(m_FFTPlanList) - 1 do
  begin
    if m_FFTPlanList[i].PCount<>0 then
    begin
      FreeMemAligned(m_FFTPlanList[i].TableExp);
    end;
  end;
  inherited;
end;

procedure cAlgMng.createEvents;
begin
  AddPlgEvent('cAlgMng_doUpdateTags', c_RUpdateData, doUpdateTags);
  AddPlgEvent('cAlgMng_doChangeRState', c_RC_DoChangeRCState, doChangeRState);
end;

procedure cAlgMng.DelAHNames(AHGrad: cAHgrad);
var
  i: integer;
begin
  i := 0;
  while i < m_AHNames.Count do
  begin
    if m_AHNames.Objects[i] = AHGrad then
    begin
      m_AHNames.Delete(i);
      continue;
    end
    else
    begin
      inc(i);
    end;
  end;
end;

procedure cAlgMng.DestroyEvents;
begin
  RemovePlgEvent(doUpdateTags, c_RUpdateData);
  RemovePlgEvent(doChangeRState, c_RC_DoChangeRCState);
end;

procedure cAlgMng.doAfterLoadXML;
var
  i: integer;
  a: tobject;
begin
  inherited;
  for i := 0 to Count - 1 do
  begin
    a := getAlg(i);
    if a is cBaseAlgContainer then
      cBaseAlgContainer(a).doAfterload;
  end;
end;

procedure cAlgMng.doChangeRState(sender: tobject);
begin
  case GetRCStateChange of
    RSt_Init:
      begin

      end;
    RSt_StopToView:
      begin
        doStart;
      end;
    RSt_StopToRec:
      begin
        doStart;
      end;
    RSt_ViewToStop:
      begin

      end;
    RSt_ViewToRec:
      begin

      end;
    RSt_initToRec:
      begin
        doStart;
      end;
    RSt_initToView:
      begin
        doStart;
      end;
    RSt_RecToStop:
      begin
        doStopRecord;
      end;
    RSt_RecToView:
      begin
        doStopRecord;
        doStart;
      end;
  end;
end;

procedure cAlgMng.doGetData;
begin

end;

procedure cAlgMng.doRenameObj(sender: tobject);
begin
  inherited;
end;

procedure cAlgMng.doStart;
var
  i: integer;
  a: cBaseObj;
begin
  for i := 0 to Count - 1 do
  begin
    a := getobj(i);
    if a is cBaseAlgContainer then
    begin
      if cBaseAlgContainer(a).ready then
        cBaseAlgContainer(a).doOnStart;
    end;
  end;
end;

procedure cAlgMng.doStopRecord;
var
  a: cBaseAlgContainer;
  i: integer;
begin
  // предрасчет
  for i := 0 to Count - 1 do
  begin
    a := getAlg(i);
    if a is cSrcAlg then
    begin
      if not a.ready then
        continue;
      if a is cSpm then
        cSpm(a).doStopRecord;
    end;
  end;
end;

procedure cAlgMng.UpdateBands;
var
  i: integer;
  b: tBand;
begin
  for i := 0 to m_bands.Count - 1 do
  begin
    b := getBand(i);
    b.eval;
  end;
end;

procedure cAlgMng.doUpdateTags(sender: tobject);
var
  a: cbaseobj;
  i: integer;
begin
  // предрасчет
  for i := 0 to Count - 1 do
  begin
    a := getobj(i);
    if a is cSrcAlg then
    begin
      if not cSrcAlg(a).ready then
      begin
        continue;
      end;
      cSrcAlg(a).doGetData;
    end;
  end;
  for i := 0 to Count - 1 do
  begin
    a := getAlg(i);
    if a is cBaseAlg then
    begin
      if not cBaseAlg(a).ready then
        continue;
      if (a is cBaseAlg) then
      begin
        cBaseAlg(a).doGetData;
      end;
    end;
  end;
  UpdateBands;
end;

function cAlgMng.getAlg(i: integer): cBaseAlg;
var
  o:cbaseobj;
begin
  o:=getobj(i);
  if o is cbasealg then
    result := cBaseAlg(getobj(i))
  else
    result:=nil;
end;

function cAlgMng.getAH(i: integer): cAHgrad;
begin
  result := cAHgrad(m_AHList.items[i]);
end;

function cAlgMng.getAH(p_name: string): cAHgrad;
var
  i: integer;
  a: cAHgrad;
begin
  result := nil;
  for i := 0 to m_AHList.Count - 1 do
  begin
    a := getAH(i);
    if a.m_name = p_name then
    begin
      result := a;
      break;
    end;
  end;
end;

function cAlgMng.GetAHGradByTagName(tagname: string): cAHgrad;
var
  i: integer;
begin
  if m_AHNames.Find(tagname, i) then
  begin
    result := getAH(i);
  end
  else
    result := nil;
end;

function cAlgMng.newAH(name: string): cAHgrad;
begin
  result := cAHgrad.create(name);
  m_AHList.add(result);
end;

procedure cAlgMng.clearahlist;
var
  i: integer;
  a: cAHgrad;
begin
  for i := 0 to m_AHList.Count - 1 do
  begin
    a := getAH(i);
    a.destroy;
  end;
  m_AHNames.Clear;
  m_AHList.Clear;
end;

function cAlgMng.getAlg(s: string): cBaseAlg;
var
  obj: cBaseObj;
  i: integer;
begin
  result := nil;
  for i := 0 to Count - 1 do
  begin
    obj := getobj(i);
    if obj is cBaseAlgContainer then
    begin
      if s = cBaseAlgContainer(obj).resname then
      begin
        result := cBaseAlg(obj);
        exit;
      end;
    end;
  end;
end;

function cAlgMng.getBand(i: integer): tBand;
begin
  result := tBand(m_bands.Objects[i]);
end;

function cAlgMng.getBand(str: string): tBand;
var
  i: integer;
begin
  result := nil;
  for i := 0 to m_bands.Count - 1 do
  begin
    if str = m_bands.Strings[i] then
    begin
      result := getBand(i);
      exit;
    end;
  end;
end;

function cAlgMng.GetFFTPlan(fftCount:integer): TFFTProp;
var
  I, j, l: Integer;
  r:TFFTProp;
begin
  j:=-1;
  r.PCount:=0;
  for I := 0 to length(m_FFTPlanList) - 1 do
  begin
    r:=m_FFTPlanList[i];
    if r.PCount=fftCount then
    begin
      result:=m_FFTPlanList[i];
      exit;
    end
    else
    begin
      if j=-1 then
      begin
        if r.PCount=0 then
        begin
          j:=i;
        end;
      end;
    end;
  end;
  if (j=-1) then
  begin
    // длина массива
    j:=Length(m_FFTPlanList);
    setlength(m_FFTPlanList, j+c_fftPlan_blockLength);
  end;
  r:=m_FFTPlanList[j];
  r.StartInd:=0;
  r.PCount:=fftCount;
  GetMemAlignedArray_cmpx_d(fftCount, r.TableExp);
  r.TableInd := GetArrayIndex(fftCount, 2);
  GetFFTExpTable(fftCount, false, tcmxArray_d(r.TableExp.p));
  m_FFTPlanList[j]:=r;
  result:=m_FFTPlanList[j];
end;

function cAlgMng.getplace(str: string): TPlace;
begin
  result := m_places.getplace(str);
end;

function cAlgMng.getSpm(str: string): cBaseAlgContainer;
var
  i: integer;
  a: cBaseAlgContainer;
begin
  result := nil;
  for i := 0 to Count - 1 do
  begin
    a := getAlg(i);
    if a is cSpm then
    begin
      if cSpm(a).resname = str then
      begin
        result := a;
        exit;
      end;
    end;
  end;
end;

function cAlgMng.getSpmByTagName(str: string): cBaseAlgContainer;
var
  i: integer;
  a: cbaseobj;
begin
  result := nil;
  for i := 0 to Count - 1 do
  begin
    a := getobj(i);
    if a is cSpm then
    begin
      if cSpm(a).m_tag.tagname = str then
      begin
        result := cBaseAlgContainer(a);
        exit;
      end;
    end;
  end;
end;

procedure cAlgMng.regObjClasses;
begin
  regclass(cCounterAlg);
  regclass(cTahoAlg);
  // regclass(cGrmsAlg);
  regclass(cSyncPhaseAlg);
  regclass(cGrmsSrcAlg);
  regclass(cSrcList);
  regclass(cSpm);
  regclass(cPhaseAlg);
  regclass(cFillingFactorAlg);
  regclass(cExcessAlg);
end;

procedure cAlgMng.removeObj(obj: cBaseObj);
begin
  inherited;
end;

function cAlgMng.SpmCount: integer;
var
  i: integer;
  a: cBaseAlgContainer;
begin
  result := 0;
  for i := 0 to Count - 1 do
  begin
    a := getAlg(i);
    if a is cSpm then
    begin
      inc(result);
    end;
  end;
end;

procedure cAlgMng.XMLlOADMngAttributes(node: txmlNode);
var
  child, bnode, pnode, tnode, n: txmlNode;
  i, j, k, tcount: integer;
  id: TAGID;
  b: tBand;
  p: TPlace;
  pair: TTagBandPair;
  t: BandTag;
  nodetype, str, substr: string;
  a:cahgrad;
begin
  inherited;
  child := node.FindNode('BandsNode');
  if child <> nil then
  begin
    for i := 0 to child.NodeCount - 1 do
    begin
      bnode := child.Nodes[i];
      nodetype := bnode.ReadAttributeString('NodeType', '');
      if nodetype = 'BNode' then
      begin
        b := tBand.create(m_bands);
        b.name := bnode.ReadAttributeString('NodeName', '');
        b.m_f1f2.x := bnode.ReadAttributeFloat('F1', 0);
        b.m_f1f2.y := bnode.ReadAttributeFloat('F2', 0);
        b.valtype := bnode.ReadAttributeInteger('BType', 0);
        tcount := bnode.ReadAttributeInteger('TagCount', 0);
        for j := 0 to bnode.NodeCount - 1 do
        begin
          tnode := bnode.Nodes[j];
          nodetype := tnode.ReadAttributeString('NodeType', '');
          if nodetype = 'TNode' then
          begin
            t := BandTag.create;
            t.tagname := tnode.ReadAttributeString('TagName', '');
            t.k := tnode.ReadAttributeFloat('Kmult', 0);
            //b.m_TagsList.AddObject(t.m_t, t);
            b.addBandTag(t);
          end;
        end;
        m_bands.AddObject(b.name, b);
      end;
    end;
  end;
  child := node.FindNode('PlacesNode');
  if child <> nil then
  begin
    for i := 0 to child.NodeCount - 1 do
    begin
      pnode := child.Nodes[i];
      nodetype := pnode.ReadAttributeString('NodeType', '');
      if nodetype = 'PlaceNode' then
      begin
        p := TPlace.create(m_places);
        m_places.addplace(p);
        p.name := pnode.ReadAttributeString('NodeName', ''); ;
        for j := 0 to pnode.NodeCount - 1 do
        begin
          bnode := pnode.Nodes[j];
          nodetype := bnode.ReadAttributeString('NodeType', '');
          if nodetype = 'BNode' then
          begin
            b := getBand(bnode.ReadAttributeString('NodeName', ''));
            if b <> nil then
            begin
              p.addband(b);
            end;
          end;
        end;
      end;
    end;
  end;
  child := node.FindNode('TagsBandPairNode');
  if child <> nil then
  begin
    for i := 0 to child.NodeCount - 1 do
    begin
      pnode := child.Nodes[i];
      nodetype := pnode.ReadAttributeString('NodeType', '');
      if nodetype = 'TagBandNode' then
      begin
        pair := m_TagBandPairList.newPair;
        pair.name := pnode.ReadAttributeString('NodeName', '');
        if pair.m_it = nil then
        begin
          id := pnode.ReadAttributeInt64('TagID', -1);
          pair.setId(id);
        end;
        for j := 0 to pnode.NodeCount - 1 do
        begin
          bnode := pnode.Nodes[j];
          nodetype := bnode.ReadAttributeString('NodeType', '');
          if nodetype = 'TagPlace' then
          begin
            p := getplace(bnode.ReadAttributeString('NodeName', ''));
            if p <> nil then
            begin
              pair.addplace(p);
            end;
          end;
        end;
      end;
    end;
  end;
  // загрузка корректировки ачх
  child := node.FindNode('AHGradList');
  if child <> nil then
  begin
    for i := 0 to child.NodeCount - 1 do
    begin
      n := child.Nodes[i];
      nodetype := pnode.ReadAttributeString('NodeType', '');
      if nodetype = 'AHNode' then
      begin
        str:=n.ReadAttributeString('NodeName', '');
        a:=newAH(str);
        a.m_units:=IntToAHUn(n.readAttributeInteger('AHUnits',0));
        a.size:=n.readAttributeInteger('AHCount', 0);
        str :=n.ReadAttributeString('AHpoints', '');
        substr:=GetSubString(str, ';', 0, j);
        k:=0;
        while substr<>'' do
        begin
          a.m_points[k].x:=strtofloatext(substr);
          substr:=GetSubString(str, ';', j, j);
          a.m_points[k].y:=strtofloatext(substr);
          substr:=GetSubString(str, ';', j, j);
          inc(k);
        end;
      end;
    end;
  end;
  // загрузка списка корректируемых тегов
  child := node.FindNode('AHNameList');
  if child <> nil then
  begin
    for i := 0 to child.NodeCount - 1 do
    begin
      n := child.Nodes[i];
      nodetype := pnode.ReadAttributeString('NodeType', '');
      if nodetype = 'AHNameNode' then
      begin
        str:=n.ReadAttributeString('NodeName', '');
        substr:=n.ReadAttributeString('AHgrad', '');
        a:=getAH(substr);
        if a<>nil then
        begin
          m_AHNames.AddObject(str,a);
        end;
      end;
    end;
  end;
end;

procedure cAlgMng.XMLSaveMngAttributes(node: txmlNode);
var
  child, n, bnode, pnode, tnode: txmlNode;
  i: integer;
  b: tBand;
  p: TPlace;
  pair: TTagBandPair;
  t: BandTag;
  j: integer;
  a: cAHgrad;
  str:string;
begin
  inherited;
  child := node.NodeNew('BandsNode');
  for i := 0 to m_bands.Count - 1 do
  begin
    b := tBand(m_bands.Objects[i]);
    bnode := child.NodeNew('Band_' + inttostr(i));
    bnode.WriteAttributeString('NodeName', b.name, '');
    bnode.WriteAttributeString('NodeType', 'BNode', '');
    bnode.WriteAttributeFloat('F1', b.m_f1f2.x, 0);
    bnode.WriteAttributeFloat('F2', b.m_f1f2.y, 0);
    bnode.WriteAttributeInteger('BType', b.valtype, 0);
    bnode.WriteAttributeInteger('TagCount', b.m_TagsList.Count, 0);
    for j := 0 to b.m_TagsList.Count - 1 do
    begin
      tnode := bnode.NodeNew(b.name);
      tnode.WriteAttributeString('NodeType', 'TNode', '');
      t := b.getbandtag(j);
      tnode.WriteAttributeString('TagName', t.m_t, '');
      tnode.WriteAttributeFloat('Kmult', t.k, 0);
    end;
  end;

  child := node.NodeNew('PlacesNode');
  for i := 0 to m_places.Count - 1 do
  begin
    p := m_places.getplace(i);
    pnode := child.NodeNew('Place_' + inttostr(i));
    pnode.WriteAttributeString('NodeName', p.name, '');
    pnode.WriteAttributeString('NodeType', 'PlaceNode', '');
    for j := 0 to p.Bandcount - 1 do
    begin
      b := p.getBand(j);
      bnode := pnode.NodeNew('Band_' + inttostr(j));
      bnode.WriteAttributeString('NodeType', 'BNode', '');
      bnode.WriteAttributeString('NodeName', b.name, '');
    end;
  end;

  child := node.NodeNew('TagsBandPairNode');
  for i := 0 to m_TagBandPairList.Count - 1 do
  begin
    pair := m_TagBandPairList.getPair(i);
    pnode := child.NodeNew('BandPair_' + inttostr(i));
    pnode.WriteAttributeString('NodeType', 'TagBandNode', '');
    pnode.WriteAttributeString('NodeName', pair.name, '');
    pnode.WriteAttributeInt64('TagID', pair.m_id, -1);
    for j := 0 to pair.m_places.Count - 1 do
    begin
      p := pair.getplace(j);
      bnode := pnode.NodeNew('TagPlace_' + inttostr(j));
      bnode.WriteAttributeString('NodeType', 'TagPlace', '');
      bnode.WriteAttributeString('NodeName', p.name, '');
    end;
  end;
  // корректировка АЧХ
  child := node.NodeNew('AHGradList');
  for i := 0 to m_AHList.Count - 1 do
  begin
    a := getAH(i);
    n := child.NodeNew('AHNode_' + inttostr(i));
    n.WriteAttributeString('NodeType', 'AHNode', '');
    n.WriteAttributeString('NodeName', a.m_name, '');
    n.WriteAttributeInteger('AHUnits', TAHUnToInt(a.m_units), 0);
    n.WriteAttributeInteger('AHCount', a.size, 0);
    str := '';
    for j := 0 to a.size - 1 do
    begin
      str := str + floattostr(a.m_points[j].x) + ';' + floattostr(a.m_points[j].y);
      if j <> a.size - 1 then
        str := str + ';';
    end;
    n.WriteAttributeString('AHpoints', str, '');
  end;
  child := node.NodeNew('AHNameList');
  for i := 0 to m_AHNames.Count - 1 do
  begin
    str := m_AHNames.Strings[i];
    n := child.NodeNew('AHNode_' + inttostr(i));
    n.WriteAttributeString('NodeType', 'AHNameNode', '');
    n.WriteAttributeString('NodeName', str, '');
    n.WriteAttributeString('AHgrad', cAHGrad(m_AHNames.Objects[i]).m_name, '');
  end;
end;

{ cSpmList }
constructor cSrcList.create;
begin
  inherited;
  fHelper := true;
  // нельзя ставить True кт.к. будет разрушен и не восстановлен при загрузке
  autocreate := true;
  blocked := true;
end;

destructor cSrcList.destroy;
begin
  inherited;
end;

{ tBand }
procedure tBand.addBandTag(bt: BandTag);
begin
  m_TagsList.AddObject(bt.m_t, bt);
end;

procedure tBand.clearTags;
var
  i: integer;
  bt: BandTag;
begin
  for i := 0 to m_TagsList.Count - 1 do
  begin
    bt := getbandtag(i);
    bt.destroy;
  end;
  m_TagsList.Clear;
end;

constructor tBand.create(owner: tstringlist);
begin
  m_TagsList := tstringlist.create;
  m_owner := owner;
end;

destructor tBand.destroy;
var
  i: integer;
  t: BandTag;
begin
  clearTags;
  for i := 0 to m_owner.Count - 1 do
  begin
    if m_owner.Objects[i] = self then
    begin
      m_owner.Delete(i);
      break;
    end;
  end;
  m_TagsList.destroy;
end;

procedure tBand.eval;
var
  i: integer;
  t: BandTag;
  v: double;
begin
  m_MainFreq := 0;
  for i := 0 to m_TagsList.Count - 1 do
  begin
    t := getbandtag(i);
    if t.m_it <> nil then
    begin
      v := GetScalar(t.m_it);
    end
    else
    begin
      break;
    end;
    if i = 0 then
    begin
      m_MainFreq := t.k * v;
    end
    else
    begin
      m_MainFreq := m_MainFreq + t.k * v;
    end;
  end;
  if valtype = c_rate then
  begin
    m_resultBand.x := m_MainFreq * m_f1f2.x;
    m_resultBand.y := m_MainFreq * m_f1f2.y;
  end
  else
  begin
    m_resultBand.x := m_MainFreq - m_f1f2.x;
    m_resultBand.y := m_MainFreq + m_f1f2.y;
  end;
end;

function tBand.getbandtag(i: integer): BandTag;
begin
  result := BandTag(m_TagsList.Objects[i]);
end;

function tBand.tagCount: integer;
begin
  result:=m_TagsList.Count;
end;

{ TPlace }

procedure TPlace.addband(b: tBand);
var
  i: integer;
begin
  for i := 0 to bands.Count - 1 do
  begin
    if bands.items[i] = b then
    begin
      exit;
    end;
  end;
  bands.add(b);
end;

function TPlace.Bandcount: integer;
begin
  result := bands.Count;
end;

constructor TPlace.create(p_owner: tlist);
begin
  owner := p_owner;
  bands := tlist.create;
end;

procedure TPlace.delband(b: tBand);
var
  i: integer;
begin
  for i := 0 to bands.Count - 1 do
  begin
    if b = bands.items[i] then
    begin
      bands.Delete(i);
      exit;
    end;
  end;
end;

destructor TPlace.destroy;
var
  i: integer;
begin
  for i := 0 to owner.Count - 1 do
  begin
    if owner.items[i] = self then
    begin
      owner.Delete(i);
      break;
    end;
  end;
  bands.destroy;
end;

function TPlace.getBand(i: integer): tBand;
begin
  result := tBand(bands.items[i]);
end;

{ TPlaces }
procedure TPlaces.addplace(p: TPlace);
begin
  add(p);
end;

destructor TPlaces.destroy;
var
  i: integer;
  p: TPlace;
begin
  while Count > 0 do
  begin
    p := getplace(0);
    p.destroy;
  end;
  inherited;
end;

function TPlaces.getplace(str: string): TPlace;
var
  i: integer;
begin
  result := nil;
  for i := 0 to Count - 1 do
  begin
    if getplace(i).name = str then
    begin
      result := getplace(i);
      exit;
    end;
  end;
end;

function TPlaces.getplace(i: integer): TPlace;
begin
  result := TPlace(items[i]);
end;

{ TTagBandPair }
procedure TTagBandPair.addplace(p: TPlace);
begin
  m_places.add(p);
end;

constructor TTagBandPair.create;
begin
  m_places := tlist.create;
end;

destructor TTagBandPair.destroy;
var
  i: integer;
begin
  for i := 0 to m_owner.Count - 1 do
  begin
    if m_owner.items[i] = self then
    begin
      m_owner.Delete(i);
      break;
    end;
  end;
  m_places.destroy;
  inherited;
end;

function TTagBandPair.getname: string;
begin
  if m_it <> nil then
    result := m_it.getname
  else
    result := m_t;
end;

function TTagBandPair.getplace(i: integer): TPlace;
begin
  result := TPlace(m_places.items[i]);
end;

function TTagBandPair.placeCount: integer;
begin
  result := m_places.Count;
end;

function TTagBandPair.removeplace(p: TPlace): boolean;
var
  i: integer;
begin
  result := false;
  for i := 0 to m_places.Count - 1 do
  begin
    if m_places.items[i] = p then
    begin
      m_places.Delete(i);
      result := true;
      exit;
    end;
  end;
end;

procedure TTagBandPair.setId(id: TAGID);
begin
  if m_id <> id then
  begin
    m_it := getTagById(id);
    m_id := id;
  end;
end;

procedure TTagBandPair.setname(s: string);
var
  b: boolean;
  astr: ansistring;
begin
  b := false;
  m_it := getTagByName(s);
  m_t := s;
  if m_it <> nil then
  begin
    m_it.GetTagId(m_id);
  end;
end;

procedure TTagBandPair.settag(t: itag);
begin
  m_it := t;
  m_t := t.getname;
  if t <> nil then
  begin
    m_it.GetTagId(m_id);
  end;
end;

{ TTagBandPairList }
destructor TTagBandPairList.destroy;
var
  i: integer;
  p: TTagBandPair;
begin
  while Count > 0 do
  begin
    p := getPair(0);
    p.destroy;
  end;
  inherited;
end;

function TTagBandPairList.getPair(i: integer): TTagBandPair;
begin
  result := TTagBandPair(items[i]);
end;

function TTagBandPairList.getPair(tagname: string): TTagBandPair;
var
  i: integer;
  t: TTagBandPair;
begin
  result := nil;
  for i := 0 to Count - 1 do
  begin
    t := getPair(i);
    if t.m_t = tagname then
    begin
      result := t;
      exit;
    end;
  end;
end;

function TTagBandPairList.newPair: TTagBandPair;
begin
  result := TTagBandPair.create;
  result.m_owner := self;
  add(result);
end;

{ BandTag }
constructor BandTag.create;
begin
  m_t:='';
  m_id:=0;
end;

destructor BandTag.destroy;
begin
  m_t:='';
end;

procedure BandTag.settagname(s: string);
begin
  m_t := s;
  m_it := getTagByName(s);
  if m_it <> nil then
  begin
    m_it.GetTagId(m_id);
  end;
end;

{ cAHgrad }
function cAHgrad.CorrectValue(v, freq: double): double;
var
  point: double;
  i: integer;
begin
  for i := 1 to size - 1 do
  begin
    if i < size - 1 then
    begin
      if (m_points[i - 1].x < freq) and (m_points[i].x > freq) then
      begin
        point := EvalLineYd(freq, m_points[i - 1], m_points[i]);
        break;
      end;
    end
    else
    begin
      point := EvalLineYd(freq, m_points[i - 1], m_points[i]);
      break;
    end;
  end;
  case m_units of
    AHmult:
      result := point * v;
    AH10db:
      result := v * (Power(10, point / 10));
    AH20db:
      result := v * (Power(10, point / 20));
    AHpercent:
      result := v * (1 + point / 100);
  end;
end;

function cAHgrad.GetMultDsc(i: integer): string;
var
  point: double;
begin
  point := m_points[i].y;
  case m_units of
    AHmult:
      result := formatstrNoE(point, 3);
    AH10db:
      result := 'Значение*10^(' + formatstrNoE(point / 10, 3) + ')';
    // point*(Power(10,percent/20));
    AH20db:
      result := 'Значение*10^(' + formatstrNoE(point / 20, 3) + ')';
    // point*(Power(10,percent/20));
    AHpercent:
      result := formatstrNoE(1 + point / 100, 3);
  end;
end;

constructor cAHgrad.create(name: string);
begin
  m_name := name;
end;

destructor cAHgrad.destroy;
var
  i: integer;
begin
  for i := 0 to g_algMng.m_AHList.Count - 1 do
  begin
    if g_algMng.m_AHList.items[i] = self then
    begin
      g_algMng.m_AHList.Delete(i);
      break;
    end;
  end;
  g_algMng.DelAHNames(self);
end;

function cAHgrad.GetMultDsc(freq: double): string;
var
  point, k: double;
  i: integer;
begin
  for i := 1 to size - 1 do
  begin
    if i < size - 1 then
    begin
      if (m_points[i - 1].x < freq) and (m_points[i].x > freq) then
      begin
        point := EvalLineYd(freq, m_points[i - 1], m_points[i]);
        break;
      end;
    end
    else
    begin
      point := EvalLineYd(freq, m_points[i - 1], m_points[i]);
      break;
    end;
  end;
  case m_units of
    AHmult:
      result := formatstrNoE(point, 3);
    AH10db:
      result := 'Значение*10^(' + formatstrNoE(point / 10, 3) + ')';
    // point*(Power(10,percent/20));
    AH20db:
      result := 'Значение*10^(' + formatstrNoE(point / 20, 3) + ')';
    // point*(Power(10,percent/20));
    AHpercent:
      result := formatstrNoE(1 + point / 100, 3);
  end;
end;

function cAHgrad.getsize: integer;
begin
  result := length(m_points);
end;

function cAHgrad.getUnitString: string;
begin
  case m_units of
    AHmult:
      result := 'Множитель';
    AH10db:
      result := '10Lg(Aизм./Ареалн.)';
    AH20db:
      result := '20Lg(Aизм./Ареалн.)';
    AHpercent:
      result := '%';
  end;
end;

procedure cAHgrad.setsize(s: integer);
begin
  setlength(m_points, s);
end;

end.
