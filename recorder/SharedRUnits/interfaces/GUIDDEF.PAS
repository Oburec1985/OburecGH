unit GUIDDEF;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 07.07.2016                                            }
{    Generated Time: 17:54:05                                              }
{                                                                          }
{**************************************************************************}

interface
uses
{$IFDEF WIN32}
  Windows;
{$ELSE}
  Wintypes, WinProcs;
{$ENDIF}


{=> e:\oburec\delphi\headerconverter\headconv\GUIDDEF.H <=}

{///+--------------------------------------------------------------------------- }
{/// }
{/// Microsoft Windows }
{/// Copyright (c) Microsoft Corporation. All rights reserved. }
{/// }
{/// File: guiddef.h }
{/// }
{/// Contents: GUID definition }
{/// }
{///---------------------------------------------------------------------------- }

{$IFNDEF GUID_DEFINED}
{$DEFINE GUID_DEFINED}
{$IFDEF __midl}
type
  GUID = record
    Data1: LongInt;
    Data2: Word;
    Data3: Word;
    Data4: Array[0..8-1] of BYTE;
  end {GUID};
{$ELSE}
type
  _GUID = record
    Data1: LongInt;
    Data2: Word;
    Data3: Word;
    Data4: Array[0..8-1] of Byte;
  end {_GUID};
  GUID = _GUID;
{$ENDIF}
{$ENDIF}

{$IFNDEF FAR}
{$IFDEF _WIN32}
{$DEFINE FAR}
{$ELSE}
const
  FAR = _far;
{$ENDIF}
{$ENDIF}

{$IFNDEF DECLSPEC_SELECTANY}
{$IFDEF (_MSC_VER >= 1100) || (__BORLANDC__ >= 0x0550)}
const
  DECLSPEC_SELECTANY = __declspec(selectany);
{$ELSE}
{$DEFINE DECLSPEC_SELECTANY}
{$ENDIF}
{$ENDIF}

{$IFNDEF EXTERN_C}
{$IFDEF __cplusplus}
const
  EXTERN_C = extern 'C';
{$ELSE}
const
  EXTERN_C = extern;
{$ENDIF}
{$ENDIF}

{$IFDEF DEFINE_GUID}
{ #undef DEFINE_GUID }
{$ENDIF}

{$IFDEF INITGUID}
const
  DEFINE_GUID(name, = l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \;
{$ELSE}
const
  DEFINE_GUID(name, = l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \;

const
  DEFINE_OLEGUID(name, = l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46);

{$IFNDEF _GUIDDEF_H_}
{$DEFINE _GUIDDEF_H_}

{$IFNDEF __LPGUID_DEFINED__}
{$DEFINE __LPGUID_DEFINED__}
type
  LPGUID = PGUID;
{$ENDIF}

{$IFNDEF __LPCGUID_DEFINED__}
{$DEFINE __LPCGUID_DEFINED__}
type
  LPCGUID = PCONST GUID;
{$ENDIF}

{$IFNDEF __IID_DEFINED__}
{$DEFINE __IID_DEFINED__}

type
  IID = GUID;
type
  LPIID = PIID;
const
  IID_NULL = GUID_NULL;
const
  IsEqualIID(riid1, = riid2) IsEqualGUID(riid1, riid2);
type
  CLSID = GUID;
type
  LPCLSID = PCLSID;
const
  CLSID_NULL = GUID_NULL;
const
  IsEqualCLSID(rclsid1, = rclsid2) IsEqualGUID(rclsid1, rclsid2);
type
  FMTID = GUID;
type
  LPFMTID = PFMTID;
const
  FMTID_NULL = GUID_NULL;
const
  IsEqualFMTID(rfmtid1, = rfmtid2) IsEqualGUID(rfmtid1, rfmtid2);

{$IFDEF __midl_proxy}
{$DEFINE __MIDL_CONST}
{$ELSE}
const
  __MIDL_CONST = const;
{$ENDIF}

{$IFNDEF _REFGUID_DEFINED}
{$DEFINE _REFGUID_DEFINED}
{$IFDEF __cplusplus}
const
  REFGUID = const GUID &;
{$ELSE}
const
  REFGUID = const GUID* __MIDL_CONST;
{$ENDIF}
{$ENDIF}

{$IFNDEF _REFIID_DEFINED}
{$DEFINE _REFIID_DEFINED}
{$IFDEF __cplusplus}
const
  REFIID = const IID &;
{$ELSE}
const
  REFIID = const IID* __MIDL_CONST;
{$ENDIF}
{$ENDIF}

{$IFNDEF _REFCLSID_DEFINED}
{$DEFINE _REFCLSID_DEFINED}
{$IFDEF __cplusplus}
const
  REFCLSID = const IID &;
{$ELSE}
const
  REFCLSID = const IID* __MIDL_CONST;
{$ENDIF}
{$ENDIF}

{$IFNDEF _REFFMTID_DEFINED}
{$DEFINE _REFFMTID_DEFINED}
{$IFDEF __cplusplus}
const
  REFFMTID = const IID &;
{$ELSE}
const
  REFFMTID = const IID* __MIDL_CONST;
{$ENDIF}
{$ENDIF}

{$ENDIF // !__IID_DEFINED__}

{$IFNDEF __midl}
{$IFNDEF _SYS_GUID_OPERATORS_}
{$DEFINE _SYS_GUID_OPERATORS_}
{$INCLUDE <string.h>}

{/// Faster (but makes code fatter) inline version...use sparingly }
{$IFDEF __cplusplus}
var
  InlineIsEqualGUID: function(rguid1: REFGUID; 
                              rguid2: REFGUID): __INLINE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  return: function(var long*: ((UNSIGNED LONG): Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  IsEqualGUID: function(rguid1: REFGUID; 
                        rguid2: REFGUID): __INLINE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  !memcmp: function(var _1: RGUID1; 
                    var _2: RGUID2; 
                    _3: SIZEOF(GUID)): RETURN cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

{$ELSE // ! __cplusplus}

const
  InlineIsEqualGUID(rguid1, = rguid2) \;
var
  @: function(long*: P((UNSIGNED LONG): Integer cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
const
  IsEqualGUID(rguid1, = rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)));

{$ENDIF // __cplusplus}

{$IFDEF __INLINE_ISEQUAL_GUID}
{ #undef IsEqualGUID }
const
  IsEqualGUID(rguid1, = rguid2) InlineIsEqualGUID(rguid1, rguid2);
{$ENDIF}

{/// Same type, different name }

const
  IsEqualIID(riid1, = riid2) IsEqualGUID(riid1, riid2);
const
  IsEqualCLSID(rclsid1, = rclsid2) IsEqualGUID(rclsid1, rclsid2);


{$IFNDEF _SYS_GUID_OPERATOR_EQ_ && !defined _NO_SYS_GUID_OPERATOR_EQ_}
{$DEFINE _SYS_GUID_OPERATOR_EQ_}
{/// A couple of C++ helpers }

{$IFDEF __cplusplus}
var
  operator==: function(guidOne: REFGUID; 
                       guidOther: REFGUID): __INLINE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  IsEqualGUID: function(_1: GUIDONE; 
                        _2: GUIDOTHER): RETURN cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 

var
  operator!=: function(guidOne: REFGUID; 
                       guidOther: REFGUID): __INLINE cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
var
  !: function(guidOther: GUIDONE ==): RETURN cdecl  {$IFDEF WIN32} stdcall {$ENDIF}; 
{$ENDIF}
{$ENDIF // _SYS_GUID_OPERATOR_EQ_}
{$ENDIF // _SYS_GUID_OPERATORS_}
{$ENDIF // __midl}
{$ENDIF // _GUIDDEF_H_}

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    {$IFDEF WIN32} = False; {$ENDIF}

implementation

var
  SaveExit: pointer;
  DLLHandle: THandle;
{$IFNDEF MSDOS}
  ErrorMode: Integer;
{$ENDIF}

  procedure NewExit; far;
  begin
    ExitProc := SaveExit;
    FreeLibrary(DLLHandle)
  end {NewExit};

procedure LoadDLL;
begin
  if DLLLoaded then Exit;
{$IFNDEF MSDOS}
  ErrorMode := SetErrorMode($8000{SEM_NoOpenFileErrorBox});
{$ENDIF}
  DLLHandle := LoadLibrary('GUIDDEF.DLL');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @InlineIsEqualGUID := GetProcAddress(DLLHandle,'InlineIsEqualGUID');
  {$IFDEF WIN32}
    Assert(@InlineIsEqualGUID <> nil);
  {$ENDIF}
    @return := GetProcAddress(DLLHandle,'return');
  {$IFDEF WIN32}
    Assert(@return <> nil);
  {$ENDIF}
    @IsEqualGUID := GetProcAddress(DLLHandle,'IsEqualGUID');
  {$IFDEF WIN32}
    Assert(@IsEqualGUID <> nil);
  {$ENDIF}
    @!memcmp := GetProcAddress(DLLHandle,'!memcmp');
  {$IFDEF WIN32}
    Assert(@!memcmp <> nil);
  {$ENDIF}
    @@ := GetProcAddress(DLLHandle,'@');
  {$IFDEF WIN32}
    Assert(@@ <> nil);
  {$ENDIF}
    @operator== := GetProcAddress(DLLHandle,'operator==');
  {$IFDEF WIN32}
    Assert(@operator== <> nil);
  {$ENDIF}
    @IsEqualGUID := GetProcAddress(DLLHandle,'IsEqualGUID');
  {$IFDEF WIN32}
    Assert(@IsEqualGUID <> nil);
  {$ENDIF}
    @operator!= := GetProcAddress(DLLHandle,'operator!=');
  {$IFDEF WIN32}
    Assert(@operator!= <> nil);
  {$ENDIF}
    @! := GetProcAddress(DLLHandle,'!');
  {$IFDEF WIN32}
    Assert(@! <> nil);
  {$ENDIF}
  end
  else
  begin
    DLLLoaded := False;
    { Error: GUIDDEF.DLL could not be loaded !! }
  end;
{$IFNDEF MSDOS}
  SetErrorMode(ErrorMode)
{$ENDIF}
end {LoadDLL};

begin
  LoadDLL;
end.
