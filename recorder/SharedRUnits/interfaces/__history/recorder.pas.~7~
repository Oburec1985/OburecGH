{---------------------------------------------------------------------}
{ Проект (Модуль) реслизации plug-in`а для измерительного ПО Recorder }
{ Модуль описания интерфейса для управления Recorder`ом и реализации  }
{ специализированных классов (форм) отображения измеренной информации }
{ Компилятор: Borland Delphi 6.0                                      }
{ НПП "ООО Мера" 2004г.                                               }
{---------------------------------------------------------------------}
unit recorder;
interface
uses Windows, tags, modules, device, ActiveX;
{$ALIGN 8}

const

  MAX_PATH=260;
  // Коды ошибок рекордера
  RCERROR_NOERROR =              0;
  RCERROR_UNKNOWNERROR =         1;
  RCERROR_NOTIMPLEMENT =         2;
  RCERROR_PLUGINNOTCREATED =     3;
  RCERROR_OUTOFRANGE =           4;
  RCERROR_NOTFOUND =             5;
  RCERROR_DLLNOTFOUND =          6;
  RCERROR_FUNCTIONNOTFOUND =     7;
  RCERROR_CANTOPEN =             8;
  RCERROR_CANTCREATE =           9;
  RCERROR_SYSTEMBUSY =          10;
  RCERROR_FILENOTFOUND =        11;
  RCERROR_INVALIDARGUMENT =     12;
  RCERROR_INVALIDTYPECAST =     13;
  RCERROR_ALREADYEXIST =        14;
  RCERROR_ABNORMALTERMINATION = 15;
  RCERROR_NOTSUPPORTED =        16;
  RCERROR_ACCESSVIOLATION =     17;
  RCERROR_USERABORT =           18;
  RCERROR_ACCESSDENIED =        19;
  LAST_ERROR_INDEX     = RCERROR_ACCESSDENIED;
  //Константы состояний Recorder`а enum RECORDER_STATE
  RS_STOP              = $0001;     //Измерение остановлено
  RS_VIEW              = $0002;     //Измерение и просмотр
  RS_REC               = $0004;     //Измерение и сохранение в файлы
  RS_PLAYING           = $0008;     //Проигрывание из файлов
  RS_BASESTATE         = RS_REC + RS_VIEW + RS_STOP + RS_PLAYING;
  RS_HARDWAREFAULT     = $0010;     // Инициализация системы не прошла успешно
  RS_INITFAULT         = $0020;     // Инициализация системы не прошла успешно
  RS_NEEDDEVICERESET   = $0040;     // Требуется Reset драйвера
  RS_NEEDHARDWARERESET = $0040;     // Требуется Reset драйвера
  RS_NEEDSOFTWARERESET = $0080;     // Требуется програмной части драйвера
  RS_NEEDLINKSREFRESH  = $0100;     // Требуется обновление ссылок
  RS_FAULT             = RS_HARDWAREFAULT + RS_INITFAULT;

  RS_PLAYMODE          = $0200;     // Настройка и работа в режиме воспроизведения
  RS_SIGNALLOADED      = $0400;     // Конфигурирование прошло успешно
  RS_CONFIGCHANGED     = $0800;     // Изменена конфигурация, требуется сохранение
  RS_CONFIGMODE        = $1000;     // Режим конфигурирования

  RS_PACKETLOST        = $00010000; // Потери во время приема
  RS_RECEIVEERROR      = $00020000; // Сейчас идут потери
  RS_TERMINATION       = $80000000; // состояние завершения работы
  RS_FULLMASK          = $FFFFFFFF;

   // Уведомления рекордеру
  RCN_RECONFIG =         0; // Переконфигурироваться
  RCN_VIEW =             1; // Старт режима просмотр
  RCN_REC =              2; // Старт записи
  RCN_STOP =             3; // Остановка рекордера
  RCN_SHOW =             4; // Сделать главное окно видимым
  RCN_HIDE =             5; // Скрыть главное окно
  RCN_CLOSE =            6; // Завершить работу рекордера
  RCN_SETCURFORM =       7; // Сменить формуляр
  RCN_ENABLESETUP =      8; // Разрешить / запретить настройки
  RCN_CLOSEPLUGIN =      9; // Завершить работу плагина
  RCN_SETCURTAG =       10; // Установить текущий канал   a_dwParam = номер канала
  RCN_CHANGECURTAG =    11; // Установить текущий канал = старый канал + a_dwParam
  RCN_CHANGETAGRANGE =  12; // Поменять границы отображения для тега use TAGRANGEDATA

  RCN_RESORTTAGS =      13;// Пересортировать теги
  RCN_LAUNCHWINPOS =    14;// Запустить пакет обработки зарегистрированной информации
  RCN_TEST =            15;// Запустить процедуру самотестирования
  RCN_SAVECONFIG =      16;// Сохранить конфигурацию
  RCN_CLOSEALLPLUGINS = 17;// Закрыть все запущенные плагины
  RCN_OPENPLUGIN =      18;// Загрузка и запуск плагина
  RCN_REG_DF_CHANGER=   19;// Зарегистрировать плагин, сменяющий рабочую папку
	RCN_PLAY =            20;// Старт режима воспроизведение
	RCN_ON_PLAY_MODE=     21;   //< Уведомдение о переключении в режим воспроизведения
	RCN_ON_REC_MODE=      22;   //< Уведомдение о переключении в режим записи
	RCN_SUBSCRALARMSEVENT=23;   //< Подписаться на уведомление о срабатывании уставок
	                            //< плагин должен поддерживать IAlarmEventHandler
	RCN_UNSUBSCRALARMSEVENT=24; //< Отпиисаться от уведомления о срабатывании уставок
	RCN_PLAY_SOUND_NOTIFY=  25; //< проиграть звуковое уведомление, данные @ref RCSNDNOTIFY

	RCN_INTERNAL_BASE    =  $8000;    //  0x8000,
	RCN_UPDATEGROUPSLINKS=     26;    //< Сделать апдейт ссылкам на группы dwParam == ByNames:BOOL
	RCN_DRIVERSRESET=          27;    //< Сделать ресет девайсам @ref RCNDRIVERSRESETFLAGS
	RCN_DRIVERSCONFIG=         28;    //< Сделать конфиг девайсам @ref RCNDRIVERSCONFIGFLAGS
	RCN_CHECKTAGSNAMES=        29;    //< Проверить имена тегов на уникальность
	RCN_BROADCAST=             30;    //< Разослать всем уведомление
	RCN_SWITCH_CALIBR_MODE=    31;    //< Переключиться в режим калибровки

	RCN_DEACTIVATE_DEVICES=    32;       //< Отключить прием данных со всех устройств для
	                                  //< нужно для воспроизведения TRUE/FALSE
	RCN_RUN_IN_RC_THREAD=      33;       //< будет вызван нотифай в треде рекордера с параметрами RCTRCOMMAND
	                                  //< если RCTRCOMMAND.pPlgDest==0 то нотификация всем
	RCN_ACTION_POPUP_SETUP=    34;    //< Запросить плагины о желании заблокировать показ окна настройки рекордера
	RCN_ACTION_POPUP_SEL_FRAME=35;    //< Запросить плагины о желании заблокировать показ окна выбора имени замера

	RCN_ACTION_SAVE_CFG=       36;    //< Запросить плагины о желании заблокировать сохранение конфигурации rc
	RCN_ACTION_SAVE_CFG_AS=    37;    //< Запросить плагины о желании заблокировать сохранение конфигурации rc
	RCN_ACTION_LOAD_CFG=       38;    //< Запросить плагины о желании заблокировать загрузу конфигурации rc
	RCN_DRIVER_RESET_EX=       39;    //< Расширенный ресет драйвера, в параметре передается номер устройства
	RCN_DRIVER_CONFIG_EX=      40;    //< Расширенный конфиг драйвера, в параметре передается номер устройства
	RCN_MARK_DEVICE_FOR_RESET= 41;    //< Внутренняя команда, ядра на ресет конкретного устройства по выходу из настройки
	RCN_RESET_CONFIG=          42;    //< Обнулить конфигурацию
	RCN_ACTION_CLOSE_APP=      43;    //< Запросить плагины о желании заблокировать завершение рекордера
	RCN_FORCE_CLOSE=           44;    //< Закрыться и не спрашивать никого и ничего
	RCN_RESET_DFT_INDEX=       45;    //< Немного подстольная штука связанная с шаблонами каталога регистрации данных


   //Широковещательные уведомления
  RCBC_PLUGINSLISTUPDATED = 0;

   //Свойства рекордера
  RCPROP_HOSTDEVICE =           0;  // [in] номер требуемого хоста [out] интерфейс носта
  RCPROP_DATAFOLDER =           1;  // Рабочий каталог [in] [out]
  RCPROP_STARTRECLEVCTRLPROPS = 2;  // Свойства старта записи по уровню RCLEVELCONTROLPROPS [out]
  RCPROP_STARTTIME =            3;  // Время старта просмотра/регистрации VT_FILETIME [out]
  RCPROP_CALIBRDBNAME =         4;  // Имя каталога с тарировочными характеристиками [out] VT_BST
  RCPROP_REFRESHPERIOD =        5;  // период обновления/размер блока данных в секундах   [in][out] VT_R8
  RCPROP_VIEWTIME =             6;  // время отображения/длинна вектора данных в секундах   [in][out] VT_R8
  RCPROP_VERSION =              7;  // версия рекордера                                           [out] VT_I4
  RCPROP_TAGSSORTMODE =         8;  // метод сортировки тегов                                 [in][out] VT_I4
  RCPROP_TIMERTICPERIOD =       9;  // интервал таймера для отображения
  RCPROP_MODIFYFRAMENAME =      10; // автоматически модифицировать имя кадра при записи
  RCPROP_CONVERTTOUSML =        11; // преобразовывать в УСМЛ по остановке записи
  RCPROP_ENABLEDLEVELSTARTREC = 12; // Разрешен старт записи по уровню
  RCPROP_TRIGGERSTART =         13; // Состояние триггерног старта
  RCPROP_ENABLEDAUTOSTOPTIME =  14; // Автоматический останов записи по времени
  RCPROP_AUTOSTOPTIME =         15; // Период для автоматического останова записи по времени
  RCPROP_CONFIGNAME =           16; // Имя файла конфигурации
  RCPROP_UISERVERLINK =         17; // Линка на UI сервер
  RCPROP_SUMMARYDATAFLOW =      18; // Суммарный поток данных
  RCPROP_PROJECTNAME =          19;
  RCPROP_CURRENTTAGNAME =       20; // Имя текущего тега [in, out] VT_BSTR
  RCPROP_CHANGEDSETTINGS =      21; // Измененные настройки SCF_XXX [in, out] U32
  RCPROP_ENABLEDLEVELSTOPREC =  22; // Разрешен стоп записи по уровню
  RCPROP_STOPRECLEVCTRLPROPS =  23; // Свойства стопа записи по уровню RCLEVELCONTROLPROPS        [out]
  RCPROP_PREHISTORY_ENABLED =   24; // Разрешена предзапись                                       [in, out] VT_BOOL
  RCPROP_PREHISTORY_TIME =      25; // Время предзаписи в секундах                                [in, out] VT_I4
  RCPROP_RESET_TIME_AT_START =  26; // Делать сброс счетчиков времени при старте просмотра/записи [in, out] VT_BOOL
  RCPROP_TRIGGER_START_MODE =   27; // Фронт для триггерного старта 1 - "1", 0 - "0"

  RCPROP_INTERNAL_BASE = $8000;
  RCPROP_USERMODE =        RCPROP_INTERNAL_BASE + 1; // Режим пользователя Simple/Advanced/More [out] VT_I4
  RCPROP_SHOWDISBALANCE =  RCPROP_INTERNAL_BASE + 2; // Показыватьразбаланс после балансировки [out] VT_BOOL
  RCPROP_ENABLEDRECPAUSE = RCPROP_INTERNAL_BASE + 3; // Разрешена пауза во время записи [out] VT_BOOL
  RCPROP_CALIBRATOR =           28;  //< Ссылка на объект калибратор [out] VT_UNK
  RCPROP_ENABLE_SPACE_RESERVE=  29;  //< Разрешено предварительное резервирование места на диске [in, out] VT_BOOL
	                                    //< для записи. "Балонная запис"
	RCPROP_SPACE_RESERVE_TIME=     30; //< Длина области для резервирования в секундах [in, out] VT_R8
	RCPROP_SECURITY_STATE=         31; //< Слово состояния режима безопастности/доступа [out]VT_UI4
	RCPROP_SYS_LOG=                32; //< Лог системных событий [out] VT_UNK
	RCPROP_PUT_CFG_FILE_TO_DATA=   33; //< Флаг необходимости сохранения файла конфигурации
	                                   //< соместно с данными [in, out] VT_BOOL
	RCPROP_FRAME_NAME =            34; //< Имя кадра записи, без пути [in, out] VT_BSTR
	RCPROP_LAST_DATA_LOCATION=     35; //< Месторасположение последних записанных данных [out] VT_BSTR
	RCPROP_USER_LOG=               36; //< Запрос (создание) юзерского лога [out]VT_UNK
	                                   //< При запросе в параметре должен быть путь к логу
	                                   //< если такой лог уже есть вернется тотже объект
	RCPROP_BATTERY_INFO =          37; //< Информация о состоянии батареи [out] VT_BSTR
	RCPROP_MAIN_TAGS_TABLE =       38; //< Таблица каналов	ImeTagsTable [out] VT_UNK
	RCPROP_FLUSH_BEFORE_CLOSE =    39; //< Делать сброс буферов перед закрытием файлов [in, out] VT_BOOL {v: 3.0.4.53}
	RCPROP_WRITE_CODES =           40; //< режим записи в кодах устройства для экономии
	                                   //< места [out] VT_BOOL {v: 3.0.4.65, 3.0.5.2}
	RCPROP_ALARM_GISTER_BY_RANGE = 41; //< метод вычисления гистерезиса уставок -
	                                   //< по значению или по диапазону  [out] VT_BOOL {v: 3.0.6.15, 3.0.5.16}
	RCPROP_PREVIEW_ENABLED =       42; //< Запись превью [out] VT_BOOL {v: 3.0.7.21}
	RCPROP_SAVE_CONFIG_DIALOG_AT_EXIT=43;  //< Отображать окно сохранения конфигурации при выходе, если были изменения
	                                   //< используется для сервернх решений [out] VT_BOOL {v: 3.0.7.40}
	RCPROP_LOST_SRC_TG_CNT=        44; //< Счетчик каналов отвалившихся от устройства [out] VT_UI4
	RCPROP_PLAYMODE_ENABLED=       45; //< Разрешение включения режима воспроизведения [in, out] VT_BOOL
	RCPROP_TIME=                   46; //< Системное время рекодера
	                                   //< Предполагается установка только из плагина воспроизведения,
	                                   //< архива, или подобных (есть своя система управления временем) [in, out] VT_R8
	RCPROP_INCLUDE_DEV_NAME_IN_TAG=47; //< Использовать наименование усройства в имени канала
	                                   //< по-умолчаию [out] VT_BOOL
	RCPROP_AUTO_STORE_VISUAL_CHANGES=48;///< Сохранять ли автоматически изменения в графической части
	RCPROP_TIME_MASHINE_PROPS=49;       ///< Ссылка на настройки машины времени [in, out] IUnknown
	RCPROP_FLUSH_SCALAR_TAGS=50;        ///< Флаг принудительного сброса (флюша) записи скалярных тегов [out] VT_BOOL
	RCPROP_FLUSH_SCALAR_PERIOD=51;      ///< Период для принудительного сброса (флюша) записи скалярных тегов [out] VT_I4 [мс]
	RCPROP_TIMESTAMP_AT_RECORD_START=52;///< Фиксировать время начала регистрации в .mera файле при начале записи
	                                  ///< обычно это делается в конце при закрытии файлов.
	                                  ///< Включение опции потенциально может привести к проблеммам при большом  [out] VT_BOOL

	RCPROP_USE_NEW_TRENDS=53;         ///< Специальная отладочная опция протащенная для возможности выключения эксперементальной графики тренлов [in,out] VT_BOOL
	RCPROP_WRITE_TARED=54;            ///< Запись данных в окончательном виде виде прошедшие через ГХ и КХ  [in,out] VT_BOOL
	RCPROP_DATA_FOLDER_TEMPLATE=55;   ///< Шаблон формирователя рабочего каталога[out] VT_UNK {v: 3.3.0.37,
	RCPROP_DATA_FRAME_TEMPLATE=56;    ///< Шаблон формирователя имени кадра данных [out] VT_UNK {v: 3.3.0.37,


  // Методы сортировки тегов для проперти RCPROP_TAGSSORTMODE
  SRTMD_BY_NAME =             0;// Сортировать по имени
  SRTMD_BY_ADDRESS =          1;//             по аппаратному адресу
  SRTMD_BY_DEVICENAME =       2;//             по имени устройства владельца

   //Флаги для функции DriverReset (RCN_DRIVERSRESET)
  DRF_SHOWPROCINDICATOR = 1; //Индицировать процесс ресета драйвера
  DRF_ONLYHOST =          2; //Делать ресет трлько хосту


   //Флаги системы управления режимом конфигурации
   //Config mode sharing flags
  CMSF_CONFIGCHANGED = $0001;   //Принудительная установка флага изменеия конфигурации
  //Флаги системы экспорта импорта настроек
  IESF_DEFAULTSETTINGS = $0001; //Сделать импортируемые/экспортируемые настройки
                                 //загружаемыми по умолчанию
  IESF_LOCAL_MODE =      $0002;

   //Коды изменения настроек и состояний рекордера
  //передаются вместе с нотификацией PN_LEAVERCCONFIG
  SCF_NOTING      = $0000;
  SCF_TAGSLIST    = $0001;
  SCF_TAGSCONTENT = $0002;

   //Стандартный размер строки
  STDSTRSIZE = 256;

   //Нотификации формуляров
  VSN_ENTERRCCONFIG = 0;  //Рекордер перешел в режим настройки
  VSN_LEAVERCCONFIG = 1;  //Рекордер вышел из режима настройки
  VSN_CHANGECURTAG  = 2;  //Сменился текущий тег, в параметре dwData
                           // номер тега, который становится выбранным.

  VSN_RCSAVECONFIG  = 8;  //Рекордер сохранил конфигурацию
  VSN_RCLOADCONFIG  = 9;  //Рекордер загрузил конфигурацию

  VSN_RCSTART       = 3;  //Рекордер перешел в режим измерения
  VSN_RCPLAY        = 4;  //Рекордер перешел в режим воспроизведения
  VSN_RCSTOP        = 5;  //Рекордер остановлен
  VSN_BEFORE_RCSTART= 14; //Рекордер переходит в режим измерения
  VSN_BEFORE_RCSTOP = 15; //Рекордер останавливается
  VSN_ABORT_RCSTART = 16; //Опереция старта была прервана

   // Индивидуальные нотификации
  VSN_SPECIFIED =      $4000; //
  VSN_RESIZE =         $4001; //Команда на изменение размера окна формуляра,
                               //  папраметр dwData содержит адрес структуры
                               //  типа TRect.
  VSN_CHANGEVIEWTIME = $4002; //Смена интервала отображения
  VSN_CHANGETIMESHIFT= $4003; //Смена смещения интервала отображения
  VSN_CHANGERCSTATE  = $4004; //Изменилось состояние Recorder в
                               //  dwData новое состояния.
  VSN_EditIFrm  = $4008;  // редактирование произвольного элемента???
  VSN_USER =           $7000; //Юзерские нотификации VFN_USER+XXXX

  /// Флаги пользовательских свойств
	UPROPFLAG_PERMANENT = $0001; //< Постоянное свойство, сохраняется с настройками объекта
	UPROPFLAG_MERA_FILE = $0002;  //< Свойство сохраняется с данными в .mera






type

   //Тип ссылка на аппаратный ресурс - псевдоним
   HARDLINK = DWORD;
   //Перечисление типа
   LEVEL = (
      LV_EQUAL,
      LV_ABOVE,
      LV_BELOW
   );

  //typedef struct tagRCLEVELCONTROLPROPS{
  //	ITag*     pTag;
  //	char      pchTagName[STDSTRSIZE];
  //	double    dblLevel;
  //	LEVEL     level;
  //}RCLEVELCONTROLPROPS,*PRCLEVELCONTROLPROPS;
   tagRCLEVELCONTROLPROPS = record
     pTag: ITag;
     pchTagName: array[0 .. STDSTRSIZE - 1] of ansichar;
     dblLevel: double;
     level: LEVEL;
   end;

  RCLEVELCONTROLPROPS = tagRCLEVELCONTROLPROPS;
  PRCLEVELCONTROLPROPS = ^RCLEVELCONTROLPROPS;


  //структура для сообщения
  //RCN_CHANGETAGRANGE  -  Поменять границы отображения для тега
  tagTAGRANGEDATA = record
    pTag: ITag;       {ссылка на интерфейс тега}
    dblBX: double;    {граница слева}
    dblBY: double;    {граница сверху}
    dblEX: double;    {граница справа}
    dblEY: double;    {граница снизу}
  end;
  TAGRANGEDATA = tagTAGRANGEDATA;
  PTAGRANGEDATA = ^TAGRANGEDATA;

  //Псевдоним для состояния Recorder`а
  RECORDERSTATE = DWORD;
  //Интерфейс формуляра отображения
  IVForm = interface;

   //Интерфейс для управления ядром измерительного ПО
   IRecorder = interface
   ['{EE880620-53EF-11d7-9244-00E029288A7F}']
      // Зарегистрировать формуляр отображения
      function RegisterIForm(const pIVForm: IVForm;
                            const lParam: longint): boolean; stdcall;
      // Исключить формуляр отображения из зарегистрированных объектов
      function UnregisterIForm(const pIVForm: IVForm): boolean; stdcall;

      // Получить формуляр отображения по имени
      function GetIFormByName(const pchName: LPCSTR): pointer{IVForm}; stdcall;
      // Получить формуляр отображения по индексу
      function GetIFormByIndex(const nIndex: ULONG): pointer{IVForm}; stdcall;

      //Получить тег по имени
      function GetTagByName(const pchName: LPCSTR): pointer{ITag}; stdcall;
      //Получить тег по индексу
      function GetTagByIndex(const nIndex: ULONG): pointer{ITag}; stdcall;
      //Получить число тегов
      function GetTagsCount: ULONG; stdcall;

      //Получить модуль по индексу
      function GetModuleByIndex(const nHostDeviceNum: ULONG;
                                const nIndex: ULONG): pointer{IModule}; stdcall;
      //Получить число модулей
      function GetModulesCount(const nHostDeviceNum: ULONG): ULONG; stdcall;

      //Получить группу по индексу
      function GetGroupByIndex(const nIndex: ULONG): pointer{ITagsGroup}; stdcall;
      //Получить число групп тегов
      function GetGroupsCount: ULONG; stdcall;

      //Получить состояние рекордера
      function GetState(const rsMask: RECORDERSTATE): RECORDERSTATE; stdcall;
      //Проверить состояние рекордера
      function CheckState(const rsState: RECORDERSTATE): boolean; stdcall;

      //Получить имя файла для сохранения сигнала
      function GetSignalFrameName: LPCSTR; stdcall;
      //Получить имя папки для сохранения сигнала
      function GetSignalFolderName: LPCSTR; stdcall;

      //Создать новый тег
      function CreateTag(const pchName: LPCSTR; const ls: LINKSTATE;
                         const a_pParams: pointer): pointer{ITag}; stdcall;
      //Уничтожить новый тег
      function CloseTag(const piTag: ITag): boolean; stdcall;

      //Уведомить рекордер о неком событии
      function Notify(const dwCommand: DWORD; const dwParam: DWORD): boolean; stdcall;

      {Установка кода последней ошибки}
      procedure SetLastError(const dwErrorCode: DWORD); stdcall;
      {получение кода последней ошибки}
      function GetLastError: DWORD; stdcall;
      {Формирование строки описания ошибки по коду}
      function ConvertErrorCodeToString(const dwErrorCode: DWORD): LPCSTR; stdcall;

      // Получить свойство
      function GetProperty(const dwPropertyID: DWORD;
                          var Value: OleVariant): HRESULT; stdcall;
      // Задать свойство
      function SetProperty(const dwPropertyID: DWORD;
                           {const} Value: OleVariant): HRESULT; stdcall;

      //Переменные окружения
      //Задать текущий каталог переменных окружения
      function SetEnvironmentCurDir(const pchDir: LPCSTR): boolean; stdcall;
      //Получить текущий каталог переменных окружения
      function GetEnvironmentCurDir(const pchDir: LPCSTR;
                                   const nLength: integer): boolean; stdcall;

      //Получить значение переменной окружения в виде варианта
      function GetEnvironmentVar(const pchVarID: LPCSTR;
                                var varVal: OleVariant): boolean; stdcall;
      //Установить значение переменной окружения в виде варианта
      function SetEnvironmentVar(const pchVarID: LPCSTR;
                                var varVal: OleVariant): boolean; stdcall;

      //Получить значение переменной окружения в виде long
      function GetEnvironmentLong(const pchVarID: LPCSTR;
                                 var lVal: longint): boolean; stdcall;
      //Установить значение переменной окружения в виде long
      function SetEnvironmentLong(const pchVarID: LPCSTR;
                                 const lVal: longint): boolean; stdcall;

      //Получить значение переменной окружения в виде double
      function GetEnvironmentDouble(const pchVarID: LPCSTR;
                                   var dblVal: double): boolean; stdcall;
      //Установить значение переменной окружения в виде double
      function SetEnvironmentDouble(const pchVarID: LPCSTR;
                                   const dblVal: double): boolean; stdcall;

      //Получить значение переменной окружения в виде char*
      function GetEnvironmentString(const pchVarID: LPCSTR; const pchVal: LPCSTR;
                                   var pnLength: integer): boolean; stdcall;

      //Установить значение переменной окружения в виде char*
      function SetEnvironmentString(const pchVarID: LPCSTR;
                                   const pchlVal: LPCSTR): boolean; stdcall;

      //Добавить в лог строку с переводом каретки
      function LogMessage(const pchMessage: LPCSTR): boolean; stdcall;
      //Получить манипулятро (handle) главного окна приложения 
      function GetHWND: HWND; stdcall;
      //получить ссылку на интерфейс выбранного в данный момент тега
      function GetCurrentTag: pointer{ITag}; stdcall;
      //выбрать тег
      function SetCurrentTag(const nIndex: ULONG): HRESULT; stdcall;

      //Получить индекс тега по указателю
      // v1.06.2+
      function GetTagIndexByPointer(const pTag: ITag): integer; stdcall;

      //Получить число устройств
      // v1.09
      function GetDevicesCount: integer; stdcall;

      //Получить имя файла проэкта *.cfg
      // v1.09.2.3
      function GetProjectName: LPCSTR; stdcall;

      //Получить полный путь
      // v1.10
      function GetRcBasePath: LPCSTR; stdcall;

      //Управление группами тегов
      //Получить группу по имени
      // v1.10.1
      function GetGroupByName(const pchName: LPCSTR): pointer{ITagsGroup}; stdcall;
      //Удалить группу
      function DeleteTagsGroup(const pGrp: ITagsGroup): HRESULT; stdcall;
      //Добавить группу
      function CreateTagsGroup(const a_pchName: LPCSTR): pointer{ITagsGroup}; stdcall;

      //Импортировать настройки
    	// IESF_DEFAULTSETTINGS = 0x0001,  ///< Сделать импортируемые/экспортируемые настройки ///< загружаемыми по умолчанию
    	// IESF_LOCAL_MODE = 0x0002		///< Режим локального импорта / экспорта. Флаг говорит рекордеру, что операция производится в режиме рабочей станции
			// При его отсутствии плагинам посылаются специальные уведомления об экспорте настроек по конкретному адресу
      // обычная загрузка/сохранение это IESF_DEFAULTSETTINGS+IESF_LOCAL_MODE
      function ImportSettings(const pchName: LPCSTR;
                             const dwFlags: DWORD): HRESULT; stdcall;
      //Экспортировать настройки
      function ExportSettings(const pchName: LPCSTR;
                             const dwFlags: DWORD): HRESULT; stdcall;

      //Методы разграничения доступа к настройкам рекордера
      //Очень настоятельно рекомендуется использовать при конфигурировании

      //Войти в режим настройки
      function EnterConfigMode(const pInitiator: IUnknown;
                              const dwFlags: DWORD): HRESULT; stdcall;

      //Выйти из режима настройки
      function LeaveConfigMode(const pInitiator: IUnknown;
                              const dwFlags: DWORD): HRESULT; stdcall;

      //Получить текщее состояние режима настройки
      function GetConfigModeState(var dwFlags: DWORD): ULONG; stdcall;

      //Получить инициатора режима настройки
      function GetConfigModeInitiator: pointer{IUnknown}; stdcall;

      //Интерфейсы для работы с аппаратными каналами

      //Получить список доступных каналов
      function dvchGetAvailableChansCount: ULONG; stdcall;
      //Получить идентификатор аппаратного канала по индексу
      function dvchGetChansList(var pIDList: HARDLINK): HRESULT; stdcall;
      //Получить адрес аппаратного канала по идентификатору
      function dvchGetAddress(const hlID: HARDLINK; const pchAddress: LPCSTR;
                             var nBuffLen: integer): HRESULT; stdcall;
      //Получить название устройства владельца аппаратного канала по идентификатору
      function dvchGetDeviceName(const hlID: HARDLINK; const pchDeviceName: LPCSTR;
                                var nBuffLen: integer): HRESULT; stdcall;
      //Получить название устройства владельца аппаратного канала по идентификатору
      function dvchGetDeviceInfo(const hlID: HARDLINK; const pchDeviceInfo: LPCSTR;
                                var nBuffLen: integer): HRESULT; stdcall;

      function MultiTagSynchroReadDataBlock(const dwCount: DWORD;
           var pTag: ITag; const dwPortionLen: DWORD; var pdblFreq: double;
           var ppdblData; const boolViaTransformer: BOOL): HRESULT; stdcall;

    // since v 1.19

    //Сформировать полный путь к файлу относительно рекордера
    function MakeFullPath(const pchLocalPath: LPCSTR): LPCSTR; stdcall;

    //Взвести флаг состояния рекордера
    procedure PushState( const rsState: integer); stdcall;
    //Сбросить флаг состояния рекордера
    procedure PopState( const rsState: integer); stdcall;

    //Получить ссылку на устройство по индексу
    function GetDeviceByIndex( var pDevice: IDevice;
                               const ulIndex: ULONG): HRESULT; stdcall;

    //Получить код инициализации устройства по индексу
    function GetDeviceInitStateByIndex(const ulIndex: ULONG): ULONG; stdcall;



    //Добавить устройство в список рекордера
    function AddDevice( pDevice: IDevice; const ulIndex: ULONG): HRESULT; stdcall;
    //Удалить устройство из списка рекордера
    function RemoveDevice( const ulIndex: ULONG): HRESULT; stdcall;

    function GetDeviceControlClassObject( var ppv): HRESULT; stdcall;
    function GetPluginsControlClassObject( var ppv): HRESULT; stdcall;

    function CreateInfoFile( const pchPath: LPCSTR;
                             pGroup: ITagsGroup): HRESULT; stdcall;

    //Задать имя фрейма для сохранения сигнала
    function SetSignalFrameName( const pcFrameName: LPCSTR): HRESULT; stdcall;
    
    //Счетчик времени в секундах с момента запуска просмотра/записи
    function GetTimeCounter: double; stdcall;

    //Получить глобальный счетчик принятых пакетов,
    //можно отслеживать стабильность получения данных
    function GetSummaryReceivedPacketsCount: ULONG; stdcall;

    //Получить счетчик принятых пакетов до с броса функцией ResetReceivedPacketsCount
    //можно отслеживать стабильность получения данных
    function GetReceivedPacketsCount: ULONG; stdcall;
    function GetSummaryCounter: ULONG; stdcall;
    function ResetReceivedPacketsCount: ULONG; stdcall;

    function IncSummaryTime( const liVal: LONGLONG): ULONG; stdcall;

    function GetWorkTime( var dblTime: double): HRESULT; stdcall;

    function ResetWorkTime: HRESULT; stdcall;

    //Получить уровень загрузки процессора на уровне обработчика IRQ
    function GetPerformanceTimeIRQ( var dblTime: double): HRESULT; stdcall;

    function ResetPerformanceTimeIRQ: HRESULT; stdcall;

    //Получить уровень загрузки процессора на уровне ядра драйвера
    function GetPerformanceTimeDriver( var dblTime: double): HRESULT; stdcall;

    function ResetPerformanceTimeDriver: HRESULT; stdcall;

    //Получить уровень загрузки процессора
    function GetCPUUsage( var pdblCPU: double): HRESULT; stdcall;

    //Получить серийный номер устройства по идентификатору
    function dvchGetDeviceSerialNumber( const hlID: HARDLINK;
             pchDeviceSerialNumber: LPCSTR;
             var nBuffLen: integer): HRESULT; stdcall;
    /// since v 2.7.0.9
    /// Получить время последнего пакета от устройства
    /// Используется для отслеживаия связи с устройством
    //virtual HRESULT     STDMETHODCALLTYPE GetDeviceLastActivityTime(ULONG a_ulIndex, double* a_pdblTime)=0;
    function GetDeviceLastActivityTime( a_ulIndex: ULONG; var a_pdblTime: double): HRESULT; stdcall;

    /// since v 2.7.0.15
    ///Получить описание аппаратного канала по нардлинку
    //virtual HRESULT     STDMETHODCALLTYPE dvchGetChanInfo(HARDLINK a_hlID, char* a_pchChanInfo, int* p_nBuffLen)=0;
    function dvchGetChanInfo( a_hlID: HARDLINK; var a_pchChanInfo: double; pchName: LPCSTR; var p_nBuffLen:integer): HRESULT; stdcall;

    /// since v 2.7.1.0
    /// Разрешить/запретить для устройства общий старт
    //virtual HRESULT     STDMETHODCALLTYPE EnableCommonStartForDevice(IDevice* a_pDevice, VARIANT_BOOL a_vbEnable)=0;
     function EnableCommonStartForDevice( a_pDevice: IDevice; a_vbEnable: VARIANT_BOOL): HRESULT; stdcall;

    /// Разрешить/запретить для устройства общий стоп
    //virtual HRESULT     STDMETHODCALLTYPE EnableCommonStopForDevice(IDevice* a_pDevice, VARIANT_BOOL a_vbEnable)=0;
    function EnableCommonStopForDevice(a_pDevice: IDevice; a_vbEnable: VARIANT_BOOL): HRESULT; stdcall;
    /// since v 2.7.5.0
    ///Счетчик времени в секундах с момента запуска просмотра/записи в шкале СЕВ
    //virtual double  STDMETHODCALLTYPE GetUTSTimeCounter() = 0;
    function GetUTSTimeCounter(): double; stdcall;
    /// Временно тут ее потом не бует
    //virtual HRESULT			STDMETHODCALLTYPE RunFn(void* a_fn,void* a_param) = 0;
    function RunFn(a_fn:pointer; a_param:pointer): HRESULT; stdcall;
    /// Уничтожение объекта ядра
    /// без очистки выделенной под него памяти
    //virtual HRESULT			STDMETHODCALLTYPE Destroy() = 0;
    function Destroy(): HRESULT; stdcall;
    /// Получение ссылки для управления свойстваи объкта драйвера
    //virtual HRESULT			STDMETHODCALLTYPE GetPropertyAccess(IPropertyAccess** ppAccess, HANDLE h)=0;
    function GetPropertyAccess(ppAccess:pointer; g:cardinal): HRESULT; stdcall;

    ///Сформировать полный путь к файлу относительно каталога даных (data) sd:/Mera Files/Recorder
    //virtual const char* STDMETHODCALLTYPE MakeFullPathData(const char* a_pchLocalPath)=0;
    function MakeFullPathData(a_pchLocalPath:LPCSTR): HRESULT; stdcall;

    /// since v 3.0.6.16
    ///Получить свойство аппаратного канала по нардлинку
    //virtual HRESULT     STDMETHODCALLTYPE dvchGetChanProperty(HARDLINK a_hlID, ULONG a_nPropID, VARIANT& a_varProp) = 0;
    function dvchGetChanProperty (a_hlID:HARDLINK;a_nPropID:ULONG; var a_varProp: OleVariant): HRESULT; stdcall;
    /// since v 3.0.7.71
    /// Найти тег по TAGID
    //virtual HRESULT     STDMETHODCALLTYPE GetTagByTagId(TAGID id, ITag** ppTag) = 0;
    function GetTagByTagId (id: TAGID; var ppTag: ITag): HRESULT; stdcall;
   end;

   //Тип для работы с массивом ссылок на теги
   TagsArray = array[0..0] of ITag;

   //Интерфейс для управления специализированными формулярами отображения
   IVForm = interface
   ['{95001263-E83C-11d6-9243-00E029288A7F}']
      //Получить имя формы должно быть уникальным, используется при регистрации
      function GetName: LPCSTR; stdcall;
      //Инициализация формы
      function Init(pParent: IRecorder; hParent: HWND; lParam: longint): boolean; stdcall;
      //Получить HWND формы
      function GetHWnd: HWND; stdcall;
      //Вызывается при закрытии формы
      function Close: boolean; stdcall;
      function Prepare: boolean; stdcall;
      function Update: boolean; stdcall;
      //Перерисовка формы
      function Repaint: boolean; stdcall;
      //Привязка к тегам рекордера
      function LinkTags( var pTagsList: TagsArray;
                         var nTagsCount: ULONG): boolean; stdcall;
      //Активизация формы
      function Activate: boolean; stdcall;
      //Деактивизация формы
      function Deactivate: boolean; stdcall;
      //Вызов окна редактирования
      function Edit: boolean; stdcall;
      //События, уведомления, команды
      function Notify(const dwCommand: DWORD; const dwData: DWORD): boolean; stdcall;
   end;

  ISettingsINI = interface
	['{4D6850A1-FED3-490c-A277-BC9AEA2C146F}']
		function WriteSettings(const pchPath:LPCSTR; const pchSection: LPCSTR):HRESULT;stdcall;
		// Прочитать настройки
		function ReadSettings(const pchPath:LPCSTR; const pchSection:LPCSTR):HRESULT;stdcall;
  end;

/// @interface IUserProperties Поддержка пользовательского набора свойств у объекта
///

  IUserProperties = interface
  ['{382A1241-052A-4bb6-8E71-DB0508E510B7}']
    //	const BSTR ,const VARIANT& , const ULONG  = 0
    function SetUserProperty(const a_pPropId:widestring; var a_varValue:OleVariant;const a_nFlags:ULONG):HRESULT;stdcall;
    /// Прочитать значение свойства
    /// если данное свойство ранее не устанавливали будет возвращено
    /// S_FALSE
    function GetUserProperty(const a_pPropId:widestring; var a_varValue:OleVariant):HRESULT;stdcall;
    /// Получение числа установленных свойств
    function GetUserPropertiesCount(var a_pnCount:ULONG):HRESULT;stdcall;
    /// Получение свойства по индексу
    /// возвращается пара значений имя и значение свойства
		// ULONG a_pnIndex,BSTR* const a_pbstrPropId,VARIANT& a_varValue
    function GetUserPropertyByIndex(a_pnIndex:ULONG; var a_pbstrPropId:TBStr; var a_varValue:OleVariant):HRESULT;stdcall;
  end;

const
  // {382A1241-052A-4bb6-8E71-DB0508E510B7}
  IID_IUserProperties: TGUID = (
    D1:$382A1241;D2:$052A;D3:$4bb6;D4:($8E,$71,$DB,$05,$08,$E5,$10,$B7));

  IID_IVForm: TGUID = (
    D1:$95001263;D2:$E83C;D3:$11d6;D4:($92,$43,$00,$E0,$29,$28,$8A,$7F));

  IID_ISettingsINI: TGUID = (
    D1:$4D6850A1;D2:$FED3;D3:$490c;D4:($A2,$77,$BC,$9A,$EA,$2C,$14,$6F));




implementation


end.
