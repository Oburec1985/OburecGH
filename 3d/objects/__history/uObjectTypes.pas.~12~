unit uObjectTypes;

interface

uses Mathfunction,opengl,windows,umatrix,uCommonTypes;

type
  MouseStruct = record
    rect:trect; // координаты окошка в глобальных координатах экрана
    // нажата левая кнопка мыши
    LButtonDown:boolean;
    // координаты нажатия кнопки мыши
    LButtonPos:tpoint;
    cx, cy, dx, dy, x,y:integer; // предыдущие координаты мыши внутри окна
    m_bChangeX,m_bChangeY:boolean;
    m_strafe:vector3f;
    m_RotSens,m_MoveSens:single;// Чувствительность при вращении камеры.
    wheel:short;    
  end;

  tbound = record
    exist:boolean;  
    lo,hi:point3;
  end;

  // Класс камеры -----------------------------------------------------
 cWindowContext = class
   Dc :hdc      ;//Контекст устройства
   hrc:HGLRC    ;//контекст воспроизведения Ogl
   Handle:Hwnd  ;//Дескриптор окна в котором происходит рендеринг
   Bound:Trect  ;//Габариты окна в котором рендериться изображение
   axislength:single; // длина осей выделеных объектов    
   ClientWidth,ClientHeight:integer;
   color:point3;
 end;

const
  // --------------------- Опции объекта
  DRAW_NODE = $0001; // рисовать систему координат узла
  DRAW_LOCAL = $0002; // рисовать систему локальную координат
  DRAW_NORMAL = $0004; // рисовать нормали
  draw_bound = $0008; // рисовать ограничивающий объем
  draw_Parent = $0010; // рисовать систему координат родителя
  draw_Points = $0020; // рисовать вершины
  draw_Geom = $0040; // рисовать геометрию
  draw_Edges = $0080; // рисовать каркас
  DRAW_TARGET = $0100; // рисовать систему координат узла
  Use_Colors = $0100; // Использовать цвета точек
  DRAW_ALL = $00ff; // рисовать все
  // --------------------- Опции камеры
  C_ACTIVECAMERA = $0200;

  ACTIVECAMERA = $1000;



  constmesh = 0;

  constLightImgIndex = 23;
  constcameraImgIndex = 22;
  constShapeImgIndex = 24;
  constdummyImgIndex = 3;

  constLight = 23;
  constcamera = 22;
  constShape = 24;
  constdummy = 3;
  constQuatObject = 4;
  constNodeObject = 5;
  constlog = false;

  constWorld = 0;
  constNode = 1;
  constLocal = 2;
  constParent = 3;
  constView = 4;

// Умножить boundbox на матрицу
function MultBoundByM(b:tbound;m:matrixgl):tbound;

implementation


function MultBoundByM(b:tbound;m:matrixgl):tbound;
begin
  b.lo:=multp3bym(m,b.lo);
  b.hi:=multp3bym(m,b.hi);
  if b.lo.x<b.hi.x then
  begin
    result.lo.x:=b.lo.x;
    result.hi.x:=b.hi.x;
  end
  else
  begin
    result.lo.x:=b.hi.x;
    result.hi.x:=b.lo.x;
  end;
  //----------------------
  if b.lo.y<b.hi.y then
  begin
    result.lo.y:=b.lo.y;
    result.hi.y:=b.hi.y;
  end
  else
  begin
    result.lo.y:=b.hi.y;
    result.hi.y:=b.lo.y;    
  end;
  //----------------------
  if b.lo.z<b.hi.z then
  begin
    result.lo.z:=b.lo.z;
    result.hi.z:=b.hi.z;
  end
  else
  begin
    result.lo.z:=b.hi.z;
    result.hi.z:=b.lo.z;
  end;
end;


end.
