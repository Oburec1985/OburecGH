// файлы DesignIntf DesignEditors и Proxies становятся доступны
// после подключения $(Delphi)Lib/designide.dcp
unit uBaseGlComponent;

interface

uses
  SysUtils, Classes, Controls, messages, dialogs, uSceneMng, ExtCtrls,
  stdctrls,
  uUI,
  uObjCtrFrame,
  forms,
  uRender,
  uobject,
  ueditobj,
  uNodeObject,
  uGlBaseItem,
  uGlComponent,
  windows,
  uEventList,
  uClickFrListener,
  uTransformButtons,
  PathUtils,
  uglEventTypes;

const
  E_ComponentInit = 1;

type

  cBaseGlComponent = class(tpanel)
  protected
    res: string;
    scene: string;
    // декорации на сцене. Объекты созданы без помощи idesigner
    mObjects: array of ceditobj;
    ClickFrame: cClickFrListener;

    fShowTransforms:boolean;
    //TransformToolsFrame: TTransformToolsFrame;
    TransformToolsFrame: TCtrlViewFrame;
  public
    // сслыка на список событий компонента
    EList: cEventList;
    // Если свойство true значит объект был обновлен и сцену надо сохранить
    update: boolean;
    // ссылка на объект движка
    mUI: cUI;
    // Объекты созданы с помощью idesigner
    SubComponents: TList;
  protected
    fOnInit: tNotifyEvent;
  public
    Constructor Create(AOwner: TComponent); override;
    destructor destroy; override;
    procedure redraw;
    // Удалить компонент из списка детей
    procedure RemoveChild(component: TComponent);
  protected
    procedure createEvents;
    procedure DeleteEvents;
    // создание списка объектов cEditObjects для сохранения в dfm файл
    procedure lincObjects;
    // создание списка объектов cEditObjects для сохранения в dfm файл
    procedure deleteobjects;
    // здесь происходит загрузка сцены
    procedure init;
    // получить/установить путь к ресурсам
    procedure SetSceneName(val: string);
    function GetSceneName: string;
    // получить/установить путь к ресурсам
    procedure SetResources(val: string);
    function GetResources: string;
    // Получить записать объект сцены
    function getObj: cobject;
    // -------------------------------
    function readObj(i: integer): ceditobj;
    procedure WndProc(var Message: TMessage); override;
    // вызывается после загрузки формы
    procedure Loaded; override;
    procedure CreateFrames;
    // создание фреймов для редактирования сцены
    procedure linkFormFrames;
  protected
    // Процедура которая вызывается при сохранении сцены
    procedure WriteState(Writer: TWriter); override;
    // Переопределенный метод для сохранения свойств объектов
    // Позволяет указать ссылку на процедуру которая будет сохранять то или иное
    // свойство
    procedure DefineProperties(Filer: TFiler); override;
    // function GetChildOwner:tcomponent; override;
    // function GetChildParent:tcomponent;override;
    procedure OnDestroyScene(Sender: tobject);
  private
    // процедура сохранения измененных свойств объектов в форму
    procedure readObjects(Reader: TReader);
    // процедура загрузки измененных свойств объектов в форму
    procedure writeObjects(Writer: TWriter);
    //
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    function getSubComponent(index: integer): glRegItem;
    procedure InitScene;
    // инициализация контекста окна. Происходит при первом показывании окна
    procedure Oninithandle(var Message: TCMControlListChanging);
    message wm_size;
    // событие смены курсора
    procedure changecursor(Sender: tobject);
    // событие смены курсора при убирании выделения
    procedure changecursorOnUnselect(Sender: tobject);
  public
    // заведено для того. чтобы сохранять
    property objects[i: integer]: ceditobj read readObj;
  public
  public
    property subComponent[index: integer]: glRegItem read getSubComponent;
  protected
    Procedure SetShowTransforms(b: boolean);
  published
    // Позиция объекта
    // property position:cpoint3 read pos write pos;
    // Свойство отвечает за объекты сцены
    property obj: cobject read getObj;
    property scenename: string read GetSceneName write SetSceneName;
    property resources: string read GetResources write SetResources;
    property ShowTrasforms: boolean read fShowTransforms write
      SetShowTransforms;
  published
    property OnInitScene: tNotifyEvent read fOnInit write fOnInit;
  end;

implementation

procedure cBaseGlComponent.linkFormFrames;
begin
  // TVframe:=TSceneTVFrame.Create(self);
  // g_ui.scene.images_16:=ImageList_16;
  // g_ui.scene.images_32:=ImageList_32;
  // tvframe.link(g_UI, GroupBox1, ImageList_32);

  //TransformToolsFrame:=TTransformToolsFrame.Create(self);
  //TransformToolsFrame.Parent := self;
  //TransformToolsFrame.Lincscene(mUI);
  //TransformToolsFrame.Visible := ShowTrasforms;

  {gb:=TGroupBox.Create(self);
  gb.Align:=alBottom;
  gb.Height:=200;
  TransformToolsFrame:=TCtrlViewFrame.Create(gb);
  TransformToolsFrame.Align:=alRight;
  TransformToolsFrame.Parent :=gb;
  TransformToolsFrame.lincScene(mUI);}
end;

procedure cBaseGlComponent.changecursor(Sender: tobject);
begin
  if mUI <> nil then
    cursor := mUI.cursor;
end;

procedure cBaseGlComponent.changecursorOnUnselect(Sender: tobject);
begin
  if mUI <> nil then
  begin
    if mUI.cursor <> crdefault then
    begin
      mUI.cursor := crdefault;
      cursor := mUI.cursor;
    end;
  end;
end;

procedure cBaseGlComponent.redraw;
begin
  if mUI <> nil then
    mUI.m_RenderScene.invalidaterect;
end;

// Переопределенный метод для сохранения свойств объектов
procedure cBaseGlComponent.DefineProperties(Filer: TFiler);
begin
  inherited DefineProperties(Filer);
  self.DockSite := true;
  // Определить методы сохранения свойства TextHistory в файл формы
  // Filer.DefineProperty('Objects', readObjects, writeObjects, true);
end;

procedure cBaseGlComponent.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  i: integer;
begin
  inherited;
  if SubComponents <> nil then
  begin
    for i := 0 to SubComponents.Count - 1 do
    begin
      Proc(TComponent(SubComponents.Items[i]));
      // Proc(TComponent(Components[i]));
    end;
  end;
end;

procedure cBaseGlComponent.RemoveChild(component: TComponent);
var
  i: integer;
begin
  for i := 0 to SubComponents.Count - 1 do
  begin
    if SubComponents.Items[i] = component then
    begin
      SubComponents.Delete(i);
      exit;
    end;
  end;
end;

// процедура сохранения измененных свойств объектов в форму
procedure cBaseGlComponent.readObjects(Reader: TReader);
begin
  try
    // Найти маркер начала списка
    Reader.ReadListBegin;
    // Загрузить элементы списка истории
    while not Reader.EndOfList do
    begin
      Reader.ReadString;
    end;
    // Прочитать маркер окончания списка
    Reader.ReadListEnd;
  except
    raise ;
  end;
end;

procedure cBaseGlComponent.WriteState(Writer: TWriter);
var
  i: integer;
  obj: ceditobj;
begin
  inherited WriteState(Writer);
  if update then
  begin
    update := false;
    if mUI <> nil then
    begin
      mUI.scene.SaveScene(scene);
    end;
  end;
  for i := 0 to ComponentCount - 1 do
  begin
  end;
  // Writer.Root:=self;
  // for I := 0 to length(mobjects) - 1 do
  // begin
  // obj := mobjects[i];
  // if obj.Owner = Writer.Root then
  // Writer.WriteComponent(obj);
  // end;
end;

// процедура загрузки измененных свойств объектов в форму
procedure cBaseGlComponent.writeObjects(Writer: TWriter);
var
  len, i: integer;
begin
  // Записать маркер начала списка
  len := length(mObjects);
  if len = 0 then
    exit;
  Writer.WriteListBegin;
  // Записать историю изменений
  // Writer.root:=self;
  // Writer.WriteComponent(self);
  // for i:=0 to len-1 do
  // begin
  // end;
  // Записать маркер окончания списка
  Writer.WriteListEnd;
end;

procedure cBaseGlComponent.deleteobjects;
var
  i, len: integer;
begin
  len := length(mObjects);
  for i := 0 to len - 1 do
  begin
    mObjects[i].destroy;
  end;
  setlength(mObjects, 0);
end;

procedure cBaseGlComponent.lincObjects;
var
  len, i: integer;
  obj: ceditobj;
begin
  if mUI <> nil then
  begin
    len := mUI.scene.Count;
    setlength(mObjects, len);
    for i := 0 to len - 1 do
    begin
      obj := ceditobj.Create(self);
      mObjects[i] := obj;
      obj.SetObj(cobject(mUI.scene.getObj(i)));
    end;
  end;
end;

procedure cBaseGlComponent.init;
begin
  if fileexists(scene) then
  begin
    if mUI <> nil then
    begin
      mUI.m_RenderScene.LoadScene(scene);
      lincObjects;
    end;
  end;
end;

procedure cBaseGlComponent.Loaded;
begin
  inherited;
  InitScene;
end;

procedure cBaseGlComponent.SetSceneName(val: string);
begin
  scene := val;
  init;
end;

function cBaseGlComponent.GetSceneName: string;
begin
  result := scene;
end;

Procedure cBaseGlComponent.SetShowTransforms(b: boolean);
begin
  fShowTransforms:=b;
  if TransformToolsFrame<>nil then
    TransformToolsFrame.Visible := b;
end;

function cBaseGlComponent.readObj(i: integer): ceditobj;
var
  obj: cobject;
  len: integer;
begin
  // Если не поставить nil редактор свойств будет ругаться
  len := length(mObjects);
  result := nil;
  if mUI <> nil then
  begin
    if i < len then
      result := mObjects[i];
  end;
end;

function cBaseGlComponent.getObj: cobject;
var
  obj: cobject;
begin
  // Если не поставить nil редактор свойств будет ругаться
  result := nil;
  if mUI <> nil then
  begin
    result := cobject(mUI.getselected);
  end;
end;

procedure cBaseGlComponent.Oninithandle;
begin
  InitScene;
  // показывать фрейм редактирования вида и положений объектов
  if TransformToolsFrame=nil then
  begin
    ShowTrasforms:=true;
    //linkFormFrames;
  end;
end;

procedure cBaseGlComponent.InitScene;
begin
  if Parent <> nil then
  begin
    if Parent.HandleAllocated then
    begin
      if HandleAllocated then
      begin
        if fileexists(res) then
        begin
          if mUI = nil then
          begin
            mUI := cUI.Create(handle, res);
            init;
            createEvents;
            // вызов событий подписанных компонентов
            if EList <> nil then
              EList.CallAllEvents(E_ComponentInit);
            CreateFrames;
            if assigned(fOnInit) then
              fOnInit(self);
          end
          else
          begin
          end;
        end;
      end;
    end;
  end;
end;

procedure cBaseGlComponent.createEvents;
begin
  mUI.EventList.AddEvent(name + 'changecursor', E_glMouseMove, changecursor);
  mUI.EventList.AddEvent(name + 'changecursorunselect', E_glUnSelect,
    changecursorOnUnselect);
  mUI.EventList.AddEvent(name + 'OnDestroyScene', E_GlOnDestroyScene,
    OnDestroyScene);
end;

procedure cBaseGlComponent.DeleteEvents;
begin
  mUI.EventList.removeEvent(changecursor, E_glMouseMove);
  mUI.EventList.removeEvent(changecursorOnUnselect, E_glUnSelect);
  mUI.EventList.removeEvent(OnDestroyScene, E_GlOnDestroyScene);
end;

procedure cBaseGlComponent.SetResources(val: string);
var
  curdir:string;
begin
  curdir:=GetCurrentDir;
  val:=RelativePathToAbsolute();
  res := val;
  if not(csLoading in componentstate) then
  begin
    InitScene;
  end;
end;

function cBaseGlComponent.GetResources: string;
begin
  result := res;
end;

Constructor cBaseGlComponent.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);

  Parent := TWinControl(AOwner);
  Width := 200;
  hEIght := 200;
  resources := '';
  scenename := '';
  update := false;
  SubComponents := TList.Create;
  EList := cEventList.Create(self, false);

  // SetSubComponent(true);
end;

destructor cBaseGlComponent.destroy;
begin
  if mUI <> nil then
  begin
    mUI.destroy;
  end;
  deleteobjects;
  if SubComponents <> nil then
    SubComponents.destroy;
  if EList <> nil then
    EList.destroy;
  inherited destroy;
end;

procedure cBaseGlComponent.WndProc(var Message: TMessage);
begin
  inherited WndProc(Message);
  case Message.Msg of
    wm_paint:
      begin
        if mUI <> nil then
        begin
          if handle <> mUI.m_RenderScene.m_wndContext.handle then
          begin
            mUI.updatehandle := true;
          end;
        end;
        // mUI.m_RenderScene.RenderScene;
      end;
  end;
end;

{
  // процедура загрузки измененных свойств объектов в форму
  procedure cBaseGlComponent.writeObjects(Writer: TWriter);
  var
  i:integer;
  begin
  // Записать маркер начала списка
  Writer.WriteListBegin;
  // Записать историю изменений
  for i:=0 to mUI.m_RenderScene.GetCount-1 do
  begin
  Writer.WriteString(mUI.m_RenderScene.m_Loader.GetObj(i).name);
  end;
  // Записать маркер окончания списка
  Writer.WriteListEnd;
  end;
}

procedure cBaseGlComponent.CreateFrames;
begin
  if mUI <> nil then
  begin
    ClickFrame := cClickFrListener.Create(mUI, 'cClickFrListener');
    mUI.framelistener.add(ClickFrame);
  end;
end;

function cBaseGlComponent.getSubComponent(index: integer): glRegItem;
begin
  result := nil;
  if SubComponents <> nil then
  begin
    if (index >= 0) and (index < SubComponents.Count) then
      result := glRegItem(SubComponents.Items[index]);
  end;
end;

procedure cBaseGlComponent.OnDestroyScene(Sender: tobject);
begin
  mUI := nil;
end;

end.
