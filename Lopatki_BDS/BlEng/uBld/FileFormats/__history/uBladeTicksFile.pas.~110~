unit uBladeTicksFile;

interface
uses
 Messages, controls, ComCtrls, classes, SysUtils, Windows,inifiles,
 uTickData, uSensor, uBaseObj, ubldeng, ubinfile, uLoadBldForm, uBaseObjInt,
 uVectorlist, uchan, ubaseobjstr, uSetList, uCommonMath, uTicks, uArrayTicks;

type
  cFile =  class
  public
    chan:integer;
    f:file;
  public
    constructor create(name:string ;read:boolean; p_chan:integer);
    destructor destroy;
  end;

  cBladeTicksFile = class
  private
    channels:cBaseObjInt;
    folder, m_name:string;
    fileList:TStringList;
  private
    // освободить файлы
    procedure ReleaseFiles;
    // создать файлы
    procedure Readfiles;
    // создаем файлы для записи данных
    procedure Writefiles;
    // пишем в файл с именем name
    procedure ReadData(name:string;ticks:cbaseticks);overload;
    procedure ReadData(chan:cchan);overload;
    procedure ReadDataToArrayTicks(ticks:cArrayTicks; f:cfile);
    procedure WriteData(name:string;ticks:cbaseticks);overload;
    procedure WriteData(chan:cchan);overload;
    // пишем заголовок данных
    procedure WriteHeader;
    // получить созданный файл по индексу или имени
    function getfile(i:integer):cFile;overload;
    function getfile(name:string):cFile;overload;
  public
    // двиг, папка с замером, имя заголовка
    constructor create(p_channels:cBaseObjInt;p_folder:string; name:string; read:boolean);
    destructor destroy;
    // сохраняем данные всех датчиков в файлы
    procedure SavaSensorsData;
    // читаем данные
    procedure ReadSensorsData;
  end;

const
  c_ChannelsSection = 'Channels';

procedure SaveData(Folder:string;name:string; channels:cBaseObjInt);overload;
procedure SaveData(name:string; channels:cBaseObjInt);overload;

procedure ReadData(Folder:string;name:string; channels:cBaseObjInt);overload;
procedure ReadData(name:string; channels:cBaseObjInt);overload;
function CheckSDTFile(name:string):boolean;

implementation


constructor cFile.create(name:string; read:boolean; p_chan:integer);
begin
  chan:=p_chan;
  AssignFile(f,name);
  if read then
    Reset(f,1)
  else
    Rewrite(f,1);
end;

destructor cFile.destroy;
begin
  closefile(f);
end;

destructor cBladeTicksFile.destroy;
begin
  ReleaseFiles;
  fileList.Destroy;
end;

constructor cBladeTicksFile.create(p_channels:cBaseObjInt;p_folder:string; name:string; read:boolean);
begin
  fileList:=tStringList.Create;
  m_name:=name;
  fileList.Sorted:=true;
  channels:=p_channels;
  folder:=p_folder;
  if folder[length(folder)]<>'\' then
  begin
    folder:=folder+'\';
  end;
  // создаем каталог с замером
  if not DirectoryExists(folder) then
    ForceDirectories(p_folder);
end;

procedure cBladeTicksFile.ReleaseFiles;
var
  I: Integer;
  f:cfile;
begin
  // уничтожаем файлы
  for I := 0 to fileList.Count - 1 do
  begin
    f:=GetFile(i);
    f.destroy;
  end;
  fileList.clear;
end;

procedure cBladeTicksFile.Writefiles;
var
  I, j: Integer;
  chan:cchan;
  f:cfile;
  str, name:string;
begin
  for I := 0 to channels.Count - 1 do
  begin
    chan:=cchan(channels.getobj(i));
    name:=inttostr(chan.chan);
    str:=folder+name+'.dat';
    if (fileexists(str)) or (not read) then
    begin
      f:=getfile(name);
      if f=nil then
      begin
        f:=cfile.create(str, read, chan.chan);
        fileList.AddObject(name,f);
      end;
    end;
  end;
end;

procedure cBladeTicksFile.Readfiles;
var
  I, j: Integer;
  chan:cchan;
  f:cfile;
  str, name:string;
  ini:tinifile;
  sections:tstringlist;
begin
  sections:=tstringlist.Create;
  ini:=tinifile.Create(folder+m_name);
  ini.ReadSection(c_ChannelsSection, sections);
  for I := 0 to sections.Count - 1 do
  begin
    str:=sections.Strings[i];
    j:=ini.ReadInteger(c_ChannelsSection,str,0);
    chan:=cchan(channels.findobj(j));
    if chan=nil then
    begin
      chan:=cchan.create;
      chan.chan:=j;
      channels.addchild(chan.chan,chan);
    end;
    name:=inttostr(chan.chan);
    str:=folder+name+'.dat';
    if (fileexists(str)) or (not read) then
    begin
      f:=getfile(name);
      if f=nil then
      begin
        f:=cfile.create(str, read,chan.chan);
        fileList.AddObject(name,f);
      end;
    end;
  end;
  sections.Destroy;
  ini.Destroy;
end;

procedure cBladeTicksFile.ReadData(name:string;ticks:cbaseticks);
var
  f:cfile;
  I, len, readed: Integer;
  t:stickdata;
begin
  f:=getfile(name);
  len:=trunc(FileSize(f.f)/SizeOf(sTickData));
  ticks.clear;
  if ticks is csortedticks then
  // пишем сразу весь массив данных
  begin
    while len>0 do
    begin
      if len<=csortedticks(ticks).BldMemMng.m_BlockCapacity then
      begin
        blockread(f.f,csortedticks(ticks).BldMemMng.MemArray[csortedticks(ticks).BldMemMng.usedBlocks,0],
                                               len*SizeOf(sTickData),readed);
        for I := 0 to len - 1 do
        begin
          csortedticks(ticks).ticklist.AddObj(@csortedticks(ticks).BldMemMng.MemArray[csortedticks(ticks).BldMemMng.usedBlocks,i]);
        end;
        len:=0;
      end
      else
      begin
        blockread(f.f,csortedticks(ticks).BldMemMng.MemArray[csortedticks(ticks).BldMemMng.usedBlocks,0],
                    csortedticks(ticks).BldMemMng.m_BlockCapacity*SizeOf(sTickData),readed);
        csortedticks(ticks).BldMemMng.allocateblock;
        len:=len-csortedticks(ticks).BldMemMng.m_BlockCapacity;
        for I := 0 to csortedticks(ticks).BldMemMng.m_BlockCapacity - 1 do
        begin
          csortedticks(ticks).ticklist.AddObj(@csortedticks(ticks).BldMemMng.MemArray[csortedticks(ticks).BldMemMng.usedBlocks,i]);
        end;
      end;
    end;
  end;
  // если тики cArrayTicks
  if ticks is cArrayTicks then
    ReadDataToArrayTicks(cArrayTicks(ticks), f);
end;

procedure cBladeTicksFile.ReadDataToArrayTicks(ticks:cArrayTicks; f:cfile);
var
  len, readed: Integer;
  t:stickdata;
begin
  len:=trunc(FileSize(f.f)/SizeOf(sTickData));
  // пишем сразу весь массив данных
  while len>0 do
  begin
    if len<=ticks.BldMemMng.m_BlockCapacity then
    begin
      blockread(f.f,ticks.BldMemMng.MemArray[ticks.BldMemMng.usedBlocks,0],
                                             len*SizeOf(sTickData),readed);
      ticks.BldMemMng.useditems:=len;
      len:=0;
    end
    else
    begin
      blockread(f.f,ticks.BldMemMng.MemArray[ticks.BldMemMng.usedBlocks,0],
                  ticks.BldMemMng.m_BlockCapacity*SizeOf(sTickData),readed);
      inc(ticks.BldMemMng.usedBlocks);
      ticks.BldMemMng.allocateblock;
      len:=len-ticks.BldMemMng.m_BlockCapacity;
      ticks.BldMemMng.useditems:=ticks.BldMemMng.useditems+
                                 ticks.BldMemMng.m_BlockCapacity;
    end;
  end;
end;

procedure cBladeTicksFile.ReadData(chan:cchan);
begin
  ReadData(inttostr(chan.chan), chan.ticks);
end;

procedure cBladeTicksFile.WriteData(chan:cchan);
begin
  WriteData(inttostr(chan.chan),chan.ticks);
end;

procedure cBladeTicksFile.WriteHeader;
var
  iFile:tinifile;
  name:string;
  len:integer;
  I: Integer;
  chan:cchan;
begin
  len:=length(folder);
  if folder[len]='\' then
  begin
    name:=folder;
    setlength(name,len-1);
    name:=extractfilename(name);
  end;
  iFile:=tinifile.Create(folder+name+'.sdt');
  for I := 0 to channels.childCount - 1 do
  begin
    chan:=cchan(channels.getchild(i));
    name:='Chan_'+inttostr(i);
    iFile.WriteInteger(c_ChannelsSection,name,chan.chan);
  end;
  iFile.Destroy;
end;

procedure cBladeTicksFile.WriteData(name:string;ticks:cbaseticks);
var
  I, len: Integer;
  t:stickdata;
  f:cFile;
begin
  if ticks is cSortedTicks then
  // пишем сразу весь массив данных
  begin
    for i := 0 to cSortedTicks(ticks).BldMemMng.usedBlocks do
    begin
      if i<>cSortedTicks(ticks).BldMemMng.usedBlocks then
        len:=cSortedTicks(ticks).BldMemMng.m_BlockCapacity
      else
        len:=cSortedTicks(ticks).BldMemMng.usedItems;
      // пишем данные в файл
      f:=getfile(name);
      if f<>nil then
        BlockWrite(f.f,cSortedTicks(ticks).BldMemMng.MemArray[i,0],sizeof(stickdata)*len);
    end;
  end
  else
  // если память для тиков выделялась одиночными элементами
  begin

  end;
end;

function cBladeTicksFile.getfile(i:integer):cFile;
begin
  result:=cFile(filelist.Objects[i]);
end;

function cBladeTicksFile.getfile(name:string):cFile;
var
  i:integer;
begin
  result:=nil;
  if filelist.find(name,i) then
  begin
    result:=getFile(i);
  end;
end;

procedure cBladeTicksFile.SavaSensorsData;
var
  I: Integer;
  chan:cchan;
begin
  WriteHeader;
  for I := 0 to channels.ChildCount - 1 do
  begin
    chan:=cchan(channels.getchild(i));
    WriteData(chan);
  end;
end;

procedure cBladeTicksFile.ReadSensorsData;
var
  I: Integer;
  chan:cchan;
  f:cfile;
begin
  // создаем файлы для записи данных
  Readfiles;
  for I := 0 to fileList.count - 1 do
  begin
    f:=getfile(i);
    chan:=cchan(channels.findobj(f.chan));
    ReadData(chan);
  end;
end;


procedure SaveData(name:string; channels:cBaseObjInt);
var
  fname,folder:string;
begin
  fname:=extractfilename(name);
  folder:=extractfiledir(name);
  SaveData(Folder,fname,channels);
end;


procedure SaveData(Folder:string;name:string; channels:cBaseObjInt);
var
  f:cBladeTicksFile;
begin
  f:=cBladeTicksFile.create(channels,folder,name, false);
  f.SavaSensorsData;
  f.destroy;
end;

procedure ReadData(name:string; channels:cBaseObjInt);
var
  fname,folder:string;
begin
  fname:=extractfilename(name);
  folder:=extractfiledir(name);
  ReadData(Folder,fname,channels);
end;


procedure ReadData(Folder:string;name:string; channels:cBaseObjInt);
var
  f:cBladeTicksFile;
begin
  f:=cBladeTicksFile.create(channels,folder,name, true);
  f.ReadSensorsData;
  f.destroy;
end;

function CheckSDTFile(name:string):boolean;
var
  i, num:integer;
  f:tinifile;
  slist:tstringlist;
  l_name, folder:string;
begin
  result:=false;
  folder:=ExtractFileDir(name);
  f:=TIniFile.Create(name);
  slist:=tstringlist.Create;
  f.ReadSectionValues(c_ChannelsSection,slist);
  for I := 0 to slist.Count - 1 do
  begin
    num:=f.ReadInteger(c_ChannelsSection,slist.Strings[i],0);
    l_name:=folder+'\'+inttostr(num)+'.dat';
    if not fileexists(l_name) then
    begin
      slist.destroy;
      f.destroy;
      exit;
    end;
  end;
  slist.destroy;
  f.destroy;
  result:=true;
end;


end.
