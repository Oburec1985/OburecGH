// В юните описаны структуры и классы для генерации, загрузки, сохранения
// данных Bld файла
unit uBldFile;

interface
 uses
   Messages, dialogs,controls, ComCtrls, classes, SysUtils,Windows,
   uTickData, uSensor, uBaseObj, ubldeng, ubinfile, uLoadBldForm,
   uVectorlist, uchan, uSetList, uCommonMath, ubldEngEventTypes;

 Type
  sData = record
    mChan:byte;      // номер канала
    mMarker:byte;
    mTicks:sTickData; // Время измерения в тиках - 0.025/1000000
  end;

  psdata = ^sdata;

  // структура содержит информацию для заполнения заголовка Bld файла
  sBldTitle = record
    mTitle:string;        // Cодержит заголовок - строку "RecBld" для bld.
    mTitleSize:LongWord;  // Размер заголовка в байтах
    mCardType:word;       // Cодержит тип платы 2070 или 2081.
    mTestDate:TDateTime;  // Дата испытания
    mSamplingFreq:word;   // Частота дискритизации
    mEmpty:array of char; // Дополнение до 6байт символами ff
    mData:array of byte;  // Данные
  end;

  cDataSet = class(cSetList)
  public
    constructor create;override;
    procedure add(data:sData);
    function getData(i:integer):sData;
  protected
    procedure deleteobj(node:pointer);override;
  end;

  // Клас для чтения/ записи Bld файла
  cBldFile = class
  public
    eng:cbldeng;
    destroysensors, destroychannels:boolean;
  public
    sensors:cBaseObjList;
    channels:cIntVectorList;
    mBldTitle:sBldtitle; // Заголовочная информация bld файла
    mData:array of sData;
    filename:string; // строка имени последнего назначенного файла
    f:File;
  private
    // добавляет тик в один из массивов выделенных для канала
    procedure evalticks(var p_data:sdata);
    // Вычисляет размер заголовка
    procedure evalTitleSize;
    // переписать ссылки на датчики из движка в sensors.
    procedure getLists;
    // подготовить данные для записи
    procedure prepareData;
    procedure DelChanData(sender:tobject);
  public
    constructor Create;
    // убивает экземпляр закрывая файл
    destructor Destroy;
    // Проасециировать с файлом. После этого методы Save и Load могут работать
    procedure GetFile(name:string);
    // Сохранение заполненых полей экземпляра класса в Bld файл
    procedure Save;
    // Загрузка Bld файла в поля класса
    function Load:boolean;
    // Загрузка Bld файла в поля класса
    procedure Clear;// Очистить данные
    // совместить загруженные датчики с конфигурацией eng
    procedure MergeCfg;
    function getsensor(i:integer):csensor;overload;
    function getsensor(name:string):csensor;overload;
    function getchan(i:integer):cchan;
    function GetEngChan(i:integer):cchan;
    function findchan(key:integer):cchan;
  end;

  // загрузить Bld Файл
  function ReadBldData(filename:string;eng:cbldEng):boolean;
  // Сохранить Bld Файл
  procedure WriteBldData(filename:string;eng:cbldEng);

  const pi = 3.14159265;

  // Константы определяющие тип датчика
  const
    c_root = 0;
    c_edge = 1;
    c_rot  = 4;
    c_UTS  = 7;

implementation

function proccomparator(p1,p2:pointer):integer;
begin
  result:=CompareTicks(sdata(p1^).mTicks, sdata(p2^).mTicks);
end;

constructor cDataSet.create;
begin
  inherited;
  comparator:=proccomparator;
end;

procedure cDataSet.add(data:sData);
var pdata:psdata;
begin
  getmem(pdata, sizeof(stickdata));
  pdata^:=data;
  AddObj(pdata);
end;

function cDataSet.getData(i:integer):sData;
begin
  result:=sdata(getnode(i)^);
end;

procedure cDataSet.deleteobj(node:pointer);
begin
  freemem(psdata(node));
end;



// добавить  в конец заголовка bld файла мусорные байты
procedure UpdateTitleSize(var BldFile:cBldFile);
var i,
    division,remainder,add:integer;
    str:string;
begin
  division  := (BldFile.mBldTitle.mTitleSize+4) div 6; //выделяет целую часть
  remainder := (BldFile.mBldTitle.mTitleSize+4) mod 6; //выделяет остаток часть
  if remainder<>0 then add:=6-remainder else add:=0;
  BldFile.mBldTitle.mTitleSize:=BldFile.mBldTitle.mTitleSize + 4 + add;
  SetLength(BldFile.mBldTitle.mEmpty, add + 4);
  for i:= 0 to (add)-1 do
  begin
    BldFile.mBldTitle.mEmpty[i]:='f'
  end;
  for i:=add to (add+4)-1 do
  begin
    str:='DATA';
    BldFile.mBldTitle.mEmpty[i]:=str[i+1 - add];
  end;
end;

procedure cBldFile.DelChanData(sender:tobject);
begin
  if sender is cchan then
    cchan(sender).destroy;
end;

constructor cBldFile.Create;
begin
  filename:='';
  mBldTitle.mTitle:='RecBld';
  sensors:=cbaseobjlist.create;
  sensors.destroydata:=true;
  channels:=cIntVectorList.create;
  channels.fDelData:=DelChanData;
end;


// Удалить BldFile
destructor cBldFile.Destroy;
begin
  clear;
  sensors.destroydata:=destroysensors;
  sensors.destroy;
  channels.destroydata:=destroychannels;
  channels.destroy;
  //if assigned(@f) then
  //  closefile(f);
end;

procedure cBldFile.prepareData;
var
  buf:cdataset;
  chan:cchan;
  I,j: Integer;
  data:sdata;
begin
  buf:=cdataset.create;
  buf.destroydata:=true;
  for I := 0 to eng.ChanCount - 1 do
  begin
    chan:=GetEngChan(i);
    for j := 0 to chan.ticksCount - 1 do
    begin
      data.mTicks:=chan.ticks.gettick(j);
      data.mChan:=chan.chan;
      data.mMarker:=0;
      buf.add(data);
    end;
  end;
  setlength(mdata, buf.Count);
  for I := 0 to buf.Count - 1 do
  begin
    mdata[i]:=buf.getdata(i);
  end;
  buf.destroy;
end;

// Сохранить данные в файл
procedure cBldFile.Save;
    //Записать в файл  паспорт датчика
    procedure WriteSensor(const Sensor:cSensor);
    begin
      // номер канала
      writeword(f,sensor.chanNumber);
      // усиление канала
      writebyte(f,sensor.chan.Amplifier);
      // записать длину имени (1 байт) и имя.
      writeansistring(f, sensor.Name);
      // записать тип датчика
      writeword(f,sensor.sensorType);
    end;
    //Записать в файл заголовка
    procedure WriteTitle(const BldTitle:sBldTitle);
    var lWritten,i:integer;
    begin
     evalTitleSize;
     // Записать заголовок RecBld
     WriteString(f,BldTitle.mTitle);
     // размер заголовка
     WriteCard(f,BldTitle.mTitleSize);
     // тип платы
     writeword(f,BldTitle.mCardType);
     // число каналов
     writeword(f,sensors.count);
     for I := 0 to sensors.count - 1 do
       WriteSensor(getsensor(i));
     BlockWrite(f,BldTitle.mTestDate,8,lWritten);
     writeword(f,BldTitle.mSamplingFreq);
     BlockWrite(f,BldTitle.mEmpty[0],Length(BldTitle.mEmpty),lWritten);
    end;
    // Записать в файл данные
    procedure WriteData(const Data:array of sData);
    var i,Len,lWritten:integer;
    begin
      Len:=Length(Data);
      for I := 0 to len-1 do
      begin
        BlockWrite(f,Data[i].mChan,1,lWritten);
        BlockWrite(f,Data[i].mMarker,1,lWritten);
        BlockWrite(f,Data[i].mTicks,4,lWritten);
      end;
    end;
begin
  // Проверка, что файл существует
  if Assigned(@f) then
  begin
     Rewrite(f,1); // Длина одной записываемой единицы.
     WriteTitle(mBldTitle); // Записать заголовок в файл
     prepareData;
     WriteData(mData); // Записать данные в файл
     CloseFile(f); // Закрыть файл
  end;
end;

// Проасециировать с файлом. После этого методы Save и Load могут работать
procedure cBldFile.GetFile(name:string);
begin
  filename:=name;
  AssignFile(f,name);
end;

// Загрузить Bld файл
function cBldFile.Load:boolean;
  var
    count,lFileSize:integer;
  // вспомогательная процедура для чтения инф-ии канала
  procedure readSensor(var sensor:cSensor);
  var
    nameLen,i:byte;
    Ch:array of char;
    lReaded:cardinal;
    lchan:cchan;
    ind, index:integer;
  begin
    sensor.channumber:=readword(f);
    ind:=sensor.channumber;
    lchan:=cchan(channels.findObj(@ind,index));
    if lchan=nil then
    begin
      lchan:=cchan.create(c_SortedTicks);
      lchan.chan:=sensor.channumber;
      channels.AddObject(@lchan.chan,lchan);
    end;
    lchan.Amplifier:=readbyte(f);
    sensor.Name:=ReadAnsiString(f);
    sensor.sensortype:=readword(f);
  end;
  // прочитать заголовок файла
  procedure ReadTitle(var Title:sBldTitle);
  var
    index,lReaded,i:integer;
    lTitle:array[0..6] of char;
    sensor:csensor;
    CountChun:word;
  begin
    // считать строку заголовка(6),тип платы(2) и число каналов
    Title.mTitle:=readstring(f,6);
    if Title.mTitle<>'RecBld' then exit;
    Title.mTitleSize:=readcard(f);
    Title.mCardType:=readword(f);
    CountChun:=readword(f);
    for i:=0 to CountChun-1 do
    begin
      sensor:=cSensor.Create;
      readSensor(sensor);
      sensors.addobj(sensor);
    end;
    BlockRead(f,Title.mTestDate,8,lReaded);
    Title.mSamplingFreq:=readword(f);
    SetLength(Title.mEmpty,Title.mTitleSize-FilePos(f));
    BlockRead(f,Title.mEmpty[0],Title.mTitleSize-FilePos(f),lReaded);
  end;
  procedure ReadData(len:integer);
  var
    i,lReaded:integer;
    Dat:sData;
  begin
    for I := 0 to len-1 do
    begin
      BlockRead(f,dat.mChan,1,lReaded);
      BlockRead(f,dat.mMarker,1,lReaded);
      BlockRead(f,dat.mTicks.Data,4,lReaded);
      evalticks(dat);
    end;
  end;
begin
  if fileexists(filename) then
  begin
    // Проверка, что файл существует
    if Assigned(@f) then
    begin
      Reset(F,1); // Определить длину читаемой записи в байтах
      // считать заголовок
      ReadTitle(mBldTitle);
      // Чтение данных
      Seek(f,mBldTitle.mTitleSize); // Переместить курсор на начало записи данных
      lFileSize:=FileSize(f);       // Определить размер файла в байтах
      count:=trunc((lFileSize-mBldTitle.mTitleSize)/6);
      // считать count блоков
      ReadData(count);
      // Закрыть файл
      CloseFile(f);
    end;
  end;
end;

procedure cBldFile.Clear;
begin
  setlength(mBldTitle.mEmpty,0);
  setlength(mData,0);
  mBldTitle.mEmpty:=nil;
  mData:=nil;
end;

procedure cBldFile.MergeCfg;
var
  i:integer;
  sensor:csensor;
begin
  for I := 0 to sensors.count - 1 do
  begin
    sensor:=csensor(sensors.getobj(i));
    if True then

  end;
end;

function cBldFile.getsensor(i:integer):csensor;
begin
  result:=csensor(sensors.getobj(i));
end;

function cBldFile.getsensor(name:string):csensor;
begin
  result:=csensor(sensors.getobj(name));
end;

function cBldFile.getchan(i:integer):cchan;
begin
  result:=cchan(channels.getObj(i));
end;

function cBldFile.GetEngChan(i:integer):cchan;
begin
  result:=cchan(eng.getchan(i));
end;

function cBldFile.findchan(key:integer):cchan;
var index:integer;
begin
  result:=cchan(channels.findObj(@key,index));
end;

procedure cBldFile.evalticks(var p_data:sdata);
var
  i,overflow,tickcount:integer;
  chan:cchan;
  prevtick, tick:stickdata;
begin
  chan:=findchan(p_data.mChan);
  if chan=nil then
  begin
    chan:=cchan.create(c_SortedTicks);
    chan.Amplifier:=p_data.mMarker;
    chan.chan:=p_data.mChan;
    channels.AddObject(@chan.chan,chan);
  end;
  tick.data:=p_data.mTicks.Data;
  tickcount:=chan.ticksCount;
  if tickcount>0 then
  begin
    prevtick:=chan.ticks.gettick(tickcount-1);
    if tick.Data<prevtick.data then
    begin
      tick.overflowcount:=prevtick.OverflowCount+1;
    end
    else
      tick.OverflowCount:=prevtick.OverflowCount;
  end
  else
  begin
    tick.OverflowCount:=0;
  end;

  chan.ticks.Add(tick);
end;

procedure cBldFile.evalTitleSize;
var
  i,size:integer;
  sensor:csensor;
begin
  // Количество байт, которое займет паспорт в файле
  // 24 =6(RecBld) + 4(размер заголовка)TitleSize + 2(тип платы) + 2(число каналов)
  // + 8(время и дата испытания)+2(freq)
  mBldTitle.mTitleSize:=24;
  size:=0;
  for I := 0 to sensors.count - 1 do
  begin
    sensor:=getsensor(i);
    // 6=2(номер канала)+1(усиление)+1(длина имени)+2(тип датчика)
    size:=Length(sensor.Name)+size+6;
  end;
  mBldTitle.mTitleSize:=mBldTitle.mTitleSize+size;
  // добавляем мусорные байты в конец загоовка
  UpdateTitleSize(self);
end;

function addproc(obj:cbaseobj; data:pointer):boolean;
begin
  result:=true;
  cbaseobjlist(data).addobj(obj);
end;

procedure cBldFile.getLists;
begin
  eng.EnumSensors(addproc, sensors);
  // переписываем данные в общий массив

end;

function ReadBldData(filename:string;eng:cbldEng):boolean;
var
  f:cBldFile;
  createNewFrm:boolean;
  lloadBldDlg:tloadBldDlg;
  showblddlg:boolean;
begin
  result:=false;
  if fileexists(filename) then
  begin
    f:=cBldFile.Create;
    f.GetFile(filename);
    f.eng:=eng;
    f.Load;
    createNewFrm:=false;
    if loadBlddlg=nil then
    begin
      lloadBldDlg:=TLoadBldDlg.Create(nil);
      createNewFrm:=true;
    end
    else
      lloadBldDlg:=loadBlddlg;
    showblddlg:=not checkflag(eng.flags,c_EngLoading);
    if lloadBlddlg.showmodal(f,showblddlg)=mrok then
    begin
      result:=true;
    end;
    f.Destroy;
    if createNewFrm then
      lloadBldDlg.Destroy;
    eng.Events.CallAllEvents(E_OnEngLoadData);
  end
  else
    showmessage('файл '+filename+' не найден');
end;

procedure WriteBldData(filename:string;eng:cbldEng);
var f:cBldFile;
begin
  f:=cBldFile.Create;
  f.GetFile(filename);
  f.eng:=eng;
  // перенести список датчиков из двига в файл
  f.getLists;
  f.save;
  f.Destroy;
end;

end.
