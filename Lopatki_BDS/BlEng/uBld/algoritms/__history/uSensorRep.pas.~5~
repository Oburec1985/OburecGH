unit uSensorRep;

interface
uses
  classes, sysutils,Graphics,  controls, stdctrls,
  uBldMath, uCommonMath, uErrorProc, uBldObj, uTickdata, usensor, uProgressDlg,
  ubldeng, uBaseBldAlg, ustage, uBaseObj, RepODS, uturbina, PathUtils,
  usensorlist;

type
  cRepOpts = class(cbaseopts)
    repname:tstrings;
    prec:integer;
    singlefile:boolean;
  public
    constructor create;override;
  end;

  cSensorRepAlg = class(cBaseBldAlg)
  protected
    singlefile:boolean;
    repname:tstrings;
    // точность с которой выводятся в отчет флоты
    floatPrec:integer;
    // номер строки в отчете
    rowArray:array of integer;
    // индекс заполняемой строки в отчете
    RowCounter:integer;
    // класс отчета
    rep: TRepODS;
    // массив индексов строк которые будут повторяться в отчете
    rows: TIntArray;
    eng:cbldeng;
    // прогресс завершения отчета
    progress:integer;
    // число строк в отчете
    rowcount:integer;
    PrBar:TProgresDlg;
  protected
    // вызывается для каждого корректного оборота CommonSensorProc
    // при этом индекс оборота, начало и конец оборота, храняться в protected
    // мемберах
    function TurnSensorProc(s:csensor):integer;override;
    function BeforeTurnSensorProc:boolean;override;
    function BadTicksProc(s:csensor;i:integer):integer;override;
    procedure CommonSensorProc(taho:csensor;sensors:cAlgSensorList);override;
    // обработка ошибок. если возникает ошибка возвращает false
    function ProcessErrors(taho:csensor; sensors:cAlgSensorList):boolean;override;
    // заполнить шапку в отчете
    procedure GenHeader(s:csensor);
    procedure SetRowColor(row:integer; color:tcolor);
    // добавить строчку в отчет, j - индекс импульса датчика
    procedure AddRepStr(s:csensor;j:integer);
  public
    procedure getOpts(opts:cBaseOpts);override;
  end;

  procedure GenerateReportName(cb:tcombobox; singlefile:boolean; sensors:calgsensorlist; eng:cbldeng);
  procedure GenerateReport(taho:csensor; sensors:cAlgSensorList; data:pointer);

  const

    c_yellow = $00AFE9F3;
    c_green = clLime;
    c_red = clRed;

implementation
uses
  uSensorRepForm;

const
  defaultPrec = 5;
  startRow = 9;
  // отступ, число колонок
  tab = 0;
  // номер строки в отчете
  c_Number = 0;
  c_TickIndex =c_Number+1;
  // Время импульса датчика в тиках
  c_T = c_TickIndex + 1;
  // Время импульса датчика в секундах
  c_TSec = c_T+1;
  // номер лопатки
  c_Blade = c_TSec+1;
  // положение импульса в обороте, градусы
  c_Pos0 = c_Blade+1;
  // априорное положение импульса в обороте, градусы
  c_dPath = c_Pos0+1;
  // отклонение в градусах
  c_Pos = c_dPath+1;
  // Проденный путь (расчетный)
  c_dPos = c_Pos+1;
  // номер оборота
  c_Turn = c_dPos+1;
  // Начало оборота, тики
  c_T1 = c_Turn+1;
  // Конец оборота, тики
  c_T2 = c_T1+1;
  // Начало оборота, сек
  c_T1sec = c_T2+1;
  // Конец оборота, сек
  c_T2sec = c_T1sec+1;
  // Время оборота в тиках
  c_dT = c_T2sec+1;
  // Время оборота в секундах
  c_dTsec = c_dT+1;
  // Частота оборотов, Гц
  c_Freq = c_dTsec+1;

constructor cRepOpts.create;
begin
  inherited;
  singlefile:=true;
  callBadTicksProc:=true;
end;


function cSensorRepAlg.TurnSensorProc(s:csensor):integer;
var
  j:integer;
begin
  // Подсчитываем число импульсов укладывающихся в каждый столбец гистограммы
  result:=0;
  //DecimalSeparator:='.';
  // ограничиваем число строк в отчете до ста
  for j:=sensorind to (sensorind+BladeCount - 1) do
  begin
    if j=sensorind then
      setflag(turnflags,c_NewTurn);
    AddRepStr(s,j);
    progress:=trunc((RowCounter/rowCount)*100);
    if (not PrBar.UpdateProgress(progress,'Число строк: '+inttostr(RowCounter))) or (progress=100) then
    begin
      result:=2;
      exit;
    end;
  end;
  //DecimalSeparator:=',';
end;

procedure cSensorRepAlg.AddRepStr(s:csensor;j:integer);
var
  t:stickdata;
  dTurnsec:single;
  rowind, blade, dturn:integer;
  // индекс строки в кластере
  row:integer;
begin
  EvalTurnCluster(s,j);
  // добавить номер строки
  rowind:=startRow+rowArray[CurSensorInd];
  row:=rowArray[CurSensorInd];
  rep.Clusters.items[CurSensorInd].InsertNumber( row, rowind, c_Number+tab);
  rep.Clusters.items[CurSensorInd].InsertNumber( j, rowind, c_TickIndex+tab);
  t:=s.chan.ticks.gettick(j);
  // добавить время импульса в тиках
  rep.Clusters.items[CurSensorInd].InsertString(TickToStr(t), rowind, c_T+tab);
  // добавить время импульса в секундах
  //rep.Clusters.items[CurSensorInd].InsertNumber(RoundSignificant(TickToSec(t),floatprec),rowind, c_Tsec+tab);
  rep.Clusters.items[CurSensorInd].InsertNumber(turnCluster.p2.x,rowind, c_Tsec+tab);
  // добавить номер лопатки
  rep.Clusters.items[CurSensorInd].InsertNumber(turnCluster.blade,rowind, c_Blade+tab);
  // добавить положение импульса в обороте
  rep.Clusters.items[CurSensorInd].InsertNumber(turnCluster.p,rowind, c_Pos+tab);
  // добавить априорное положение импульса в обороте
  rep.Clusters.items[CurSensorInd].InsertNumber(turnCluster.p0,rowind, c_Pos0+tab);
  // добавить проденный путь
  rep.Clusters.items[CurSensorInd].InsertNumber(turncluster.path, rowind, c_dPath + tab);
  // Добавить отклонение от расчетного пути
  rep.Clusters.items[CurSensorInd].InsertNumber(turncluster.p2.y, rowind, c_dPos + tab);
  // добавить номер оборота
  rep.Clusters.items[CurSensorInd].InsertNumber(turnind, rowind, c_Turn+tab);
  // Начало оборота, тики
  rep.Clusters.items[CurSensorInd].InsertString(TickToStr(t1), rowind, c_T1+tab);
  // Конец оборота, тики
  rep.Clusters.items[CurSensorInd].InsertString(TickToStr(t2), rowind, c_T2+tab);
  // Начало оборота, сек
  rep.Clusters.items[CurSensorInd].InsertNumber(Ticktosec(t1),rowind, c_T1sec+tab);
  // Конец оборота, сек
  rep.Clusters.items[CurSensorInd].InsertNumber(Ticktosec(t2),rowind, c_T2sec+tab);
  // Время оборота в тиках
  dturn:=getdturn;
  rep.Clusters.items[CurSensorInd].InsertNumber(dturn, rowind, c_dT+tab);
  // Время оборота в секундах
  dTurnsec:=ticktosec(dturn);
  rep.Clusters.items[CurSensorInd].InsertNumber(dTurnsec, rowind, c_dTsec+tab);
  // Частота оборотов, Гц
  rep.Clusters.items[CurSensorInd].InsertNumber(1/dTurnsec, rowind, c_freq+tab);
  if checkflag(turnflags,c_NewTurn) then
  begin
    setRowColor(rowind,c_Yellow);
    dropflag(turnflags,c_NewTurn);
  end
  else
  begin
    if checkflag(turnflags,c_drop) then
    begin
      setRowColor(rowind,c_Red);
    end
  end;
  inc(rowArray[CurSensorInd]);
  inc(rowCounter);
end;

function cSensorRepAlg.BadTicksProc(s:csensor;i:integer):integer;
var
  count,j:integer;
begin
  // Подсчитываем число импульсов укладывающихся в каждый столбец гистограммы
  result:=0;
  count:=TickCountInTurn(t1,t2,s.chan.ticks);
  //DecimalSeparator:='.';
  // ограничиваем число строк в отчете до ста
  for j:=i to (lastSensorInd) do
  begin
    if j=sensorind then
      setflag(turnflags,c_NewTurn);
    AddRepStr(s,j);
    progress:=trunc((RowCounter/rowCount)*100);
    if (not PrBar.UpdateProgress(progress,'Число строк: '+
        inttostr(RowCounter)))
        or (progress=100)
    then
    begin
      result:=2;
      exit;
    end;
  end;
end;

procedure cSensorRepAlg.SetRowColor(row:integer; color:tcolor);
var
  i:integer;
  colorBGR:integer;
  str:string;
begin
  colorBGR:=RGBtoBGR(color);
  str:='#'+inttohex(colorBGR,6);
  for i := Tab + c_Number to C_Freq+tab do
  begin
    rep.Clusters.Items[CurSensorInd].CellColor(row, i, str);
  end;
end;
// вызывается если оборот сбойный
function cSensorRepAlg.BeforeTurnSensorProc:boolean;
begin

end;

procedure cSensorRepAlg.getOpts(opts:cBaseOpts);
begin
  inherited;
  floatprec:=cRepOpts(opts).prec;
  repname:=cRepOpts(opts).repname;
  singlefile:=cRepOpts(opts).singlefile;
end;

procedure cSensorRepAlg.CommonSensorProc(taho:csensor;sensors:cAlgSensorList);
var
  // имя шаблона отчета
  TmplRepName,
  // имя отчета
  RepPath:string;
  i,j:integer;
begin
  PrBar:=TProgresDlg.Create(nil);
  PrBar.showProgress('Формирование отчета');
  eng:=taho.eng;
  TmplRepName:=relativepathtoabsolute(eng.PathMng.findRepPathFile('SensorRep.ods'));
  // если файла шаблона нет
  if not (fileexists(TmplRepName)) then exit;
    repPath:=repname[0];
  // массив счетчиков номера строки в кластерах
  setlength(rowArray,sensors.Count);
  for j := 0  to sensors.Count-1 do
    rowArray[j]:=0;
  // заполняем список используемых строк в отчете
  setlength(rows,10);
  for j := 0  to 9 do
    rows[j]:=j;
  for I := 0 to sensors.Count - 1 do
  begin
    if not singlefile then
      repPath:=repname[i]
    else
      if i>0 then break;
    rep:=TRepODS.Create(TmplRepName,RepPath);
    rep.Open('Лист1');
    rep.MakeCluster(rows);
    if singlefile and (sensors.Count>1) then
    begin
      rep.AddClusters(sensors.Count-1,0);
    end;
    // заполняем шапки отчета
    if singlefile then
    begin
      for j := 0 to sensors.Count - 1 do
      begin
        GenHeader(sensors.GetSensor(j));
      end;
    end
    else
      GenHeader(sensors.GetSensor(i));
    inherited;
    for j := 0 to sensors.Count - 1 do
    begin
      rep.Clusters.Items[j].FindAndReplace('<Отбраковано оборотов>', inttostr(curtaho.tickscount-1 - sstruct[j].validturns));
    end;
    rep.Close;
    rep.ExecRep;
    rep.destroy;
  end;
  PrBar.destroy;
end;

procedure GenerateReportName(cb:tcombobox; singlefile:boolean; sensors:calgsensorlist; eng:cbldeng);
var
  pathlist:tstringlist;
  I: Integer;
  str:string;
begin
  cb.Clear;
  eng.PathMng.MakeCurrentStartAppDir;
  pathlist:=eng.PathMng.getReplist;
  if singlefile then
  begin
    for I := 0 to sensors.Count - 1 do
    begin
      str:=relativepathtoabsolute(pathlist.Strings[0]+sensors.GetSensor(i).name+'.ods');
      cb.Items.Add(str);
    end;
  end
  else
  begin
    str:='';
    for I := 0 to sensors.Count - 1 do
    begin
      str:=str+sensors.GetSensor(i).name+'_';
      str:=relativepathtoabsolute(pathlist.Strings[0]+str+'.ods');
      cb.Items.Add(str);
    end;
  end;
  if cb.Items.Count>0 then
    cb.ItemIndex:=0;
end;

procedure cSensorRepAlg.GenHeader(s:csensor);
var
  str:string;
  obj:cbldobj;
  i:integer;
begin
  i:=sensorsList.GetIndex(s);
  rep.Clusters.Items[i].FindAndReplace('<Имя датчика>',s.name);
  // получить ссылку на турбину
  obj:=s.getTurbine;
  // заполняем данные о турбине
  if obj<>nil then
  begin
    rep.Clusters.Items[i].FindAndReplace('<Имя обработанного файла>',eng.lastfile);
    rep.Clusters.Items[i].FindAndReplace('<Имя турбины>',cturbine(obj).name);
    rep.Clusters.Items[i].FindAndReplace('<Число ступеней>',inttostr(cturbine(obj).StageCount));
  end
  else
  begin
    rep.Clusters.Items[i].FindAndReplace('<Имя обработанного файла>','');
    rep.Clusters.Items[i].FindAndReplace('<Имя турбины>','');
    rep.Clusters.Items[i].FindAndReplace('<Число ступеней>','');
  end;
  // заполняем данные о ступени
  obj:=s.stage;
  // заполняем данные о турбине
  if obj<>nil then
  begin
    rep.Clusters.Items[i].FindAndReplace('<Имя ступени>',cstage(obj).name);
    rep.Clusters.Items[i].FindAndReplace('<Число лопаток>',inttostr(cstage(obj).BladeCount));
    rep.Clusters.Items[i].FindAndReplace('<Диаметр ступени>',floattostr(cstage(obj).diametr));
  end
  else
  begin
    rep.Clusters.Items[i].FindAndReplace('<Имя ступени>','');
    rep.Clusters.Items[i].FindAndReplace('<Число лопаток>','');
    rep.Clusters.Items[i].FindAndReplace('<Диаметр ступени>','');
  end;
  // заполняем данные о таходатчике
  rep.Clusters.Items[i].FindAndReplace('<Имя тахо датчика>',curtaho.name);
  rep.Clusters.Items[i].FindAndReplace('<Число тиков тахо>',inttostr(curtaho.tickscount));
  rep.Clusters.Items[i].FindAndReplace('<Положение тахо датчика>',floattostr(curtaho.pos));
  // заполняем данные о датчике
  rep.Clusters.Items[i].FindAndReplace('<Имя датчика>',s.name);
  rep.Clusters.Items[i].FindAndReplace('<Число тиков>',inttostr(s.tickscount));
  rep.Clusters.Items[i].FindAndReplace('<Положение датчика>',floattostr(s.pos));
  // заполняем данные о датчике
  rep.Clusters.Items[i].FindAndReplace('<Всего оборотов>',inttostr(curtaho.tickscount-1));
  rep.Clusters.Items[i].FindAndReplace('<Положение датчика>',floattostr(s.pos));
  rowCount:=rowcount+s.tickscount;
  // вставляем в отчет строки для заполнения информации об оборотах
  rep.Clusters.Items[i].InsertRows(startRow, s.tickscount);
end;

procedure GenerateReport(taho:csensor; sensors:cAlgSensorList; data:pointer);
var
  rep: cSensorRepAlg;
  RepForm: TSensorRepForm;
  opts:crepopts;
begin
  opts:=cRepOpts.Create;
  opts.useBladesPos:=true;
  opts.prec:=defaultprec;
  opts.callBadTicksProc:=true;
  opts.eng:=taho.eng;
  Repform:=TSensorRepForm.Create(nil);
  if Repform.ShowModal(taho,sensors,opts)=mrok then
  begin
    rep:=cSensorRepAlg.create;
    rep.apply(taho,sensors,opts);
    rep.Destroy;
  end;
  Repform.Destroy;
  opts.Destroy;
end;

function cSensorRepAlg.ProcessErrors(taho:csensor;sensors:cAlgsensorList):boolean;
var
  l:integer;
  sensor:csensor;
begin
  if inherited ProcessErrors(taho,sensors)=false then
  begin
    result:=false;
    exit;
  end;
  result:=ProcClusterError(taho,sensors);
end;



end.
