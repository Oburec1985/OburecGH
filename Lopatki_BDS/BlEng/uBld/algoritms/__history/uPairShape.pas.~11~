// при выполнении данного алгоритма нельзя задавать пропуск между датчиками пары, он
// считается автоматом по положению датчиков. В результате исключена ситуация когда будет
// замерено расстояние между разными лопатками
unit uPairShape;

interface
uses
  classes, sysutils,Graphics,  controls, stdctrls, uchart, uaxis,
  uBldMath, uCommonMath, uErrorProc, uBldObj, uTickdata, usensor, uProgressDlg,
  ubldeng, uBaseBldAlg, ustage, uBaseObj, RepODS, uturbina, PathUtils,
  usensorlist, uCommonTypes, uGistogram, uBldTypes, upair, uTag;

type
  sArray = array of single;
  // для корректного выполнения алгоритма для датчиков должны быть определены пропуски лопаток
  // чтоб правильно определить где 0-я лопатка и работала функция correctBlade
  cPairShapeOpts = class(cbaseopts)
    n, // размер порции
    skipblade // пропустить лопаток
    :integer;
    chart:cchart;
    pair:cpair;
  public
    constructor create;override;
  end;
  // алгоритм восстанавливает сигнал вибрации по всему колесу
  cPairShape = class(cBaseBldAlg)
  protected
    pair:cpair;
    skipblade,
    // размер следа
    n:integer;
    gistItem:cGistogramItem;
    // хранит растояния между датчиками пары посчитанное на обороте
    // каждые n значений происходит расчет дисперсии
    ResArray:array of single;
    // хранит min и max между датчиками пары посFчитанное на обороте
    // за n оборотов
    MinMaxArray:array of point2;
    // хранит растояния между датчиками пары посчитанное на обороте
    // каждые n значений происходит расчет дисперсии в ResArray
    BufArray: array of sArray;
    DArray:cVectorTag;
    MArray:cVectorTag;
    MinMaxDArray:c2VectorTag;
    MinMaxMArray:c2VectorTag;
  protected
    // вызывается для каждого корректного оборота CommonSensorProc
    // при этом индекс оборота, начало и конец оборота, храняться в protected
    // мемберах
    function gist:cgistogram;
    function TurnSensorProc(s:csensor):integer;override;
    procedure CommonSensorProc(taho:csensor;sensors:cAlgSensorList);override;
    // обработка ошибок. если возникает ошибка возвращает false
    function ProcessErrors(taho:csensor; sensors:cAlgSensorList):boolean;override;
    // выделение памяти для расчета алгоритма
    procedure PrepareBuffers;
    // расчитать дисперсию для i-й лопатки
    function evalDisperse(i:integer):single;
    // расчитать матожидание для i-й лопатки
    function EvalM(i:integer):single;
    procedure updateMinMax(blade:integer; v:single);
    function CorrectBlade(i:integer):boolean;
    procedure setopts(opts:cbaseopts);override;
    procedure InitOpts;override;
    procedure createTags;override;
  public
    procedure getOpts(opts:cBaseOpts);override;
    function CreateOpts:cbaseopts;override;
    function AlgID:integer;override;
  end;

  procedure BuildPairShape(taho:csensor; sensors:cAlgSensorList; data:pointer);
  function PreparePairShape(taho:csensor; sensors:cAlgSensorList; data:pointer):cbasebldalg;

implementation
uses
  uPairShapeForm, umarkers;


constructor cPairShapeOpts.create;
begin
  inherited;
  skipblade:=0;
  callBadTicksProc:=false;
end;

function getGistogram(c:cchart):cGistogram;
var
  i:integer;
  obj:cbaseobj;
  axis:caxis;
begin
  axis:=c.activepage.activeAxis;
  axis.destroychildrens;
  for I := 0 to Axis.ChildCount - 1 do
  begin
    obj:=axis.getChild(i);
    if obj is cgistogram then
    begin
      result:=cgistogram(obj);
      exit;
    end;
  end;
  result:=axis.AddGistogram;
end;

function cPairShape.TurnSensorProc(s:csensor):integer;
var
  i:integer;
  v:single;
begin
  // Подсчитываем число импульсов укладывающихся в каждый столбец гистограммы
  result:=0;
  if validturn<n then
  begin
    for I := sensorind to sensorind + stage.BladeCount - 1 do
    begin
      EvalTurnCluster(s,i);
      if CurSensorInd=0 then
        BufArray[validturn][turnCluster.blade]:=turnCluster.p
      else
      begin
        v:=abs(turnCluster.p - BufArray[validturn][turnCluster.blade]);
        if CorrectBlade(turnCluster.blade) then
          v:=360-v;
        BufArray[validturn][turnCluster.blade]:=v;
      end;
    end;
  end;
end;

procedure cPairShape.PrepareBuffers;
var
  i:integer;
begin
  setlength(MinMaxArray,stage.BladeCount);
  for I := 0 to stage.BladeCount - 1 do
  begin
    MinMaxArray[i]:=p2(-1,-1);
  end;
  setlength(ResArray,0);
  setlength(ResArray,stage.BladeCount);
  setlength(bufArray,n);
  for I := 0 to n - 1 do
  begin
    setlength(bufarray[i],stage.BladeCount);
  end;
  if gist<>nil then
    gist.clear;
end;

procedure cPairShape.CommonSensorProc(taho:csensor;sensors:cAlgSensorList);
var
  i:integer;
  p:single;
  m:cmarkerlist;
begin
  PrepareBuffers;
  inherited;
  for I := 0 to stage.BladeCount - 1 do
  begin
    ResArray[i]:=evalDisperse(i);
  end;
  m:=gist.getMarkers;
  for I := 0 to stage.BladeCount - 1 do
  begin
    p:=GetBladePos(i);
    gist.addValue(p,ResArray[i]);
    // добавляем маркер minVal к лопатке
    m.AddMarker(p2(p,MinMaxArray[i].x));
    // добавляем маркер maxVal к лопатке
    m.AddMarker(p2(p,MinMaxArray[i].y));
  end;
end;


function cPairShape.ProcessErrors(taho:csensor;sensors:cAlgsensorList):boolean;
var
  l:integer;
  sensor:csensor;
begin
  if inherited ProcessErrors(taho,sensors)=false then
  begin
    result:=false;
    exit;
  end;
  result:=ProcClusterError(taho,sensors);
end;

// расчитать матожидание для i-й лопатки
function cPairShape.EvalM(i:integer):single;
var
  j:integer;
begin
  result:=0;
  for j := 0 to n-1 do
  begin
    result:=result+bufarray[j][i];
  end;
  result:=result/n;
end;

function cPairShape.evalDisperse(i:integer):single;
var
  j:integer;
  s:single;
begin
  result:=0;
  for j := 0 to n - 1 do
  begin
    if EvalDisp then
    begin
      s:=(evalM(i) - bufarray[j][i]);
      s:=abs(s);
    end
    else
    begin
      s:=bufarray[j][i];
    end;
    result:=result+s;
    updateMinMax(i,s);
  end;
  result:=result/n;
end;

procedure BuildPairShape(taho:csensor; sensors:cAlgSensorList; data:pointer);
var
  alg: cPairShape;
  PairShapeForm: TPairShapeForm;
  opts:cPairShapeOpts;
  slist:cAlgSensorList;
  i:integer;
  p:cpair;
begin
  slist:=cAlgSensorList.create;
  slist.destroydata:=false;
  // выделямс пару
  p:=cpair(sensors.GetObj(0));
  for I := 0 to p.sensors.Count - 1 do
  begin
    slist.add(csensor(p.sensors.getobj(i)));
  end;
  // опции алгоритма
  opts:=cPairShapeOpts.Create;
  opts.chart:=cchart(data);
  opts.useBladesPos:=true;
  PairShapeForm:=TPairShapeForm.Create(nil);
  if PairShapeForm.ShowModal(taho,slist,opts)=mrok then
  begin
    alg:=cPairShape.create;
    alg.apply(taho,slist,opts);
    alg.Destroy;
  end;
  PairShapeForm.Destroy;
  opts.Destroy;
  slist.destroy;
end;

function PreparePairShape(taho:csensor; sensors:cAlgSensorList; data:pointer):cbasebldalg;
var
  alg: cPairShape;
  PairShapeForm: TPairShapeForm;
  opts:cPairShapeOpts;
  slist:cAlgSensorList;
  i:integer;
  p:cpair;
begin
  slist:=cAlgSensorList.create;
  slist.destroydata:=false;
  // выделямс пару
  p:=cpair(sensors.GetObj(0));
  for I := 0 to p.sensors.Count - 1 do
  begin
    slist.add(csensor(p.sensors.getobj(i)));
  end;
  // опции алгоритма
  opts:=cPairShapeOpts.Create;
  opts.chart:=cchart(data);
  opts.useBladesPos:=true;
  alg:=cPairShape.create;
  alg.n:=opts.n;
  alg.skipblade:=opts.skipblade;
  //alg.apply(taho,slist,opts);
  result:=alg;
end;

procedure cPairShape.updateMinMax(blade:integer; v:single);
begin
  // запоминаем min/ max
  if (MinMaxArray[blade].x>v) or
     (MinMaxArray[blade].x=-1) then
  begin
    MinMaxArray[blade].x:=v;
  end
  else
  begin
    if MinMaxArray[blade].y<v then
      MinMaxArray[blade].y:=v;
  end;
end;

function cPairShape.CorrectBlade(i:integer):boolean;
var
  s1,s2:csensor;
begin
  s1:=sensorsList.GetSensor(0);
  s2:=sensorsList.GetSensor(1);
  result:=(s1.skipBlade<i) <> (s2.skipBlade<i);
end;

procedure  cPairShape.getopts(opts:cbaseopts);
begin
  inherited;
  skipblade:=cPairShapeOpts(opts).skipblade;
  n:=cpairshapeopts(opts).n;
  EvalDisp:=not cpairshapeopts(opts).ShowOffset;
  if drawobj=nil then
    drawobj:=getGistogram(cPairShapeOpts(opts).chart);
  gist.width:=180/stage.BladeCount;
end;

procedure cPairShape.setopts(opts:cbaseopts);
begin
  inherited setopts(opts);
  cpairshapeopts(opts).skipblade:=skipblade;
  cpairshapeopts(opts).n:=n;
  cpairshapeopts(opts).ShowOffset:=not EvalDisp;
end;

function cPairShape.CreateOpts:cbaseopts;
begin
  result:=cpairshapeopts.create;
  setopts(result);
end;

function cPairShape.gist:cgistogram;
begin
  result:=cgistogram(drawobj);
end;

function cPairShape.AlgID:integer;
begin
  result:=c_pairShape
end;

procedure cPairShape.InitOpts;
begin
  inherited;
  LinkedSensors:=true;
end;

procedure cPairShape.createTags;
var
  tag:cBaseTag;
  i:integer;
begin
  if Darray=nil then
  begin
    DArray:=cVectorTag.create;
    DArray.name:='DArray';
    DArray.dsc:='Последовательность дисперсий разброса положения лопаток';

    MArray:=cVectorTag.create;
    MArray.name:='MArray';
    MArray.dsc:='Последовательность мат ожидания разброса положения лопаток';

    MinMaxDArray:=c2VectorTag.create;
    MinMaxDArray.name:='MinMaxDArray';
    MinMaxDArray.dsc:='Последовательность максимумов и минимумов дисперсий по лопаткам';

    MinMaxMArray:=c2VectorTag.create;
    MinMaxMArray.name:='MinMaxMArray';
    MinMaxMArray.dsc:='Последовательность максимумов и минимумов мат ожидания по лопаткам';

    for i := 0 to tags.Count - 1 do
    begin
      tag:=cBaseTag(tags.getobj(i));
      // запрещаем удалять объект менеджеру тегов, т.к. теги
      // создаются и удаляются алгоритмом
      tag.blocked:=true;
      tag.active:=false;
    end;

    tags.addobj(DArray);
    tags.addobj(MArray);
    tags.addobj(MinMaxDArray);
    tags.addobj(MinMaxMArray);
  end;
end;

end.
