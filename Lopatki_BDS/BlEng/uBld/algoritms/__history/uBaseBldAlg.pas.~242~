unit uBaseBldAlg;

interface
uses
  uBldMath, uCommonMath, uErrorProc, uBldObj, uTickdata, usensor, uchart,types, sysutils,
  uGistogram, uTrend, ubldeng, ustage, ubldtypes, uSensorList, uCommonTypes, dialogs,
  udrawobj, uTag, classes, ueventlist, uBaseObj, NativeXml, uMyMath,
  MathFunction, uMeraFile, utagsignal, uUtsSensor, uTagOwnerObj;


type
  sTurnCluster = record
    // положение импульса в обороте
    p,
    // априорное положение импульса в обороте
    p0,
    // априорный путь который должна пройти лопатка
    path:single;
    // номер лопатки от которой пришел импульс
    blade,
    // индекс импульса в массиве тиков
    i:integer;
    // время импульса в тиках
    t:stickdata;
    // время и отклонение лопатки от априорного положения
    p2:point2;
  end;

  AdjustSensorStruct = record
    interrupt:boolean;
    // предыдущее смещение
    prevOffset:single;
    // хранит число корректных оборотов для каждого из обработанных объектов
    validturns,
    dropedturn:integer;
    // отбраковано 0..1
    droped:single;
    // расстояние между первой и последней лопаткой
    // априорное положение последней лопатки.
    FirstEndDist,
    EndPos:single;
    // пересчитанный по форме колеса
    // набор расстояний до датчика, где 0-й элемент расстояние до первого импульса
    // 1-й до второго
    offsets:array of single;
    // массив индексов первых импульсов в корректных оборотах. если первый оборот сбойный
    // то нулевой элемент - первый импульс на датчике во втором обороте.
    // Заполняется если алгоритм двухпроходный
    // Хранит индексы импульсов с которых начинаются корректные обороты
    sensorind:array of integer;
  end;

  cBaseOpts = class
    // частота дискретизации (<0 если сигнал x/y)
    SampleRate,
    // размер порции при записи 3d
    portionSize,
    dZ
    :integer;
    // сохранять сигнал
    SaveSignals,
    // показывать форму настройки перед сохранением замера
    showSaveDlg,
    // щаписать 3d
    b_3D:boolean;
    // путь к сохраняемому замеру
    path, dsc, testname:string;
    // использовать СЕВ
    useUTS:boolean;
    chart:cchart;
    showFrm:boolean;
    // использовать априорную информацию. Если false то не обрабатывается
    // useprevoffset, useBladesPos (не ищется firstsensorind)
    useStageInfo,
    // включает проверку, что лопатка не перескочила в другой оборот по априорным
    // данным (расположение лопаток на турбине, смещения)
    useNearest,
    // использовать частоту следования импульсов на датчике
    // для подсчета пропущенных импульсов
    useDist:boolean;
    // UseCorr искать первую лопатку в обороте по коеффициенту корреляции
    useCorr:boolean;
    // Использовать blades если true иначе используется shape (форма смещеий)
    useBladesPos:boolean;
    // допуск на расстояние до первой лопатки
    offset:single;
    // априорное положение первой лопатки
    pos,
    // ссылка на ступень
    stage:cstage;
    // ссылка на тренд для отображения результатов
    trend:ctrend;
    // доп данные
    data:pointer;
    // рассчитывать число пропущенных лопаток в обороте
    evalSkipBladesInTurn,
    // вызывать процедуру по обработке отфильтрованных тиков
    callBadTicksProc:boolean;
    eng:cbldeng;
    taho:csensor;
    tags:cBaseObjList;
    alg:tobject;
    startind,endind:integer;
  public
    constructor create;virtual;
    procedure createEvents(e:ceventlist);
    procedure DeleteEvents(e:ceventlist);
  end;

  cBaseBldAlg = class(cTagOwnerObj)
  public
    // частота дискретизации (<0 если сигнал x/y)
    SampleRate,
    // размер порции при записи 3d
    portionSize,
    dZ
    :integer;
    // сохранять сигнал
    SaveSignals,
    // показывать форму настройки перед сохранением замера
    showSaveDlg,
    // щаписать 3d
    b_3D:boolean;
    // путь к сохраняемому замеру
    path, dsc, testname:string;

    // использовать СЕВ
    useUTS:boolean;
    // поток в котором выполняется алгоритм
    Task:cbaseobj;
    ownerSensorList:boolean;
    sensorsList:cAlgSensorList;
    // текущий датчик
    curtaho:csensor;
    drawObj:cdrawObj;
    eng:cbldeng;
    prepared,
    algBlocked:boolean;
    // тег сигнала единого времени
    UTSTag:c2dVectorTag;
  protected
    // алгоритм двухпроходный - на первой стадии выявляются корректные обороты
    // на второй стадии выполняется спец обработка когда один оборот зависим от другого
    DoubleProcessing:boolean;
    // Последовательности корректных оборотов. Число элементов - число корректных оборотов
    // значение p.x - начало последовательности p.y - конец последжовательности
    GoodTurnsChain:array of tpoint;
    // число последовательностей
    goodTurnChainCapacity, goodTurnChainLength,
    ValidTurns:integer;

    beginInd,EndInd:integer;
    sstruct:array of AdjustSensorStruct;
    // использовать априорную информацию. Если false то не обрабатывается
    // useprevoffset, useBladesPos (не ищется firstsensorind)
    useStageInfo,
    // флаг намекает, что датчики работают в связке, т.е. если зафильтрован оборот
    // по одному датчику надо фильтровать и второй. validturn увеличивается, только если все
    // датчики имеют корректный оборот
    LinkedSensors,
    // рассчитывать число пропущенных лопаток в обороте
    evalSkipBladesInTurn,
    // флаг который говорит, что необходимо обработать оборот для датчика,
    // сбрасывается в false если датчики связаны LinkedSensors и предыдущий датчик на этом
    // обороте сбойный
    needProcessTurn,
    // использовать частоту следования импульсов на датчике
    // для подсчета пропущенных импульсов
    usedist:boolean;
    turnCluster:sTurnCluster;
    // вызывать процедуру по обработке отфильтрованных тиков
    callBadTicksProc,
    // включает проверку, что лопатка не перескочила в другой оборот по априорным
    // данным (расположение лопаток на турбине, смещения)
    fuseNearest:boolean;
    // UseCorr искать первую лопатку в обороте по коеффициенту корреляции
    useCorr:boolean;
    // Использовать blades если true
    useBladesPos:boolean;
    // допуск на расстояние до первой лопатки
    offset:single;
    BladePos:single;
    // ссылка на ступень
    stage:cstage;
    // число лопаток
    bladecount:integer;
    // начало и конец очередного оборота
    t1, t2:stickdata;
    // индекс первого тика с датчика внутри нового оборота
    sensorind,
    // Последний тик в предыдущем обороте
    lastSensorInd,
    // индекс обрабатываемого оборота
    turnind,
    // индекс обрабатываемого датчика в списке
    CurSensorInd:integer;
    blades:array of single;
    // флаги оборота
    turnFlags:cardinal;
  private
    // вспомогательный буфер используется некоторыми процедурами чтоб не
    // перевыделять память на каждом обороте
    buf:array of integer;
  protected
    procedure GetNewData(turncount:integer);virtual;
    procedure setTagsBuffers(opts:cbaseOPts);virtual;
    procedure setopts(opts:cbaseopts);virtual;
    function AlgEvalTickPos(t1_,t2_, tick:stickdata):single;
    // получить первый импульс лопатки в обороте
    function GetFirstIndInTurn(t1_,t2_:stickdata;s:csensor):integer;
    function GetLastIndInTurn(t1_,t2_:stickdata;s:csensor; var skipCount:integer):integer;
    // i:номер импульса в массиве тиков
    procedure EvalTurnCluster(s:csensor;i:integer);
    // Не использует априорную информацию. вычислению подлежит положение
    // импульса в обороте и его время
    procedure EvalSimpleTurnCluster(s:csensor;i:integer);
    // перенести офсеты в blades. Расчет ведется по датчику s (берется параметр
    //firstbladeoffset)
    procedure PrepareBladePos(s:csensor);
    // получить время оборота в тиках
    function GetDTurn:integer;
    // получить индекс первого тика в новом обороте.
    function GetSensorInd(s:csensor; t1, t2:stickdata):integer;
    function GetEndSensorInd(s:csensor; t1, t2:stickdata):integer;
    // возвращает false если необходимо прервать выполнение алгоритма
    // возвращает 0 - продолжить выполнение. 1 - перейти к следующему обороту.
    // 2 - прервать выполнение
    function TurnSensorProc(s:csensor):integer;virtual;
    // процедура для обработки отфильтрованных тиков
    // i - индекс сбойного импульса
    function BadTicksProc(s:csensor;i:integer):integer;virtual;
    // вызывается перед turnProc
    function BeforeTurnSensorProc:boolean;virtual;
    // основа процедуры расчета. BladeCount - критерий для фильтрации оборотов
    procedure CommonSensorProc(taho:csensor; sensors:cAlgSensorList);virtual;
    // растояние i-й лопатки до датчика на очередном обороте
    function GetSensorBladePos(s:csensor; index:integer):single;
    // получить положение последней лопатки
    function getEndBladePos:single;
    // скоректировать первый импульс
    function CorrectFirstWithNearest(s:csensor;firstInTurn:integer;t1_,t2_:stickdata):integer;
    function CorrectFirstWithPrevOffset(s:csensor;firstInTurn:integer;t1_,t2_:stickdata):integer;
    // скоректировать последний импульс bcgjkmpez расчет пропущенных лопаток.
    // в ситуации когда уровень вибрации превышает половину растояния между лопатками при пропуске
    // в качестве последнего импульса может оказаться импульс из другого оборота, и посчитается что
    // пропуска не было, однако растояние до между лопатками где был пропуск будет большим.
    function CorrectLastWithDist(s:csensor;LastInTurn:integer;
                                 t1_,t2_:stickdata; var skipcount:integer;var inserted:integer):integer;
    function CorrectLastWithNearest(t1_,t2_:stickdata;s:csensor):integer;
    // получить номер лопатки по номеру тика в обороте
    function getBladeNumber(s:csensor; SensorIndex:integer):integer;
    // обратная задача по отношению к предыдущей функции:
    // получить номер ипульса в обороте чтоб пришла лопатка под номером bl
    function GetBladeImpulsIndex(s:csensor; bl:integer):integer;
    procedure InitOpts;virtual;
    // вычислить заполнена ли информация для расчета оборотного кластера
    function ProcClusterError(taho:csensor;sensors:cAlgSensorList):boolean;
    // обработка ошибок. если возникает ошибка возвращает false
    function ProcessErrors(taho:csensor;sensors:cAlgSensorList):boolean;virtual;
    // получить априорное положение лопатки. Причем смещения заданы относительно
    // 0-й лопатки (первая лопатка на датчике по которому строила форма).
    // Чтобы получить растояние i-й лопатки до датчика на очередном обороте
    // (сразу после отметки нового оборода на тахо), нужно использовать
    // GetSensorBladePos(index:integer):single;
    function GetBladePos(index:integer):single;
    // обработка датчика
    function SensorProcessTurn(s:csensor):integer;
    function getUseNearest:boolean;
    function BeforeCommonSensorProc:boolean;virtual;
    procedure AfterTurnProc;virtual;
    procedure SecondProcess;virtual;
    property usenearest:boolean read getUseNearest write fusenearest;
    procedure createEvents(e:ceventlist);virtual;
    procedure DeleteEvents(e:ceventlist);virtual;
    procedure LoadObjAttributes(xmlNode:txmlNode; mng:tobject);override;
    procedure SaveObjAttributes(xmlNode:txmlNode);override;
    procedure OnEndTurn;virtual;
    procedure Preparetosave(tag:cbasetag);virtual;
  public
    procedure SaveMera;
    // инициализация опций алгоритма
    procedure getOpts(opts:cBaseOpts);virtual;
    constructor create;override;
    destructor destroy;override;
    function CreateOpts:cbaseopts;virtual;
    procedure apply(taho:csensor; sensors:cAlgSensorList; data:cBaseOpts);overload;
    procedure apply(ibegin,iend:integer);overload;
    function AlgID:integer;virtual;
    procedure SetTimeBeginEnd(time:tpoint);
    procedure prepare;
    function status:integer;
  end;

  const
    // Скорректирован (например был признан принадлежащим другому обороту)
    c_Correct = $000001;
    // Первый импульс в обороте
    c_NewTurn = $000002;
    // отбракован
    c_Drop = $000004;

    c_error = -1;
    c_Ok = 1;

    // возвращаемое значение в TurnSensorProc
    c_interrupt = 2;
    // сбойный оборот
    c_breakTurn = 1;
    c_continue = 0;

    // идентификаторы алгоритмов
    c_BaseAlg = 1;
    c_PairShape = 2;
    c_TahoAlg = 3;
    c_BladeTrend = 4;
    c_RestoreSignal = 5;
    c_PairShapeTrend = 6;



implementation
uses
  uAlgMng, ubldtimeproc, uAlarms, uprocessAlgTask;

constructor cBaseOpts.create;
begin
  showFrm:=true;
  useStageInfo:=true;
  useNearest:=true;
  useCorr:=false;
  useBladesPos:=false;
  offset:=2;
  callBadTicksProc:=false;
  evalSkipBladesInTurn:=true;

  SampleRate:=1000;
end;

procedure cBaseOpts.createEvents(e:ceventlist);
begin
  if alg<>nil then
    cBaseBldAlg(alg).createevents(e);
end;

procedure cBaseOpts.DeleteEvents(e:ceventlist);
begin
  if alg<>nil then
    cBaseBldAlg(alg).DeleteEvents(e);
end;

destructor cBaseBldAlg.destroy;
begin
  if ownerSensorList then
    sensorsList.destroy;
  // удаляем канал сев
  if UTSTag<>nil then
    UTSTag.destroy;
  inherited;
end;

constructor cBaseBldAlg.create;
begin
  inherited;
  DoubleProcessing:=false;
  ownerSensorList:=false;
  algblocked:=false;
  prepared:=false;
  name:=ClassName;
  InitOpts;
  createTags;
end;

procedure cBaseBldAlg.createEvents(e:ceventlist);
begin

end;

procedure cBaseBldAlg.DeleteEvents(e:ceventlist);
begin

end;

function cBaseBldAlg.getdturn:integer;
begin
  result:=evDecTicks(t1,t2);
end;

procedure cBaseBldAlg.PrepareBladePos(s:csensor);
var
  I: Integer;
begin
  setlength(blades, bladecount);
  prepareBlades(blades,stage.Shape.offset);
end;

function cBaseBldAlg.AlgID:integer;
begin
  result:=c_BaseAlg;
end;

function cBaseBldAlg.GetBladePos(index:integer):single;
var
  i:integer;
  p:single;
begin
  if stage<>nil then
  begin
    if useBladesPos then
      p:=stage.Shape.blades[index]
    else
    begin
      p:=0;
      if GetOffsetsInit(blades) then
      begin
        p:=blades[index];
      end
      else
      begin
        p:=-1;
        errorStage_noBladesPos(stage,stage.eng.flags);
      end;
    end;
    result:=p;
  end
  else
  begin
    result:=-1;
  end;
end;

function cBaseBldAlg.GetSensorBladePos(s:csensor; index:integer):single;
var
  p, spos:single;
begin
  p:=GetBladePos(index);
  spos:=s.pos;
  if p<=spos then
  begin
    result:=spos - p;
    exit;
  end
  else
    result:=360 - p + sPos;
end;

function cBaseBldAlg.getEndBladePos:single;
var
  i:integer;
  p:single;
begin
  result:=GetBladePos(bladecount-1);
end;

function cBaseBldAlg.BeforeTurnSensorProc:boolean;
begin

end;

function cBaseBldAlg.TurnSensorProc(s:csensor):integer;
begin
  result:=0;
end;

function cBaseBldAlg.GetSensorInd(s:csensor;t1,t2:stickdata):integer;
var
  tick:stickdata;
  i:integer;
  dist, dist2:integer;
  sdist, sdist2:single;
begin
  tick:=s.chan.ticks.GetHiTick(t1,i);
  // получаем первый тик который больше либо равен началу оборота
  if i>0 then
  begin
    if compareticks(s.chan.ticks.gettick(i-1),t1)=0 then
    begin
      i:=i-1;
    end;
  end;
  result:=i;
end;

function cBaseBldAlg.GetEndSensorInd(s:csensor;t1,t2:stickdata):integer;
var
  tick:stickdata;
  i:integer;
  dist, dist2:integer;
  sdist, sdist2:single;
begin
  tick:=s.chan.ticks.GetLoTick(t2,i);
  // получаем первый тик который больше либо равен началу оборота
  if i>0 then
  begin
    if i+1<s.chan.ticks.Count then
    begin
      if compareticks(s.chan.ticks.gettick(i+1),t2)=0 then
      begin
        i:=i+1;
      end;
    end;
  end;
  result:=i;
end;

function FindBlade(pos:single; blades:array of single; bladecount:integer):integer;
begin
  result:=FindInFloatArrayHiBound(blades,pos,0,bladecount-1);
  if blades[result]>pos then
    dec(result);
end;



function cBaseBldAlg.CorrectLastWithDist(s:csensor;LastInTurn:integer;
                                 t1_,t2_:stickdata; var skipcount:integer;
                                 var inserted:integer):integer;
var
  tick:stickdata;

  // номер лопатки
  PrevBlade,
  blade,
  sub,
  i:integer;

  dist,min,
  TickPos,
  bladePos:single;
begin
  result:=-1;
  skipcount:=0;
  inserted:=0;
  min:=offset*2;
  PrevBlade:=0;
  for I := sensorind+1 to sensorind+bladecount - 1 do
  begin
    // время первого импульса в обороте
    tick:=s.chan.ticks.gettick(i);
    TickPos:=EvalTickPos(t1_,t2_,tick);
    blade:=FindBlade(tickpos,sstruct[cursensorind].offsets,bladecount);
    if blade>0 then
    begin
      dist:=abs(sstruct[cursensorind].offsets[blade-1]-TickPos);
      min:=dist;
      sub:=-1;
    end;
    dist:=abs(sstruct[cursensorind].offsets[blade]-TickPos);
    if dist<min then
    begin
      min:=dist;
      sub:=0;
    end;
    if blade<bladecount-1 then
    begin
      dist:=abs(sstruct[cursensorind].offsets[blade+1]-TickPos);
      if abs(dist)<abs(min) then
      begin
        min:=dist;
        sub:=1;
      end;
    end;
    // если ближайший импульс вне углового допуска лопатки
    if min>Offset then
    begin
      exit;
    end;
    blade:=blade+sub;
    sub:=blade - prevblade;
    // если в окрестностях лопатки более одной лопатки sub=0 или ни одной >1
    if sub<>1 then
    begin
      exit;
    end;
    prevblade:=blade;
  end;
  result:=sensorind+bladecount - 1;
end;

function cBaseBldAlg.CorrectLastWithNearest(t1_,t2_:stickdata;s:csensor):integer;
var
  i,j, d:integer;
  function testLast(t,t1,t2:stickdata):boolean;
  var
    dpos:single;
  begin
    result:=false;
    dpos:=algEvalTickPos(t1,t2,t);
    // сверяем отклонение импульса от ожидаемого конечного положения
    if sstruct[cursensorind].endPos>=0 then
    begin
      dpos:=abs(sstruct[cursensorind].endpos-dpos);
      // проверяем, что лопатка отклонилась не более чем на разумное расстояние
      if dpos<c_step then
      begin
        result:=true;
      end;
    end
    // если априорное положение лопатки не известно, то сверяем, что лопатка
    // внутри нового оборота прошла не больше "шага" между лопатками
    else
    begin
      if (dpos-360)<c_step then
        result:=true;
    end;
  end;
begin
  result:=lastSensorInd;
  d:=lastSensorInd-sensorind-bladecount+1;
  for I := lastsensorind-d to lastsensorind do
  begin
    if (i>=0) and (i<s.chan.ticks.count) then
    begin
      if testLast(s.chan.ticks.gettick(i),t1_,t2_) then
      begin
        result:=i;
        exit;
      end;
    end;
  end;
end;

function cBaseBldAlg.GetLastIndInTurn(t1_,t2_:stickdata;s:csensor;var skipCount:integer):integer;
var
  inserted:integer;
begin
  result:=lastSensorInd;
  if lastSensorInd=s.chan.ticks.Count-1 then
    exit;
  // использовать частоту следования импульсов на датчике
  // для подсчета пропущенных импульсов
  if useDist then
  begin
    result:=CorrectLastWithDist(s, result,t1_,t2_,skipCount,inserted);
  end
  else
  begin
    if useStageInfo then
    begin
      if useNearest then
        result:=CorrectLastWithNearest(t1_,t2_,s)
    end;
  end;
end;

function cBaseBldAlg.CorrectFirstWithPrevOffset(s:csensor;firstInTurn:integer;t1_,t2_:stickdata):integer;
var
  tick:stickdata;
  sdist:SINGLE;
  i:integer;
begin
  result:=firstInTurn;
  // обработка работает в тех случаях когда уровень вибрации превышает половины растояния
  // меж лопаток, но плохо работает при пропуске лопаток по датчику
  if (sstruct[cursensorind].prevoffset<>-1000) then
  begin
    for i := -1 to 1 do
    begin
      if firstInTurn+i>=0 then
      begin
        tick:=s.chan.ticks.GetTick(firstInTurn+i);
        // растояние между последней и первой лопаткой
        sdist:=abs(sstruct[cursensorind].prevoffset-360 - algEvalTickPos(t1_,t2_,tick));
        if abs(sdist-sstruct[cursensorind].FirstEndDist)/sstruct[cursensorind].FirstEndDist<Offset then
        begin
          result:=firstInTurn+i;
          exit;
        end;
      end;
    end;
  end
  else
    result:=lastSensorInd+1;
end;

function cBaseBldAlg.CorrectFirstWithNearest(s:csensor; firstInTurn:integer;t1_,t2_:stickdata):integer;
var
  tick:stickdata;
  dist,dist2,dist3:integer;
  min,sdist,sdist2,sdist3:SINGLE;
begin
  result:=firstinturn;
  if s.pos<0 then
    s.pos:=0;
  tick:=s.chan.ticks.GetTick(firstInTurn);
  dist:=evDecTicks(t1_,tick);
  // пересчитываем отклонение импульса из тиков в градусы
  sdist:=EvalTickDPos(t1_,t2_,dist)-s.firstBladeOffset;
  min:=sdist;
  if abs(sdist)>offset then
    result:=-1;
  // проверяем что первая лопатка в обороте не перескочила за левую границу оборота
  if firstInTurn>0 then
  begin
    tick:=s.chan.ticks.GetTick(firstInTurn-1);
    dist2:=evDecTicks(t1_,tick);
    sdist2:=EvalTickDPos(t1_,t2_,dist2)-s.firstBladeOffset;
    // если приблизились к нулевому положению
    if abs(sdist2)<abs(min) then
    begin
      if abs(sdist2)<offset then
      begin
        result:=firstInTurn-1;
      end
      else
        result:=-1;
      exit;
    end;
  end;
  // проверяем что первая лопатка в обороте не перескочила за левую границу оборота
  if firstInTurn<s.chan.ticksCount then
  begin
    tick:=s.chan.ticks.GetTick(firstInTurn+1);
    dist3:=evDecTicks(t1_,tick);
    sdist3:=EvalTickDPos(t1_,t2_,dist3)-s.firstBladeOffset;
    if abs(sdist3)<abs(min) then
    begin
      if abs(sdist3)<offset then
        result:=firstInTurn+1
      else
        result:=-1;
    end;
  end;
end;

function cBaseBldAlg.GetFirstIndInTurn(t1_,t2_:stickdata;s:csensor):integer;
var
  NewSensorind,ind:integer;
begin
  // получаем индекс первого импульса в обороте.
  ind:=sensorind;
  // получаем индекс первого импульса в обороте.
  result:=ind;
  // корректировка первого импульса в обороте на случай,
  // если он перескочил в другой оборот
  dropflag(TurnFlags,c_Correct);
  if useStageInfo then
  begin
    if useNearest then
    begin
      result:=CorrectFirstWithNearest(s, result,t1_,t2_);
    end
  end;
end;

function cBaseBldAlg.SensorProcessTurn(s:csensor):integer;
var
  // индекс первого в обороте импульса от датчика
  newSensorind,
  // индекс для обхода отфильтрованых тиков
  j,skipcount:integer;
  nextt2:stickdata;
begin
  // тупо первый тик после t1
  sensorind:=GetSensorInd(s, t1, t2);
  if sensorind+bladecount>s.tickscount then
  begin
    sstruct[CurSensorInd].interrupt:=true;
    result:=c_breakTurn;
  end;
  // тупо последний тик перед t2
  lastSensorInd:=GetLastTick(t1,t2,s.chan.ticks);
  // корректировка первого импульса в обороте на случай,
  // если он перескочил в другой оборот
  dropflag(TurnFlags,c_Correct);
  // коректируем первый и последний импульс по априорной инфе
  if useStageInfo then
  begin
    newSensorind:=GetFirstIndInTurn(t1,t2,s);
    if newSensorind=-1 then
    begin
      setflag(turnflags, c_drop);
      result:=c_breakTurn;
      exit;
    end;
    if NewSensorind<>Sensorind then
      SetFlag(TurnFlags,c_Correct);
    Sensorind:=NewSensorind;
  end;
  // находим последний импульс в обороте
  lastSensorInd:=GetLastIndInTurn(t1,t2,s, skipcount);
  if lastSensorInd-sensorind<>bladecount-1 then
  begin
    setflag(turnflags, c_drop);
    result:=c_breakTurn;
    exit;
  end;
  BeforeTurnSensorProc;
  // если оборот корректный
  if (newsensorind<>-1) then
  begin
    result:=c_continue;
  end;
end;

procedure cBaseBldAlg.EvalTurnCluster(s:csensor;i:integer);
begin
  EvalSimpleTurnCluster(s,i);
  if useStageInfo then
  begin
    turncluster.blade:=getBladeNumber(s,i-sensorind);
    turncluster.p0:=GetBladePos(turncluster.blade);
    // время очередного импульса от датчика
    //turncluster.t:=s.chan.ticks.gettick(i);
    // добавить положение импульса в обороте
    //turncluster.p:=algEvalTickPos(t1,t2,turncluster.t);
    // добавить проденный путь
    turncluster.path:=GetSensorBladePos(s, turncluster.blade);
    // Добавить отклонение от расчетного пути
    turncluster.p2.y:=turncluster.p-turncluster.path;
    //turncluster.p2.x:=TickToSec(turncluster.t);
  end;
end;

procedure cBaseBldAlg.EvalSimpleTurnCluster(s:csensor;i:integer);
begin
  // время очередного импульса от датчика
  turncluster.t:=s.chan.ticks.gettick(i);
  // добавить положение импульса в обороте
  turncluster.p:=algEvalTickPos(t1,t2,turncluster.t);
  // Добавить отклонение от расчетного пути
  turncluster.p2.x:=TickToSec(turncluster.t);
end;

procedure cBaseBldAlg.CommonSensorProc(taho:csensor;sensors:cAlgSensorList);
var
  tick:stickdata;
  // индекс импульса тахо датчика
  i,
  // индекс датчика
  j,
  // счет по сбойным тикам
  k:integer;
  s:csensor;
  valid:boolean;
  offsets:array of single;
  dropindex:array of tpoint;
begin
  validturns:=0;
  lastSensorInd:=-1;
  // выставляем флаги для оборота
  turnFlags:=0;
  // цикл по оборотам
  for i := beginInd to EndInd-1 do
  begin
    if sstruct[cursensorind].interrupt then
    begin
      // если по датчику произошел полный П то прервать алгоритм
      if LinkedSensors then exit;
      continue;
    end;
    turnind:=i;
    // начало оборота
    t1:=taho.chan.ticks.gettick(turnind);
    // конец оборота
    t2:=taho.chan.ticks.gettick(turnind+1);
    // обработка датчика на данном обороте
    valid:=true;
    for j:=0 to sensors.Count-1 do
    begin
      CurSensorInd:=j;
      s:=sensors.GetSensor(j);
      if s.tickscount<1 then
        continue;
      case SensorProcessTurn(s) of
        c_continue:
        begin
          valid:=true;
          if TurnSensorProc(s) = c_interrupt then
          begin
            valid:=false;
            sstruct[cursensorind].interrupt:=true;
          end;
        end;
        c_breakTurn:
        begin
          valid:=false;
          if callBadTicksProc then
          begin
            BadTicksProc(s,sensorind);
          end;
          if linkedsensors then
          begin
            inc(sstruct[cursensorind].dropedturn);
            break;
          end;
        end;
        c_interrupt:
        begin
          valid:=false;
          sstruct[cursensorind].interrupt:=true;
        end;
      end;
      if valid then
      begin
        inc(sstruct[cursensorind].validturns);
        if DoubleProcessing then
        begin
          sstruct[cursensorind].sensorind[validturns]:=sensorind;
        end;
      end
      else
        inc(sstruct[cursensorind].dropedturn);
    end;
    AfterTurnProc;
    // если все датчики отработали корректно оборот
    if valid then
    begin
      OnEndTurn;
    end;
    // если дошли до сюда
    dropflag(turnflags,c_Drop);
  end;
  SecondProcess;
end;

function cBaseBldAlg.ProcessErrors(taho:csensor;sensors:cAlgSensorList):boolean;
var
  s:csensor;
  bExit:boolean;
  I: Integer;
begin
  result:=false;
  bExit:=false;
  if taho.tickscount<1 then
  begin
    errorTicksCount_ErrorType(taho, taho.eng.flags);
    exit;
  end;
  for I := 0 to sensors.Count - 1 do
  begin
    s:=sensors.GetSensor(i);
    if s.tickscount<1 then
    begin
      errorTicksCount_ErrorType(s, s.eng.flags);
      if sensors.Count=1 then
      begin
        result:=false;
        exit;
      end;
    end;
  end;
  if bExit then
    exit;
  result:=true;
end;

function cBaseBldAlg.ProcClusterError(taho:csensor;sensors:cAlgSensorList):boolean;
var
  sensor:csensor;
  i,l:integer;
begin
  result:=true;
  if usestageinfo=false then
    exit;
  for I := 0 to sensors.Count - 1 do
  begin
    sensor:=sensors.GetSensor(i);
    if sensor.stage=nil then
    begin
      result:=false;
    end
    else
    begin
      if cstage(sensor.stage).shape=nil then
      begin
        result:=false;
      end
      else
      begin
        if usebladespos=false then
        begin
          l:=length(cstage(sensor.stage).shape.offset);
          if cstage(sensor.stage).shape.offset[l-1]=0 then
            result:=false;
        end;
      end;
    end;
    if not result then
    begin
      errorSensor_BladePos(sensor,sensor.eng.flags);
      break;
    end;
  end;
end;

function cBaseBldAlg.BeforeCommonSensorProc:boolean;
var
  s:csensor;
  i,j:integer;
begin
  result:=ProcessErrors(curtaho, sensorslist);
  prepared:=result;
  if result then
  begin
    setlength(sstruct,sensorslist.Count);
    for I := 0 to sensorslist.Count - 1 do
    begin
      sstruct[i].validturns:=0;
      sstruct[i].dropedturn:=0;
    end;
    s:=sensorslist.GetSensor(0);
    if stage<>nil then
    begin
      bladecount:=stage.BladeCount;
      setlength(buf,stage.BladeCount);
    end;
    // если массив положений лопаток не создан для ступени создае его локально по смещениям
    if useStageInfo then
    begin
      if stage<>nil then
      begin
        if stage.Shape<>nil then
        begin
          if not usebladespos and (GetOffsetsInit(stage.Shape.offset)) then
          begin
            PrepareBladePos(s);
          end;
          // получаем положение первой лопатки в обороте по априорным данным
          // хранящимся в stag
          if useNearest then
          begin
            for i := 0 to sensorslist.Count - 1 do
            begin
              s:=sensorslist.GetSensor(i);
              sstruct[cursensorind].endpos:=getEndBladePos;
              // расстояние между первой и последней лопаткой в обороте
              sstruct[cursensorind].FirstEndDist:=abs(sstruct[cursensorind].EndPos - 360 - s.pos);
            end;
          end;
        end;
      end;
    end;
    if bladecount=-1 then
    begin
      if s<>nil then
      begin
        // находим число лопаток по статистике импульсов (датчик/ тахо)
        bladecount:=evalBladesCount(curtaho.chan.ticks, s.chan.ticks);
      end;
    end;
  end;
end;

procedure cBaseBldAlg.apply(taho:csensor; sensors:cAlgSensorList; data:cBaseOpts);
var
  s:CSENSOR;
begin
  sensorslist:=sensors;
  // для RunTime нужна замена ф-ции где getOpts закомментировано
  getOpts(data);
  curtaho:=taho;
  data.startind:=0;
  data.endind:=curtaho.tickscount-1;
  if BeforeCommonSensorProc then
  begin
    apply(data.startind,data.endind);
  end;
end;

procedure cBaseBldAlg.apply(ibegin,iend:integer);
var
  s:csensor;
  i,j, tcount:integer;
  tag:cbasetag;
begin
  beginind:=ibegin;
  endind:=iend;
  tcount:=endind-beginind;
  GetNewData(tcount);
  for I := 0 to sensorslist.Count - 1 do
  begin
    sstruct[i].interrupt:=false;
  end;
  if useStageInfo then
  begin
    for I := 0 to sensorslist.Count - 1 do
    begin
      setlength(sstruct[i].offsets,bladecount);
      sstruct[i].validturns:=0;
      sstruct[i].dropedturn:=0;
      for j := 0 to bladecount - 1 do
      begin
        s:=sensorsList.GetSensor(i);
        // пишем сюда номер лопатки
        tcount:=getBladeNumber(s,j);
        sstruct[i].offsets[j]:=GetSensorBladePos(s, tcount);
      end;
    end;
  end;
  CommonSensorProc(curtaho, sensorslist);
  for I := 0 to tags.Count - 1 do
  begin
    tag:=cBaseTag(tags.getobj(i));
    if tag.active then
    begin
      // значение обновилось. надо обновить алармы и проч.
      tag.UpdateValue;
      // обновить отрисовку
      tag.UpdateDrawObj;
    end;
  end;
  for I := 0 to sensorslist.Count - 1 do
  begin
    sstruct[i].droped:=sstruct[i].dropedturn/(sstruct[i].dropedturn+sstruct[i].validturns);
    if sstruct[i].droped<>0 then
    begin
      sstruct[i].droped:=sstruct[i].dropedturn/(sstruct[i].dropedturn+sstruct[i].validturns);
      eng.getmessage('По датчику '+sensorslist.GetSensor(i).name+
                    ' отфильтровано '+ formatstr(sstruct[i].droped*100,3)+'% оборотов',c_infoMessage);
    end;
  end;
  if SaveSignals then
  begin
    SaveMera;
  end;
end;



procedure cBaseBldAlg.InitOpts;
begin
  evalSkipBladesInTurn:=true;
  useNearest:=true;
  useCorr:=false;
  useBladesPos:=false;
  lastSensorInd:=0;
  offset:=2;
  bladecount:=-1;
end;

function cBaseBldAlg.getBladeNumber(s:csensor; SensorIndex:integer):integer;
begin
  result:=uBldMath.getBladeNumber(s.skipblade,sensorindex,bladecount);
end;

function cBaseBldAlg.GetBladeImpulsIndex(s:csensor; bl:integer):integer;
begin
  if s.skipblade<bl then
  begin
    result:=bladecount - bl + s.skipblade;
  end
  else
    result:=s.skipblade - bl;
end;

function cBaseBldAlg.BadTicksProc(s:csensor; i:integer):integer;
begin

end;

function cBaseBldAlg.AlgEvalTickPos(t1_,t2_, tick:stickdata):single;
begin
  if checkflag(turnFlags, c_drop) then
  begin
    //пересчитать если был сбой по тахо
    //Result:=evaltickpos(t1,tick,tahoar[turnind-1]);
    Result:=evaltickpos(t1,t2,tick);
  end
  else
    Result:=evaltickpos(t1,t2,tick);
end;

function cBaseBldAlg.getUseNearest:boolean;
begin
  result:=false;
  if useStageInfo then
    result:=fusenearest;
end;

procedure cBaseBldAlg.setopts(opts:cbaseopts);
begin
  opts.useStageInfo:=useStageInfo;
  opts.useNearest:=useNearest;
  opts.useCorr:=useCorr;
  opts.useBladesPos:=useBladesPos;
  opts.callBadTicksProc:=callBadTicksProc;
  opts.offset:=offset;
  opts.stage:=stage;
  opts.tags:=tags;
  // использовать частоту следования импульсов на датчике
  // для подсчета пропущенных импульсов
  opts.useDist:=useDist;
  opts.alg:=self;
end;

procedure cBaseBldAlg.getOpts(opts:cBaseOpts);
var
  uts:cUTSSensor;
begin
  if opts.taho<>nil then
    eng:=opts.taho.eng;
  if doubleprocessing then
  begin
    goodTurnChainCapacity:=10000;
    goodTurnChainLength:=0;
    SetLength(GoodTurnsChain,goodTurnChainCapacity);
    GoodTurnsChain[0].x:=0;
    GoodTurnsChain[0].x:=0;
  end;
  useStageInfo:=opts.useStageInfo;
  useNearest:=opts.useNearest;
  useCorr:=opts.useCorr;
  useBladesPos:=opts.useBladesPos;
  callBadTicksProc:=opts.callBadTicksProc;
  offset:=opts.offset;
  stage:=opts.stage;
  if stage<>nil then
  begin
    bladecount:=stage.BladeCount;
  end;
  // использовать частоту следования импульсов на датчике
  // для подсчета пропущенных импульсов
  useDist:=opts.useDist;
  if curtaho=nil then
    curtaho:=opts.taho;
  createTags;
  setTagsBuffers(opts);

  path:=opts.path;
  testname:=opts.testname;
  dsc:=opts.dsc;
  SampleRate:=opts.SampleRate;
  SaveSignals:=opts.SaveSignals;
  portionsize:=opts.portionSize;
  dZ:=opts.dZ;
  b_3d:=opts.b_3D;

  useuts:=opts.useUTS;
  if useuts then
  begin
    uts:=cUTSSensor(eng.UTS);
    UTSTag:=uts.createtag;
  end;
end;

procedure cBaseBldAlg.setTagsBuffers(opts:cbaseopts);
var
  i:integer;
  tag:cbasetag;
begin
  for i:=0 to tags.Count - 1 do
  begin
    tag:=cbasetag(tags.getobj(i));
    tag.source:=self;
  end;
end;

function cBaseBldAlg.CreateOpts:cbaseopts;
var
  o:cbaseopts;
begin
  o:=cbaseopts.create;
  setopts(o);
  result:=o;
end;

procedure cBaseBldAlg.SetTimeBeginEnd(time:tpoint);
begin
  beginInd:=time.X;
  if (curtaho.tickscount-2)>=time.Y then
  begin
    endind:=time.Y
  end
  else
  begin
    endind:=curtaho.tickscount-2;
  end;
end;

procedure cBaseBldAlg.prepare;
begin
  BeforeCommonSensorProc;
end;

procedure cBaseBldAlg.GetNewData(turncount:integer);
var
  tag:cbaseTag;
  i:integer;
begin
  for I := 0 to tags.count - 1 do
  begin
    tag:=cbasetag(tags.getobj(i));
    if tag.active then
    begin
      if tag is carraytag then
      begin
        carraytag(tag).used:=0;
      end;
    end;
  end;
  if DoubleProcessing then
  begin
    for I := 0 to sensorsList.Count - 1 do
    begin
      setlength(sstruct[i].sensorind, turncount+1);
    end;
  end;
end;

procedure cBaseBldAlg.LoadObjAttributes(xmlNode:txmlNode; mng:tobject);
var
  str:string;
  s:csensor;
  scount, aCount,i,j,activeTagCount:integer;
  tag:cbasetag;
  tagnode:txmlnode;
  a:calarm;
  task:ctask;
begin
  inherited;
  useStageInfo:=xmlNode.ReadAttributeBool('useStageInfo');
  useNearest:=xmlNode.ReadAttributeBool('useNearest');
  useDist:=xmlNode.ReadAttributeBool('useDist');
  useCorr:=xmlNode.ReadAttributeBool('useCorr');
  useBladesPos:=xmlNode.ReadAttributeBool('useBladesPos');
  offset:=xmlNode.ReadAttributeFloat('offset');
  // читаем задачу
  str:=xmlNode.ReadAttributeString('TaskName');
  task:=ctask(cbldtimeproc(cAlgMng(mng).getTProc).TaskList.getobj(str));
  if task<>nil then
    task.Thread.addAlg(self);
  // имя ступени
  str:=xmlNode.ReadAttributeString('StageName');
  stage:=cstage(eng.getobj(str));
  if stage<>nil then
  begin
    bladecount:=stage.bladecount;
    createTags;
    setTagsBuffers(nil);
  end
  else
    bladecount:=0;
  // число датчиков
  scount:=xmlNode.ReadAttributeInteger('SensorsCount');
  for I := 0 to scount - 1 do
  begin
    str:='s_'+inttostr(i);
    str:=xmlNode.ReadAttributeString(str);
    s:=csensor(eng.getobj(str));
    sensorsList.add(s);
  end;
  str:=xmlNode.ReadAttributeString('taho');
  curtaho:=csensor(eng.getobj(str));
  // пишем активные теги
  activeTagCount:=xmlNode.ReadAttributeInteger('activeTagCount');
  for I := 0 to activeTagCount - 1 do
  begin
    tagnode:=xmlNode.Nodes[i];
    str:=tagnode.Name;
    tag:=cbasetag(tags.getobj(str));
    if tag<>nil then
    begin
      // сбрасываем в false на случай если тег изначально активен при создании алгоритма
      tag.active:=false;
      tag.active:=true;
      tag.opts:=tagnode.ReadAttributeString('DrawObj');
      // сохраняем аларм
      aCount:=tagnode.ReadAttributeInteger('AlarmCount');
      for j:=0 to aCount-1 do
      begin
        a:=calarmmng(cbldtimeproc(eng.timeProc).alarms).createalarm;
        a.name:=tagnode.ReadAttributeString('AlarmName');
        a.dsc:=tagnode.ReadAttributeString('Desc',a.dsc);
        a.LoAlarm:=tagnode.ReadAttributeBool('LoAlarm',a.LoAlarm);
        a.threshold:=tagnode.ReadAttributeFloat('Thereshold',a.threshold);
        a.Gisterezis:=tagnode.ReadAttributeInteger('Gisterezis',a.Gisterezis);
        tag.addalarm(a);
      end;
    end;
  end;
end;

procedure cBaseBldAlg.SaveObjAttributes(xmlNode:txmlNode);
var
  str:string;
  i,j, activeTagCount:integer;
  tag:cbasetag;
  tagnode:txmlnode;
  a:calarm;
begin
  inherited;
  xmlNode.WriteAttributeBool('useStageInfo',useStageInfo);
  xmlNode.WriteAttributeBool('useNearest',useNearest);
  xmlNode.WriteAttributeBool('useDist',useDist);
  xmlNode.WriteAttributeBool('useCorr',useCorr);
  xmlNode.WriteAttributeBool('useBladesPos',useBladesPos);
  xmlNode.WriteAttributeFloat('offset',offset);
  if task<>nil then
    xmlNode.WriteAttributeString('TaskName',task.name)
  else
    xmlNode.WriteAttributeString('TaskName','');
  if task<>nil then
    xmlNode.WriteAttributeString('Task',task.name);
  if stage<>nil then
    xmlNode.WriteAttributeString('StageName',stage.name)
  else
    xmlNode.WriteAttributeString('StageName','');
  xmlNode.WriteAttributeFloat('SensorsCount',sensorsList.Count);
  for I := 0 to sensorsList.Count - 1 do
  begin
    str:='s_'+inttostr(i);
    xmlNode.WriteAttributeString(str,sensorslist.GetSensor(i).name);
  end;
  if curtaho<>nil then
    xmlNode.WriteAttributeString('taho',curtaho.name)
  else
    xmlNode.WriteAttributeString('taho','');
  // пишем активные теги
  activeTagCount:=0;
  for I := 0 to tags.count - 1 do
  begin
    tag:=cbasetag(tags.getobj(i));
    if tag.active then
    begin
      tagnode:=xmlNode.NodeNew(tag.id);
      if tag.DrawObj<>nil then
        tagnode.WriteAttributeString('DrawObj',tag.DrawObj.name);
      inc(activeTagCount);
      // сохраняем аларм
      tagnode.WriteAttributeInteger('AlarmCount',tag.alarms.Count);
      for j:=0 to tag.alarms.Count-1 do
      begin
        a:=calarmslist(tag.alarms).GetAlarm(i);
        tagnode.WriteAttributeString('AlarmName',a.name);
        tagnode.WriteAttributeString('Desc',a.dsc);
        tagnode.WriteAttributeBool('LoAlarm',a.LoAlarm);
        tagnode.WriteAttributeFloat('Thereshold',a.threshold);
        tagnode.WriteAttributeInteger('Gisterezis',a.Gisterezis);
      end;
    end;
  end;
  xmlNode.WriteAttributeInteger('activeTagCount',activeTagCount);
end;

function cBaseBldAlg.status:integer;
begin
  if prepared then
    Result:=c_Ok
  else
    Result:=c_error;
end;

procedure cBaseBldAlg.OnEndTurn;
begin
  inc(validturns);
  if doubleprocessing then
  begin
    if ValidTurns=1 then
    begin
      inc(goodTurnChainLength);
    end
    else
    begin
      if turnind-GoodTurnsChain[goodTurnChainLength-1].Y=1 then
      begin
        inc(GoodTurnsChain[goodTurnChainLength-1].Y);
      end
      else
      begin
        inc(goodTurnChainLength);
        GoodTurnsChain[goodTurnChainLength-1].x:=turnind;
        GoodTurnsChain[goodTurnChainLength-1].y:=turnind;
      end;
    end;
  end;
end;

procedure cBaseBldAlg.SecondProcess;
begin

end;

procedure cBaseBldAlg.SaveMera;
var
  list:tStringList;
  s:cTagSignal;
  // перевод из градусов в мм
  k1:single;
  i:integer;
  tag:cbasetag;
  lpath,lname:string;
  merafile:cmerafile;
  opts:tmeraopts;
begin
  k1:=cstage(stage).getscale;
  list:=tstringlist.Create;
  for i:=0 to tags.count-1 do
  begin
    tag:=cbaseTag(tags.getobj(i));
    if tag is c2VectorTag then
    begin
      if tag.active then
      begin
        s:=cTagSignal.Create;
        s.obj:=tag;
        s.k1:=k1;
        s.k0:=0;
        s.yUnits:='мм';
        s.xUnits:='сек';
        // чистка происходит внутри mera файла
        list.AddObject(tag.name, s);
      end;
    end;
  end;
  opts.TestName:=TestName;
  opts.TestDsc:=Dsc;
  opts.freq:=samplerate;
  for I := 0 to list.Count - 1 do
  begin
    s:=cTagSignal(list.Objects[i]);
    s.freqX:=opts.freq;
    if opts.freq<1 then
    begin
      s.WriteXY:=true;
    end;
    s.b_3d:=b_3d;
    s.dz:=dz;
    s.portionsize:=portionsize;
  end;
  lpath:=extractfiledir(path);
  lname:=extractfileName(path);
  // готовим к записи СЕВ
  if UTSTag<>nil then
  begin
    s:=cTagSignal.Create;
    s.obj:=UTSTag;
    s.k1:=1;
    s.k0:=0;
    s.WriteXY:=true;
    s.yUnits:='сек.';
    s.xUnits:='сек.';
  end
  else
    s:=nil;
  merafile:=cmerafile.create(path,lpath, list, opts ,s);
  merafile.save;
  merafile.DestroySignals;
  merafile.Destroy;
  list.Destroy;
end;

procedure cBaseBldAlg.Preparetosave(tag:cbasetag);
begin

end;

procedure cBaseBldAlg.AfterTurnProc;
begin

end;

end.
