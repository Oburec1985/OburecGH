unit u2070;

interface
uses
  MxxxxAPI, MxxxxTypes,  inifiles, SysUtils, classes, uBaseObjMng,
  uBaseObj, uBldObj, uBaseObjTypes, controls, ubldeng, uPlat,  Types4Bld,
  uTag, ubldglobalstrings;

type
  LWArr = array of longword;
  ArrLWArr = array of LWArr;
  WordArray = array of Word;
  PWordArray = array of WordArray;

  cM2070 = class(cPlat)
  protected
    // идентификатор устройства. Заполняется при вызове CreateDevice
    handle:ppointer;
    // буфер для получения данных из платы в синхронном режиме
    DigBuff:array of longWord;
    // массив распакованных данных
    chandata:ArrLWArr;
    AnalogData:PWordArray;
  protected
    procedure init(inipath:ansistring; devinfo:TDevice);override;
    procedure Config;override;
    // Установить размер буфера
    procedure SetBufferSize(size:cardinal);override;
  public
  public
    constructor create;override;
    destructor destroy;override;
    procedure Stop;override;
    // Получить буфер данных. Осциллографирование. Получает состояние всех каналов
    procedure GetOscData;
  end;

  // процедура callback на прерывания от платы
  function DataHandler(sender : tobject):cardinal; stdcall;

  const
    // обьем памяти для handler
    memsize = 1000000;
    // Секция из которой читается число лопаток
    section = 'Lopatki';
    // число аналоговых каналов
    c_AChanCount = 1;
    // частота опроса аналоговых каналов
    cRate = 10000;
    c_OscBuff = 4096;

implementation

Function DataHandler(sender : tobject):cardinal; stdcall; //обработчик прерывания
var  dir: Word;
    szLost,szOverflow,BSize:LongInt;
    plat:cM2070;
begin
  plat:=cm2070(sender);
  GetDirection(plat.handle,@dir);
  GetReadBufSize(plat.handle,@BSize,@szLost,@szOverflow);
  MxxxxApi.ReadBuf(plat.handle,@plat.Bf.Buf[plat.Bf.BSIndx*plat.Bf.AcqIndex],@BSize);
  plat.Bf.AcqIndex:=(plat.Bf.AcqIndex+1)mod cSafetyfactor;
  result:=0;
end;

procedure cM2070.init(inipath:ansistring; devinfo:TDevice);
var
  inifile:tinifile;
  res:cardinal;
  p:pointer;
begin
  inherited;
  // p - должен указывать хоть куда-то (не nil)
  getmem(p, memsize);
  handle:=@p;
  res:=MxxxxApi.CreateDevice(devinfo, handle);
  handle:=p;
  // если не было ошибок
  if res=ERROR_NOERROR then
  begin
    Res:=ReadPropertyEx(handle,PAnsiChar(inipath),PAnsiChar(section));
    if Res = ERROR_NOERROR then
    begin
      SetInterrupt(handle, self, @DataHandler);
      // чтобы правильно прошла инициация в ini файле должен быть правильно
      // прописан путь к Flex файлу
      Res :=Load(handle);
      if Res <> ERROR_NOERROR then
      begin
        // если произошла ошибка, закрываем устройство
        CloseDevice(@handle);
        handle:=nil;
      end
      else //плата 2070 готова
      begin
        finit:=true;
      end;
    end
  end;
  freq:=999;
  if fileexists(inipath) then
  begin
    inifile:=tinifile.create(inipath);
    freq:=iniFile.ReadFloat(section,'FreqInN',999);
    iniFile.Destroy;
  end;
  Config;
end;

procedure cM2070.Config;
var
  res:cardinal;
  v:variant;
begin
  // считать свойства платы
  Res:=ReadPropertyEx(handle,PAnsiChar(m_inipath),PAnsiChar(section));
  // частота аналогового сбора
  VarClear(v);
  TVarData(v).VType := varDouble;
  TVarData(v).VDouble:=freq;
  // 999
  SetProperty(handle, PROP_FREQ_IN, v);
  // размер буфера
  VarClear(v);
  TVarData(v).VType := varSmallint;
  TVarData(v).VSmallint:=c_BuffSize;
  // 1023
  SetProperty(handle,PROP_NWORD, v);
  // число фрэймов
  VarClear(v);
  TVarData(v).VType := varSmallint;
  TVarData(v).VSmallint:=c_FrameCount;
  // 10
  SetProperty(handle,PROP_CNT_FRAME, v);
  //число полубуферов ФИФО
  VarClear(v);
  TVarData(v).VType := varSmallint;
  TVarData(v).VSmallint:= cPartFifo;
  // 8
  SetProperty(handle,PROP_CNT_PART_FIFO, v);
  // канал аналогового коммутатора
  VarClear(v);
  TVarData(v).VType := varSmallint;
  TVarData(v).VSmallint:=$004+(0); //$004+( ME052.Chan div 8);
  // 4
  SetProperty(handle,PROP_CMD_REG_0, v);
  res := mxxxxapi.Config(handle);

  GetOscData;
end;

destructor cM2070.destroy;
begin
  inherited;
  CloseDevice(@handle);
  //freemem(handle^, memsize);
end;

procedure cM2070.GetOscData;
var
  res:cardinal;
  AChans: array [0..4] of word;
  i,j:integer;
  Mask, MaskA:LongWord;
  bufsize:word;
begin
  AChans[0]:=0;
  AChans[1]:=1;
  AChans[2]:=2;
  AChans[3]:=3;
  //<=4096 в 16-битных словах
  bufsize:=c_OscBuff;
  res:=LpOscil(handle, cRate, @AChans, c_AChanCount, @DigBuff[1], bufsize);
  if res=ERROR_NOERROR then
  begin
    MaskA:=$FFF00000;
    for i:=0 to (bufsize div NumPort)-1 do  //выделим соответствующий бит
    begin
       for j:= 0 to fChanCount - 1 do
       begin
         //Andata[0][i]:= (DigBuf[i] and MaskA) shr 20;  // TODO : здесь распаковка кодов АЦП
         // маска для выделения j- ого канала
         Mask:=1 shl j;
         chandata[j][i]:=((DigBuff[i] and Mask) shr j);
       end;
       AnalogData[0][i]:= (DigBuff[i] and MaskA) shr 20;
    end;
  end;
end;

procedure cM2070.Stop;
begin
  //остановка приема/передачи данных
  mxxxxapi.Stop(handle);
end;

constructor cM2070.create;
begin
  inherited;
  objtype:=c_2070;
  fChanCount:=22;
  // буфер данных для цифровых каналов
  setlength(chandata, fChanCount);
  // буфер данных для аналоговых каналов
  setlength(AnalogData,2);
end;

procedure cM2070.SetBufferSize(size:cardinal);
var
  I: Integer;
begin
  inherited;
  setlength(DigBuff ,cBufSize);
  for I := 0 to fChanCount - 1 do
  begin
    setlength(chandata[i],(c_OscBuff div NumPort));
  end;
  setlength(AnalogData[0], c_OscBuff);
  setlength(AnalogData[1], c_OscBuff);
end;

end.
