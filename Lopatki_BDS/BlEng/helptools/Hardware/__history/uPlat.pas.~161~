unit uPlat;

interface
uses
  MxxxxAPI, MxxxxTypes, Types4Bld, inifiles, SysUtils, classes, uBaseObjMng,
  uBaseObj, uBldObj, uBaseObjTypes, controls, ubldeng, ubldtimeproc,
  uTagOwnerObj, uTag, ubldEngEventTypes, uBldGlobalStrings, uTagUtils;

type
  cPlatThread = class;

  cPlat = class(cTagOwnerObj)
  private
   //Для асинхронного ввода размер буфера платы в словах
   // -размер фрейма, кратный трем словам, в половину FIFO входят NFrame таких буферов
   // 126, 255,510,1023,2046,4095, 6141
    fBufferSize:cardinal;
    Thread:cPlatThread;
  public
    // буфер данных
    Bf:TBuf;
    // плата проинициализирована
    finit:boolean;
    // Частота опроса
    freq:double;
    // файл настроек платы
    m_inipath:ansistring;
    // число каналов
    fChanCount:cardinal;
    // теги по каналам
    digTags:array of cvectortag;
    GetDataMode:integer;
  protected
    // проинициализировать плату
    //procedure init(inipath:ansistring; devinfo:TDevice);virtual;
    procedure init(inipath:ansistring; devinfo:TDevice);virtual;
    // перезаписать свойства платы. Делается перед началом сбора данных
    procedure Config;virtual;abstract;
    procedure SetBufferSize(size:cardinal);virtual;
    procedure createTags;override;
    // процедура вызывается в цикле для получения данных с периодом
    procedure SyncGetData;virtual;
  public
    destructor destroy;override;
    function getengine:cbldeng;override;
    property BufferSize:cardinal read fBufferSize write SetBufferSize;
    constructor create;override;
    // Остановить прием данных
    procedure Stop;virtual;
    // получить пачку данных (разово)
    procedure GetData;virtual;abstract;
    // включить режим приема данных
    procedure Oscillograph;
  end;

  cPlatsList = class(cBaseObjMng)
  public
    eng:cbldeng;
    //структура, описывающая найденные в системе ТМ устройства
    pFoundDevs : TDeviceEnum;
  protected
    procedure regObjClasses;override;
  public
    function getplat(i:integer):cplat;overload;
    function getplat(name:string):cplat;overload;
    procedure OnTagSetActive(sender:tobject);
    // поиск существующих плат
    procedure Search;
    procedure play;
    procedure stop;
  end;

  cPlatThread = class(TThread)
  public
    plat:cPlat;
  protected
    // период работы потока в миллисекундах
    fperiod:cardinal;
    fstate:cardinal;
  protected
    procedure Linc(p_plat:cplat);
    procedure Execute; override;
    procedure setperiod(v:cardinal);
    procedure setState(v:cardinal);
    Property State:cardinal read fstate write setstate;
  public
    procedure play;
    procedure stop;
  public
    property period:cardinal read fperiod write setPeriod;
  end;

  const
    // 126, 255,510,1023,2046,4095, 6141
    c_BuffSize = 1023;
    c_FrameCount = 10;
    c_s2081 = 'M2081';
    c_s2070 = 'M2070';
    c_OscMode = 1;
    c_ASyncMode = 2;
    // удаляемс
    c_play = 1;
    c_pause = 0;
    c_Delete = 2;

procedure LoadFromFile(FileName:AnsiString;var Size:Cardinal;Buff:pByteArray);

implementation
uses
  u2070, u2081;

procedure LoadFromFile(FileName:AnsiString;var Size:Cardinal;Buff:pByteArray);
var
  f:File;
  llength:Cardinal;
begin
  AssignFile(f,FileName);
  Reset(f, 1);
  llength:= FileSize(f);
  GetMem(Buff,llength);
  BlockRead(f,Buff,llength);
  Close(f);
  Size:=llength;
end;

function checkName(name1:array of ansichar; name2:ansistring):boolean;
var
  I: Integer;
begin
  result:=true;
  for I := 0 to length(name2)-1 do
  begin
    if name1[i]<>name2[i+1] then
    begin
      result:=false;
      exit;
    end;
  end;
end;

procedure cPlatsList.regObjClasses;
begin
  inherited;
  regclass(cM2070);
  regclass(cM2081);
end;

procedure cPlatsList.OnTagSetActive(sender:tobject);
begin
  if cBaseTag(sender).active then
  begin
    cbldtimeproc(eng.timeProc).ftagmng.Add(cBaseTag(sender));
  end
  else
  begin
    cbldtimeproc(eng.timeProc).ftagmng.removeObj(cBaseTag(sender));
  end;
  eng.Events.CallAllEventsWithSender(e_OnAddRemoveTag,cBaseTag(sender));
end;

procedure cPlatsList.Search;
var
  I: Integer;
  plat:cPlat;
  res:cardinal;
  path,section:ansistring;
begin
  SearchDevicesEx(@pFoundDevs);
  if pFoundDevs.nFoundDevs>0 then
  begin
    for I := 0 to pFoundDevs.nFoundDevs - 1 do
    begin
      if checkName(pFoundDevs.DevInfo[i].DeviceName,c_s2070) then
      begin
        Plat:=cM2070.create;
      end
      else
      begin
        if checkName(pFoundDevs.DevInfo[i].DeviceName,c_s2081) then
        begin
          Plat:=cM2081.create;
        end;
      end;
      Add(Plat, nil);
      path:=eng.PathMng.findCfgPathFile('M2070.INI');
      plat.init(path, pFoundDevs.DevInfo[i]);
      plat.createTags;
    end;
  end;
end;

procedure cPlatsList.play;
var
  I: Integer;
  plat:cplat;
begin
  for I := 0 to count - 1 do
  begin
    plat:=getplat(i);
    if plat.getDataMode=c_OscMode then
    begin
      plat.Oscillograph;
    end
    else
    begin

    end;
  end;
end;

procedure cPlatsList.stop;
var
  I: Integer;
  plat:cplat;
begin
  for I := 0 to count - 1 do
  begin
    plat:=getplat(i);
    if plat.getDataMode=c_OscMode then
    begin
      plat.stop;
    end
    else
    begin

    end;
  end;
end;

function cPlatsList.getplat(i:integer):cplat;
begin
  result:=cplat(getobj(i));
end;

function cPlatsList.getplat(name:string):cplat;
begin
  result:=cplat(getobj(name));
end;

constructor cPlat.create;
begin
  inherited;
  getDataMode:=c_OscMode;
  finit:=false;
  helper:=false;
  imageindex:=c_Hardware_img;
  blocked:=false;
  Thread:=cPlatThread.Create(true);
  Thread.FreeOnTerminate:=true;
  Thread.Linc(self);
end;

destructor cPlat.destroy;
begin
  if Thread.Suspended then
    Thread.resume;
  Thread.Terminate;
  inherited;
end;

function cplat.getengine:cbldeng;
var
  list:cplatslist;
begin
  result:=nil;
  if getMng is cbldeng then
  begin
    result:=cbldeng(getmng);
  end
  else
  begin
    list:=cPlatsList(getMng);
    result:=list.eng;
  end;
end;

procedure cPlat.init(inipath:ansistring; devinfo:TDevice);
begin
  m_inipath:=inipath;
end;

procedure cPlat.SetBufferSize(size:cardinal);
begin
  fBufferSize:=size;
end;

procedure cPlat.createTags;
var
  I: Integer;
  tag:cbaseTag;
begin
  if fchancount<>0 then
  begin
    setlength(digTags,fchancount);
    for I := 0 to fchancount - 1 do
    begin
      tag:=cvectortag.create;
      digTags[i]:=cvectortag(tag);
      tag.OnSetActive:=cPlatsList(getmng).OnTagSetActive;
      tag.name:=Name+'_'+inttostr(i);
      tag.dsc:=v_OscTagDsc;
      tag.blocked:=true;
      tags.addobj(tag);
      if finit then
        tag.active:=true;
    end;
  end;
  for I := 0 to tags.Count - 1 do
  begin
    tag:=gettag(i);
    tag.source:=self;
  end;
  BufferSize:=c_BuffSize;
end;

procedure cPlat.Oscillograph;
begin
  thread.play;
end;

procedure cPlat.Stop;
begin
  thread.stop;
end;

procedure cPlat.SyncGetData;
var
  I: Integer;
  tag:cbasetag;
begin
  getdata;
  for I := 0 to tags.count - 1 do
  begin
    tag:=gettag(i);
    if tag.DrawObj<>nil then
      TagToDrawObj(tag.DrawObj,tag,nil);
  end;
end;

procedure cPlatThread.Execute;
begin
  while not terminated do
  begin
    if state=c_play then
    begin
      // получаем данные
      plat.SyncGetData;
    end
    else
      suspend;
    sleep(period);
  end;
end;

procedure cPlatThread.setperiod(v:cardinal);
begin
  fperiod:=v;
end;

procedure cPlatThread.setState(v:cardinal);
begin
  fstate:=v;
  case v of
    c_play:resume;
    // suspend выполняется только в одной точке программы (вконце execute)
    c_pause:;
    c_delete:
    begin
      if suspended then
        resume;
      terminate;
    end;
  end;
end;

procedure cPlatThread.Linc(p_plat:cplat);
begin
  plat:=p_plat;
  fperiod:=1000;
end;

procedure cPlatThread.play;
begin
  state:=c_play;
end;

procedure cPlatThread.stop;
begin
  state:=c_pause;
end;

end.
