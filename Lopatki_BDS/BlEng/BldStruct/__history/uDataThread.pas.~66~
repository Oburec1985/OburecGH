unit uDataThread;

interface
uses
  windows, uBaseObj, classes, SysUtils,
  uCommonMath, uEventtypes, ExtCtrls, uBaseObjMng,
  NativeXML, uEventList, dialogs, uSetList;

type
  cDataThreadMng = class;

  // класс для обозначения мнест вызовов синхронных и асинхронных событий
  // в контексте BaseObj-ов
  cDataThread = class(TThread)
  protected
    fperiod:cardinal;
    // запущены или нет потоки
    fEnabled:boolean;
    fMng:cDataThreadMng;
    // секция защищает работу с флагами потока
    StartStopCs:TRTLCriticalSection;
    // сосотояние потоков - работают, пауза, переход в остановку, остановлены
    fStatus:integer;
  public
    Data:pointer;
  protected
    // Включение/ выключение потока
    procedure setEnabled(b:boolean);
    function getEnabled:boolean;
    procedure InitCS;
    procedure DeleteCS;
    // функция выполняется в execute. Вызывает асинхронное событие менеджера потоков
    // здесь наследники класса реализуют механизм получения данных
    procedure PlayFunc;virtual;
  public
    constructor create;virtual;
    destructor destroy;override;
    procedure Execute;override;
    property Enabled:boolean read getEnabled write setEnabled;
  end;

  cDataThreadMng = class(cSetList)
  private
    m_tProc:tobject;
    // запущены или нет потоки
    fEnabled:boolean;
    // сосотояние потоков - работают, пауза, переход в остановку, остановлены
    fStatus:integer;
    // синхронизировать потоки по самому медленному.
    // Если работает несколько потоков, то при выполнении Execute до конца они встанут в ожидание остальных потоков.
    // все получат данные вызовется SyncEvent
    fCallSync:boolean;
    // защита счетчика потоков
    cs:TRTLCriticalSection;
  protected
    // счетчик остановленных потокв. Если равен 0, то enabled:=false;
    fStopThreadCounter:integer;
  public
    // Асинхронное событие
    AsyncEvent:TNotifyEvent;
    // Синхронное событие
    SyncEvent:TNotifyEvent;
  protected
    procedure ASyncDataEvent(DataThread:cDataThread);virtual;
    procedure SyncDataEvent(DataThread:cDataThread);virtual;
    // Включение/ выключение потоков
    procedure setEnabled(b:boolean);
    function getEnabled:boolean;
  public
    constructor create;override;
    destructor destroy;override;
    // увеличить уменьшить число запущенных потоков
    procedure addStartedThread;
    procedure decStartedThread;
    function GetThread(i:integer):cDataThread;
    // Удаление потомка (вызывает деструктор потомка и отвязывает от дерева)
    procedure deletechild(i:integer);override;
    procedure deletechild(node:pointer);override;
    // Включение/ выключение потоков
    property Enabled:boolean read getEnabled write setEnabled;
    // синхронизировать потоки по самому медленному.
    property CallSync:boolean read getEnabled write setEnabled;
  end;

  const
    c_Stop = 0;
    c_TryStop = 1;
    c_Play = 3;

implementation
uses
  uBldTimeProc;

procedure cDataThread.PlayFunc;
begin
  fMng.ASyncDataEvent(self);
end;

procedure cDataThread.Execute;
begin
  while not terminated do
  begin
    EnterCriticalSection(StartStopCs);
    if fStatus=c_Play then
    begin
      // получение данных
      playFunc;
      // тупо ждем  когда процессор обработает данные
      if m_tProc.waitDataProcEvent then
      begin
        if mode then
        begin
          ExchangeData;
          m_tProc.ProcFile:=false;
        end;
      end;
      // вызов асинхронного события
      if assigned(fMng.AsyncEvent) then
        fMng.AsyncEvent(self);
    end;
    if fstatus=c_trystop then
    begin
      fStatus:=c_stop;
      fMng.decStartedThread;
      suspend;
    end;
    LeaveCriticalSection(StartStopCs);
    sleep(fPeriod);
  end;
end;

constructor cDataThread.create;
begin
  inherited create(true);
  InitCS;
  // настройки потока
  FreeOnTerminate:=false;
  Priority:=tpLower;
end;

destructor cDataThread.destroy;
begin
  if suspended then
  begin
    resume;
    fStatus:=c_Stop;
  end;
  deletecs;
  inherited;
end;

procedure cDataThread.InitCS;
begin
  InitializeCriticalSection(StartStopcs);
end;

procedure cDataThread.DeleteCS;
begin
  DeleteCriticalSection(StartStopcs);
end;

// Включение/ выключение потока
procedure cDataThread.setEnabled(b:boolean);
begin
  if b=fEnabled then
    exit;
  // включаем на просмотр
  if b then
  begin
    EnterCriticalSection(StartStopCs);
    fStatus:=c_play;
    LeaveCriticalSection(StartStopCs);
    fMng.addStartedThread;
    fEnabled:=true;
    if suspended then
      resume;
  end
  else
  begin
    EnterCriticalSection(StartStopCs);
    // разрешаем остановку. остановка делается в execute
    fStatus:=c_TryStop;
    LeaveCriticalSection(StartStopCs);
  end;
end;

function cDataThread.getEnabled:boolean;
begin
  result:=fEnabled;
end;

procedure cDataThreadMng.deletechild(i:integer);
begin
end;

procedure cDataThreadMng.deletechild(node:pointer);
begin

end;

procedure cDataThreadMng.ASyncDataEvent(DataThread:cDataThread);
begin

end;

procedure cDataThreadMng.SyncDataEvent(DataThread:cDataThread);
begin

end;

function cDataThreadMng.GetThread(i:integer):cDataThread;
begin
  result:=cDataThread(getNode(i));
end;

procedure cDataThreadMng.setEnabled(b:boolean);
var
  t:cDataThread;
  I: Integer;
begin
  if b then
  begin
    fEnabled:=true;
    for I := 0 to Count - 1 do
    begin
      t:=GetThread(i);
      t.Enabled:=true;
    end;
  end
  else
  begin
    for I := 0 to Count - 1 do
    begin
      t:=GetThread(i);
      t.Enabled:=false;
    end;
  end;
end;

function cDataThreadMng.getEnabled:boolean;
begin
 if fStopThreadCounter=0 then
  result:=true
 else
  result:=false;
end;

constructor cDataThreadMng.create;
begin
  inherited;
  InitializeCriticalSection(cs);
end;

destructor cDataThreadMng.destroy;
begin
  DeleteCriticalSection(cs);
  inherited;
end;

procedure cDataThreadMng.addStartedThread;
begin
  EnterCriticalSection(cs);
  dec(fStopThreadCounter);
  LeaveCriticalSection(cs);
end;

procedure cDataThreadMng.decStartedThread;
begin
  EnterCriticalSection(cs);
  inc(fStopThreadCounter);
  LeaveCriticalSection(cs);
end;


end.
