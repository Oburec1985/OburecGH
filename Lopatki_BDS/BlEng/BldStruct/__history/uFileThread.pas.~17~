unit uFileThread;

interface
uses
  windows, uBaseObj, classes, SysUtils,
  uCommonMath, uEventtypes, ExtCtrls, uBaseObjMng,
  NativeXML, uEventList, dialogs, uSetList, uDataThread;


type
  cID = class
    time:tDateTime;
    // тип файла
    filetype:integer;
    // идентификатор загружаемого замера
    intID:integer;
    // файл обработан
    m_processed:boolean;
    fName:string;
  end;

  cIDSet = class(cSetList)
  public
    Function GetID(i:integer):cID;overload;
    Function GetID(fname:string):cID;overload;
    constructor create;override;
    destructor destroy;override;
    procedure deletechild(node:pointer);override;
  end;

  // класс для обозначения мнест вызовов синхронных и асинхронных событий
  // в контексте BaseObj-ов
  cFileThread = class(cDataThread)
  protected
    // расширение загружаемых файлов
    m_NamePart, m_ext,
    // папка с загружаемыми файлами
    m_folder:string;
    // список идентификаторов которые надо загрузить
    m_IDList:cIDSet;
    // текущий обрабатываемый файл
    curID:integer;
    // массивы тиков (буфер данных для обмена с движком)
    channels:cBaseObj;
  protected
    procedure PlayFunc;override;
    // проверяет наличие новых данных и добавляет в список идентификаторов
    // если список идентификаторов больше чем текущий номер последней
    // обработанной записи то загружается новый файл. если наступает событие
    // в cBldTimeProc обработки данных (обработка закончена), то происходит обмен данными.
    function CheckNewData:boolean;
    function LoadFile(index:integer):boolean;
  public
    constructor create;override;
    destructor destroy;override;
  end;

implementation

function cFileThread.LoadFile(index:integer):boolean;
var
  fname, ext:string;
  l_id:cID;
begin
  result:=false;
  l_id:=m_IDList.GetID(index);
  fname:=l_id.fName;
  // очищаем старые данные
  cleardata;
  if fileexists(fname) then
  begin
    ReadData(fname, channels);
    result:=true;
  end;
end;

function cFileThread.CheckNewData:boolean;
begin
  result:=false;
  if m_idList.count>curID then
  begin
    LoadFile(curID);
    // тупо ждем  когда процессор обработает данные
    if m_tProc.waitDataProcEvent then
    begin
      if mode then
      begin
        ExchangeData;
        m_tProc.ProcFile:=false;
      end;
    end;
    inc(curid);
  end;
end;


constructor cFileThread.create;
begin
  inherited;
  m_IDList:=cIDSet.create;
  m_IDList.destroydata:=true;
  fPeriod:=1000;
  m_ext:='.sdt';
  m_NamePart:='';
  curID:=0;
  channels:=cBaseObj.create;
  channels.destroydata:=true;
  // настройки потока
  FreeOnTerminate:=false;
  Priority:=tpLower;
end;

destructor cFileThread.destroy;
begin
  if suspended then
  begin
    Enabled:=false;
    resume;
  end;
  m_IDList.Destroy;
  channels.destroy;
  inherited;
end;


procedure cFileThread.PlayFunc;
begin
  inherited;
end;

function IDcomparator(p1,p2:pointer):integer;
begin
  result:=0;
  if cID(p1).intID>cID(p2).intID then
  begin
    result:=1
  end
  else
  begin
    if cID(p1).intID<cID(p2).intID then
    begin
      result:=-1
    end
  end;
end;


constructor cIDSet.create;
begin
  inherited;
  comparator:=idComparator;
end;

destructor cIDSet.destroy;
begin
  inherited;
end;

procedure cIDSet.deletechild(node:pointer);
begin
  cID(node).destroy;
end;

Function cIDSet.GetID(i:integer):cID;
begin
  result:=cID(getNode(i));
end;

Function cIDSet.GetID(fname:string):cID;
var
  I: Integer;
  id:cid;
begin
  result:=nil;
  for I := 0 to Count - 1 do
  begin
    id:=GetID(i);
    if id.fName=fname then
    begin
      result:=id;
      exit;
    end;
  end;
end;

end.
