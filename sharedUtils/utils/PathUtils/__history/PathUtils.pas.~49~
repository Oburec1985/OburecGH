unit PathUtils;

interface

uses
  uCommonMath,ShellApi, Windows, dialogs,
  SysUtils {must be before var PathDelim declaration};

  //Преобразует относительный путь APath в абсолютный, относительно базы ABasePath.
  function RelativePathToAbsolute(const ABasePath, APath: String): String;overload;
  function RelativePathToAbsolute(APath: String): String;overload;
  // возвращает базовый путь + часть пути отмеченое в пункте level
  function GetPathLevel(Base,Path: String; level:integer): String;
  //Преобразует абсолютный путь APath в относительный, используя как базу ABasePath.
  function AbsolutePathToRelative(const ABasePath, APath: String): String;
  function WideRelativePathToAbsolute(const ABasePath, APath: WideString): WideString;
  function WideAbsolutePathToRelative(const ABasePath, APath: WideString): WideString;
  function GetRoot(const APath: String): String;
  function WideGetRoot(const APath: WideString): WideString;
  function isRelativePath(const APath: string): boolean;
  function isAbsolutePath(const APath: string): boolean;
  // обрубить строку по терминирующему символу
  function trimNullString(str:string):string;
  function ExecFile(name:string):boolean;
  // если на конце нет '\' то добавляем
  function AddSlashToPath(path:string):string;
  // убираем вконце '\'
  function DelSlashFromPath(path:string):string;
  function extractDirName(path:string):string;
  function RemoveDirAll(sDir : string) : Boolean;

var
  PathDelim: Char;
  CaseSensitive: Boolean;

implementation

type TStringArray = array of String;

function RemoveDirAll(sDir : string) : Boolean;
var
  iIndex: Integer;
  SearchRec: TSearchRec;
  sFileName: string;
begin
  Result := False;
  sDir := sDir + '\*.*';
  iIndex := FindFirst(sDir, faAnyFile, SearchRec);

  while iIndex = 0 do
  begin
    sFileName := ExtractFileDir(sDir)+'\'+SearchRec.name;
    if SearchRec.Attr = faDirectory then
    begin
      if (SearchRec.name <> '' ) and (SearchRec.name <> '.') and
      (SearchRec.name <> '..') then
        RemoveDir(sFileName);
    end
    else
    begin
      if SearchRec.Attr <> faArchive then
        FileSetAttr(sFileName, faArchive);
      if not DeleteFile(sFileName) then
      begin
        ShowMessage('Could NOT delete ' + sFileName);
      end;
    end;
    iIndex := FindNext(SearchRec);
  end;

  FindClose(SearchRec);
  RemoveDir(ExtractFileDir(sDir));
  Result := True;
 end;

function ExecFile(name:string):boolean;
begin
  result:=ShellExecute(0, 'open', pchar(Name), '', pchar(extractfiledir(name)), SW_MAXIMIZE)>0;
end;

function trimNullString(str:string):string;
var
  i:integer;
begin
  for I := 1 to length(str) - 1 do
  begin
    if byte(str[i])=0 then
    begin
      setlength(str, i-1);
      result:=str;
      exit;
    end
  end;
  result:=str;
end;

procedure ResemblePath(const APath: String; var Parts: TStringArray); overload;
var
  i, j, k: Integer;
  S: String;
begin
  j := 1;
  k := 0;
  Parts := nil;
  for i := 1 to Length(APath) do
    if APath[i] = PathDelim then
    begin
      S := Copy(APath, j, i-j);
      if S <> '' then
      begin
        SetLength(Parts, k+1);
        Parts[k] := S;
        Inc(k);
      end;
      j := i+1;
    end;
  if j <= Length(APath) then
  begin
    SetLength(Parts, k+1);
    Parts[k] := Copy(APath, j, MaxInt);
  end;
end;

function RelativePathToAbsolute(const ABasePath, APath: String): String;
var
  i, j, k: Integer;
  TmpPath, S: String;
  RootLevel: Integer;
  Strs1: TStringArray;
begin
  if apath='' then
  begin
    result:='';
    exit;
  end;
  if (Length(APath) > 1) and ((APath[2] = DriveDelim) or // локальный диск
    ((APath[1] = PathDelim) and (APath[2] = PathDelim))) then // или сетевой путь
  begin
    Result := APath; // в таком случае путь не является относительным
    Exit;
  end;
  
  RootLevel := Ord((Length(ABasePath) > 1) and ((ABasePath[2] = DriveDelim) // локальный диск
    or ((ABasePath[1] = PathDelim) and (ABasePath[2] = PathDelim))))-1; // или сетевой путь
  // Выше этого уровня в базовом дереве подняться нельзя: ([A..Z]:) или (\\server_name).
  // Если RootLevel = 0, то это может быть каталог в корне юниксового дерева (\home),
  // или что-то неопределенное (если нет первого слэша) - выше такого каталога можно
  // подняться (перейти на соседний в корне)
    
  Result := '';
  ResemblePath(ABasePath, Strs1);

  j := 1;
  k := Length(Strs1)-1;
  if APath[Length(APath)] = PathDelim
    then TmpPath := APath
    else TmpPath := APath + PathDelim;
  for i := 1 to Length(TmpPath) do
    if TmpPath[i] = PathDelim then
    begin
      S := Copy(TmpPath, j, i-j);
      if (S <> '') and (S <> '.') then
      begin
        if S = '..' then
        begin
          Dec(k);
          if k < RootLevel then k := RootLevel; // выше корня не прыгнешь :)
          // Игнорируем лишние ссылки на родителя или тут нужно исключение?
        end
        else
        begin
          Inc(k);
          if k = Length(Strs1) then
            SetLength(Strs1, k+1);
          Strs1[k] := S;
        end;
      end;
      j := i+1;
    end;
  for i := 0 to k do
    Result := Result + Strs1[i] + PathDelim;

  // Немного уточняем рузультат
  if (Length(APath) > 0) and (APath[Length(APath)] <> PathDelim) then
    SetLength(Result, Length(Result)-1); // в конце нет слэша - м.б. имя файла
  if (Length(ABasePath) > 0) and (ABasePath[1] = PathDelim) then
    Result := PathDelim + Result; // слэш в начале - юниксовый путь
  if (Length(ABasePath) > 1) and (ABasePath[2] = PathDelim) then
    Result := PathDelim + Result; // два слэша в начале - сетевой путь
end;

function RelativePathToAbsolute(APath: String): String;
begin
  result:=RelativePathToAbsolute(getcurrentdir, apath);
end;

function GetRoot(const APath: String): String;
var
  i: Integer;
begin
  Result := '';
  if Length(APath) > 0 then
    if APath[1] = PathDelim then
      if (Length(APath) > 1) and (APath[2] = PathDelim) then
      begin
        for i := 3 to Length(APath) do // сетевой путь
          if APath[i] = PathDelim then
          begin
            Result := Copy(APath, 3, i-3);
            Break;
          end;
        if Result = '' then Result := Copy(APath, 3, MaxInt);
      end
      else Result := PathDelim // корень файловой системы
    else if (Length(APath) > 1) and (APath[2] = DriveDelim) then
      Result := APath[1] // локальный диск
    else
      Result := PathDelim;
end;

function SameString(const S1, S2: String): Boolean; overload;
begin
  if CaseSensitive
    then Result := AnsiCompareText(S1, S2) = 0
    else Result := AnsiCompareStr(S1, S2) = 0;
end;

function AbsolutePathToRelative(const ABasePath, APath: String): String;
var
  Strs1, Strs2: TStringArray;
  i, j, k, l: Integer;
begin
  if (Length(ABasePath) = 0) or (Length(APath) = 0) then
  begin
    Result := APath;  // (*)
    Exit;
  end;

  // пути на разных сетевых шарах или дисках
  if not SameString(GetRoot(ABasePath), GetRoot(APath)) then
  begin
    Result := APath;
    Exit;
  end;

  ResemblePath(ABasePath, Strs1);
  ResemblePath(APath, Strs2);

  Result := '';
  k := Length(Strs1); l := 0;
  for i := 0 to Length(Strs2)-1 do
    if i < k then
    begin
      if not SameString(Strs2[i], Strs1[i]) then
      begin
        for j := i to k-1 do Result := Result + '..' + PathDelim;
        Break;
      end
      else Inc(l);
    end
    else
    begin
      Result := '.' + PathDelim;
      Break;
    end;
  // путь меньше или равен базовому
  if l >= Length(Strs2) then
    if l = k then Result := Result + '.' + PathDelim
    else
      for i := l to k-1 do Result := Result + '..' + PathDelim
  else
    for i := l to Length(Strs2)-1 do
      Result := Result + Strs2[i] + PathDelim;
  if (Length(APath) > 0) and (APath[Length(APath)] <> PathDelim) then
    SetLength(Result, Length(Result)-1); // в конце нет слэша - м.б. имя файла
end;

//------------------------------------------------------------------------------
// Wide-версии

type TWideStringArray = array of WideString;

procedure ResemblePath(const APath: WideString; var Parts: TWideStringArray); overload;
var
  i, j, k: Integer;
  S: WideString;
  PathDelimW: WideChar;
begin
  j := 1;
  k := 0;
  Parts := nil;
  PathDelimW := WideChar(PathDelim);
  for i := 1 to Length(APath) do
    if APath[i] = PathDelimW then
    begin
      S := Copy(APath, j, i-j);
      if S <> '' then
      begin
        SetLength(Parts, k+1);
        Parts[k] := S;
        Inc(k);
      end;
      j := i+1;
    end;
  if j <= Length(APath) then
  begin
    SetLength(Parts, k+1);
    Parts[k] := Copy(APath, j, MaxInt);
  end;
end;

function WideRelativePathToAbsolute(const ABasePath, APath: WideString): WideString;
var
  i, j, k: Integer;
  TmpPath, S: WideString;
  RootLevel: Integer;
  Strs1: TWideStringArray;
  DriveDelimW, PathDelimW: WideChar;
begin
  DriveDelimW := WideChar(DriveDelim);
  PathDelimW := WideChar(PathDelim);
  
  if (Length(APath) > 1) and ((APath[2] = DriveDelimW) or // локальный диск
    ((APath[1] = PathDelimW) and (APath[2] = PathDelimW))) then // или сетевой путь
  begin
    Result := APath; // в таком случае путь не является относительным
    Exit;
  end;

  RootLevel := Ord((Length(ABasePath) > 1) and ((ABasePath[2] = DriveDelimW) // локальный диск
    or ((ABasePath[1] = PathDelimW) and (ABasePath[2] = PathDelimW))))-1; // или сетевой путь
  // Выше этого уровня в базовом дереве подняться нельзя: ([A..Z]:) или (\\server_name).
  // Если RootLevel = 0, то это может быть каталог в корне юниксового дерева (\home),
  // или что-то неопределенное (если нет первого слэша) - выше такого каталога можно
  // подняться (перейти на соседний в корне)

  Result := '';
  ResemblePath(ABasePath, Strs1);

  j := 1;
  k := Length(Strs1)-1;
  if APath[Length(APath)] = PathDelimW
    then TmpPath := APath
    else TmpPath := APath + PathDelimW;
  for i := 1 to Length(TmpPath) do
    if TmpPath[i] = PathDelimW then
    begin
      S := Copy(TmpPath, j, i-j);
      if (S <> '') and (S <> WideString('.')) then
      begin
        if S = WideString('..') then
        begin
          Dec(k);
          if k < RootLevel then k := RootLevel; // выше корня не прыгнешь :)
          // Игнорируем лишние ссылки на родителя или тут нужно исключение?
        end
        else
        begin
          Inc(k);
          if k = Length(Strs1) then
            SetLength(Strs1, k+1);
          Strs1[k] := S;
        end;
      end;
      j := i+1;
    end;
  for i := 0 to k do
    Result := Result + Strs1[i] + PathDelimW;

  // Немного уточняем рузультат
  if (Length(APath) > 0) and (APath[Length(APath)] <> PathDelimW) then
    SetLength(Result, Length(Result)-1); // в конце нет слэша - м.б. имя файла
  if (Length(ABasePath) > 0) and (ABasePath[1] = PathDelimW) then
    Result := PathDelimW + Result; // слэш в начале - юниксовый путь
  if (Length(ABasePath) > 1) and (ABasePath[2] = PathDelimW) then
    Result := PathDelimW + Result; // два слэша в начале - сетевой путь
end;

function WideGetRoot(const APath: WideString): WideString;
var
  i: Integer;
  PathDelimW: WideChar;
begin
  PathDelimW := WideChar(PathDelim);
  Result := '';
  if Length(APath) > 0 then
    if APath[1] = PathDelimW then
      if (Length(APath) > 1) and (APath[2] = PathDelimW) then
      begin
        for i := 3 to Length(APath) do // сетевой путь
          if APath[i] = PathDelimW then
          begin
            Result := Copy(APath, 3, i-3);
            Break;
          end;
        if Result = '' then Result := Copy(APath, 3, MaxInt);
      end
      else Result := PathDelim // корень файловой системы
    else if (Length(APath) > 1) and (APath[2] = WideChar(DriveDelim)) then
      Result := APath[1] // локальный диск
    else
      Result := PathDelimW;
end;

function SameString(const S1, S2: WideString): Boolean; overload;
begin
  if CaseSensitive
    then Result := WideCompareText(S1, S2) = 0
    else Result := WideCompareStr(S1, S2) = 0;
end;

function WideAbsolutePathToRelative(const ABasePath, APath: WideString): WideString;
var
  Strs1, Strs2: TStringArray;
  i, j, k, l: Integer;
  PathDelimW: WideChar;
begin
  PathDelimW := WideChar(PathDelim);

  if (Length(ABasePath) = 0) or (Length(APath) = 0) then
  begin
    Result := APath;
    Exit;
  end;

  // пути на разных сетевых шарах или дисках
  if not SameString(WideGetRoot(ABasePath), WideGetRoot(APath)) then
  begin
    Result := APath;
    Exit;
  end;

  ResemblePath(ABasePath, Strs1);
  ResemblePath(APath, Strs2);

  Result := '';
  k := Length(Strs1); l := 0;
  for i := 0 to Length(Strs2)-1 do
    if i < k then
    begin
      if not SameString(Strs2[i], Strs1[i]) then
      begin
        for j := i to k-1 do Result := Result + '..' + PathDelimW;
        Break;
      end
      else Inc(l);
    end
    else
    begin
      Result := WideString('.') + PathDelimW;
      Break;
    end;
  // путь меньше или равен базовому
  if l >= Length(Strs2) then
    if l = k then Result := Result + '.' + PathDelimW
    else
      for i := l to k-1 do Result := Result + '..' + PathDelimW
  else
    for i := l to Length(Strs2)-1 do
      Result := Result + Strs2[i] + PathDelimW;
  if (Length(APath) > 0) and (APath[Length(APath)] <> PathDelimW) then
    SetLength(Result, Length(Result)-1); // в конце нет слэша - м.б. имя файла
end;

function isAbsolutePath(const APath: string): boolean;
begin
  result:=false;
  if pos(':\',apath)>0 then
    result:=true;
end;

function isRelativePath(const APath: string): boolean;
begin
  if apath[1]='.' then
    result:=true;
end;

function GetPathLevel(Base,Path: String; level:integer): String;
var
  i, j, len:integer;
  о: Integer;
begin
  result:='';
  if pos(base, path)>0 then
  begin
    len:=length(base);
    i:=len;
    if base[i]<>'\' then
      inc(i);
    for j := 0 to level-1 do
    begin
      if I+1<length(path) then
        result:=result+'\'+GetSubString(path, '\',i+1,i);
    end;
    if base[len]='\' then
      setlength(base, len-1);
    result:=base+result;
  end;
end;

function AddSlashToPath(path:string):string;
begin
  if path[length(path)]<>'\' then
    result:=path+'\'
  else
    result:=path;
end;

function DelSlashFromPath(path:string):string;
begin
  if path[length(path)]='\' then
  begin
    setlength(path, length(path)-1);
    result:=path;
  end
  else
    result:=path;
end;

function extractDirName(path:string):string;
var
  i, from,l:integer;
begin
  l:=length(path);
  if path[l]='\' then
  begin
    from:=l-1;
  end
  else
  begin
    from:=l;
  end;
  for I := from downto 1 do
  begin
    if path[i]='\' then
    begin
      result:=copy(path,i+1,from-i);
      break;
    end;
  end;
end;


initialization
  PathDelim := SysUtils.PathDelim;
{$if defined(MSWINDOWS) or defined(WINDOWS)}
  CaseSensitive := False;
{$else}
    CaseSensitive := True;
{$ifend}
end.
