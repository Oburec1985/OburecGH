// Аналог сишного вектора (индексированный список) обеспечивающий быструю вставку
unit uVList;

interface
uses
  Windows, SysUtils, Classes, uListMath;
type

  fcomparator = function (p1,p2:pointer):integer;

  cVList<T> = class;
  cVObj<T> = class;

  cVList<T> = class(tlist)
  public
    // сюда передавать удаляемый объект
    fDelData:tNotifyEvent;
    destroydata:boolean;
    // функция которая позволяет произвести произвольную сортировку
  private
    fsorted:boolean;
  protected
    fCustomSort:fcomparator;
    useCustomSort:boolean;
  private
    procedure setsorted(value:boolean);
    function getsorted:boolean;
    procedure SortChildrens;
  protected

  public
    procedure CustomSort(SortProc:fcomparator);
    constructor create;virtual;
    destructor destroy;virtual;
    function createObj:cVObj<T>;virtual;abstract;
    // удалить объект по ключу из списка. Возвращает объект с данными
    function deleteobj(key:T):tobject;
    function deleteIndObj(index:integer):tobject;
    // возвращает индекс найденного объекта или -1
    function GetIndex(key:T):integer;
    // найти ближайший объект слева от ключа
    function GetLow(key:T;var index:integer):tobject;
    // найти ближайший объект справа от ключа
    function GetHight(key:T; var index:integer):tobject;
    function findObj(key:T;var index:integer):tobject;overload;
    function findObj(key:T):tobject;overload;
    procedure AddObject(key:T;obj:tobject);
    function getObj(i:integer):tobject;
    procedure clear;
    property sorted:boolean read getsorted write setsorted;
  end;

  cVObj<T> = class
    parentList:cVList<T>;
    key:T;
  protected
    procedure setKey(k:pointer);virtual;abstract;
  public
    function compare(k:pointer):integer;overload;virtual;
    destructor destroy;
  end;

implementation

destructor cVObj<T>.destroy;
begin
  parentlist.
  inherited destroy;
end;

function cVObj<T>.compare(k:cVectorObj):integer;
begin
  result:=parentlist.fCustomSort(self,k);
end;

function cVObj<T>.compare(k:pointer):integer;
begin
  result:=parentlist.fCustomSort(pointer,k);
end;

function Comparator(p1,p2:pointer):integer;
var
  obj1, obj2:cVObj<T>;
begin
  obj1 := cVObj<T>(p1);
  obj2 := cVObj<T>(p2);
  // Теперь сравнение строк
  result:=obj1.compare(obj2);
end;

constructor cVectorList.create;
begin
  inherited;
  fsorted:=true;
  destroydata:=true;
end;

destructor cVectorList.destroy;
var i:integer;
begin
  for I := 0 to count - 1 do
  begin
    getNode(i).destroy(destroydata);
  end;
  inherited;
end;

function cVectorList.getObj(i:integer):tobject;
begin
  result:=nil;
  if i>=count then exit;
  result:=tobject(getnode(i).pointer);
end;

function cVectorList.getNode(i:integer):cVectorObj;
begin
  result:=cVectorObj(items[i]);
end;

procedure cVectorList.CustomSort(SortProc:fcomparator);
begin
  useCustomSort:=true;
  fCustomSort:=sortproc;
end;

procedure cVectorList.setsorted(value:boolean);
begin
  fsorted:=value;
  if fsorted=true then
    SortChildrens;
end;

function cVectorList.getsorted:boolean;
begin
  result:=fsorted;
end;

procedure cVectorList.SortChildrens;
begin
  Sort(Comparator);
end;

procedure cVectorList.AddObject(key:pointer;obj:tobject);
var i:integer;
    vectorobj:cVectorObj;
begin
  vectorobj:=createObj;
  vectorobj.pointer:=obj;
  vectorobj.setkey(key);
  if sorted then
  begin
    // находим индекс куда вставлять объект
    i:=FindInListLowBound(self,vectorobj,comparator);
    if (count<>0) then
    begin
      if i=0 then
      begin
        if getnode(i).compare(key)=1 then
          insert(i,vectorobj)
        else
          insert(i+1,vectorobj);
      end
      else
      begin
        if (i+1)=count then
          add(vectorobj)
        else
          insert(i+1,vectorobj);
      end;
    end
    else
      add(vectorobj);
  end
  else
    add(vectorobj);
end;

function cVectorList.deleteIndObj(index:integer):tobject;
var
  vectorobj:cvectorobj;
begin
  vectorobj:=getNode(index);
  // Исключаем объект из списка
  self.Delete(index);
  // возвращаем данные
  result:=vectorobj.pointer;
  // Удаляем вспомогательный объект
  vectorobj.Destroy(destroydata);
end;

function cVectorList.deleteobj(key:pointer):tobject;
var i:integer;
    vectorobj:cvectorobj;
begin
  vectorobj:=createObj;
  vectorobj.setkey(key);
  i:=FindInListLowBound(self,vectorobj,comparator);
  vectorobj.Destroy(false);
  vectorobj:=getNode(i);
  if vectorobj.compare(key)=0 then
  begin
    // Исключаем объект из списка
    self.Delete(i);
    // возвращаем данные
    result:=vectorobj.pointer;
    // Удаляем вспомогательный объект
    vectorobj.Destroy(destroydata);
  end;
end;

function cVectorList.GetLow(key:pointer;var index:integer):tobject;
var i:integer;
    vectorobj:cvectorobj;
begin
  result:=nil;
  if count<>0 then
  begin
    vectorobj:=createObj;
    vectorobj.setkey(key);
    i:=FindInListLowBound(self,vectorobj,comparator);
    vectorobj.Destroy(destroydata);
    vectorobj:=getNode(i);
    index:=i;
    if i=0 then
    begin
      if vectorobj.compare(key)=1 then
      begin
        result:=nil;
        exit;
      end
      else
        result:=vectorobj.pointer;
    end
    else
    begin
      if vectorobj.compare(key)<=0 then
      begin
        result:=vectorobj.pointer;
        exit;
      end;
    end;
  end;
end;

function cVectorList.GetHight(key:pointer; var index:integer):tobject;
var i:integer;
    vectorobj:cvectorobj;
begin
  result:=nil;
  if count<>0 then
  begin
    vectorobj:=createObj;
    vectorobj.setkey(key);
    i:=FindInListHiBound(self,vectorobj,comparator);
    index:=i;
    vectorobj.Destroy(destroydata);
    vectorobj:=getNode(i);
    if i=0 then
    begin
      if vectorobj.compare(key)=-1 then
      begin
        result:=vectorobj.pointer;
        exit;
      end;
    end
    else
    begin
      if vectorobj.compare(key)=1 then
      begin
        result:=vectorobj.pointer;
        exit;
      end;
    end;
  end
  else
  begin
    index:=0;
  end;
end;

function cVectorList.findObj(key:pointer):tobject;
var i:integer;
begin
  result:=findobj(key,i);
end;

function cVectorList.findObj(key:pointer;var index:integer):tobject;
var i:integer;
    vectorobj:cvectorobj;
begin
  index:=-1;
  result:=nil;
  if count<>0 then
  begin
    vectorobj:=createObj;
    vectorobj.setkey(key);
    i:=FindInListLowBound(self,vectorobj,comparator);
    vectorobj.Destroy(destroydata);
    vectorobj:=getNode(i);
    if vectorobj.compare(key)=0 then
    begin
      index:=i;
      result:=vectorobj.pointer;
      exit;
    end
    else
    begin
      if (i+1)<count then
      begin
        vectorobj:=getNode(i+1);
        if vectorobj.compare(key)=0 then
        begin
          index:=i+1;
          result:=vectorobj.pointer;
          exit;
        end
      end;
    end;
  end;
end;

function cVectorList.GetIndex(key:pointer):integer;
var i:integer;
    vectorobj:cvectorobj;
begin
  result:=-1;
  if count<>0 then
  begin
    vectorobj:=createObj;
    vectorobj.setkey(key);
    i:=FindInListLowBound(self,vectorobj,comparator);
    if vectorobj.compare(key)=0 then
      result:=i
    else
    begin
      if getnode(i+1).compare(key)=0 then
        result:=i+1;
    end;
    vectorobj.destroy(false);
  end;
end;

procedure cVectorList.clear;
var
  vectorobj:cvectorobj;
  i:integer;
begin
  while count<>0 do
  begin
    deleteIndObj(0);
  end;
end;

end.
