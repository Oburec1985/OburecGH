unit uPointsList;

interface
uses
  usetList, uCommonTypes, uMyMath;

type

  p2dArray = array of point2d;

  cPointsMemMng = class
  public
    // число использованных элементов в последнем использованном пуле
    usedItems:cardinal;
    // число использованных блоков в последнем использованном пуле
    usedBlocks:cardinal;
  public
    MemArray:array of p2dArray;
    // вместительность одного блока данных
    m_BlockCapacity:cardinal;
  protected
    procedure IncUsedItems;
  public
    function count:integer;
    procedure allocateBlock;
    // получаем номер блока в котором находится i-й элемент, возвращаем индекс внутри блока
    function GetBlockIndex(i:integer; var block:integer):integer;
    // находим индекс блока в котором импульс
    function GetBlock(x:double):integer;
    // при создани выделяется 1 блок
    Constructor Create(blockCapacity:cardinal);
    Destructor Destroy;
    // очищает все выделенные блоки
    procedure clearMem;
    // копирует тик в память и возвращает указатель
    function AddP2(p2:point2d):pointer;
  end;

  cP2dList = class(csetlist)
  protected
    mem:cPointsMemMng;
  public
    procedure deletechild(node: pointer); override;
    constructor create; override;
    function add(p:point2d):integer;
    destructor destroy;override;
  end;

  cPointList = class
  protected
    // ссыль на менеджер памяти для выделенных тиков
    PointsMemMng:cPointsMemMng;
  protected
    // возвращает номер блока в котором находиться нужный импульс
    function GetBlockIndex(i:integer; var block:integer):integer;
    function GetPInBlock(i:integer; block:integer):point2d;
    function GetLow(key:pointer;var index:integer):pointer;
    // найти ближайший объект справа от ключа
    function GetHight(key:pointer; var index:integer):pointer;
  public
    constructor create;override;
    destructor destroy;override;
    function getP(i:integer):point2d;override;
    function GetLoP(p:point2d; var index:integer):point2d;override;
    function GetHiP(p:point2d; var index:integer):point2d;override;
    function Count:integer;override;
    procedure clear;override;
  end;

  const
    c_blockcapacity = 40000;
    c_blockCount = 500;

implementation

function ResComparator(p1, p2: pointer): integer;
begin
  if point2d(p1).x > point2d(p2).x then
  begin
    result := 1;
  end
  else
  begin
    if  point2d(p1).x <  point2d(p2).x then
    begin
      result := -1;
    end
    else
    begin
      result := 0;
    end;
  end;
end;

constructor cPointList.create;
begin
  inherited;
  PointsMemMng:=cPointsMemMng.Create(c_blockcapacity);
end;

destructor cPointList.destroy;
begin
  PointsMemMng.ClearMem;
  PointsMemMng.destroy;
  inherited;
end;

function cPointList.getP(i:integer):point2d;
var
  // номер блока в котором нужный тик
  block, index:integer;
begin
  //block:=trunc(i/BldMemMng.m_blockcapacity);
  //index:=i-block*BldMemMng.m_blockcapacity;
  //result:=BldMemMng.MemArray[block,index];
  index:=getblockindex(i,block);
  //if length(BldMemMng.MemArray[block])<>0 then
  if index>=0 then
    result:=PointsMemMng.MemArray[block,index];
end;

function cPointList.GetLoP(p:point2d; var index:integer):point2d;
var
  used,block:integer;
begin
  block:=PointsMemMng.GetBlock(p);
  if block<cPointList.usedBlocks then
    used:=cPointList.m_BlockCapacity
  else
    used:=PointsMemMng.usedItems;
  index:=FindInDPointsArrayHiBound(PointsMemMng.MemArray[block],p, 0,used-1);
  result:=PointsMemMng.MemArray[block,index];
  index:=index+block*PointsMemMng.m_BlockCapacity;
end;

function cPointList.GetHiP(p:point2d; var index:integer):point2d;
var
  used,block:integer;
begin
  block:=PointsMemMng.GetBlock(p);
  if block<PointsMemMng.usedBlocks then
    used:=PointsMemMng.m_BlockCapacity
  else
    used:=PointsMemMng.usedItems;
    index:=FindInDPointsArrayHiBound(PointsMemMng.MemArray[block],p,0,used-1);
  result:=PointsMemMng.MemArray[block,index];
  index:=index+block*PointsMemMng.m_BlockCapacity;
end;

// найти ближайший объект слева от ключа
function cPointList.GetLow(key:pointer;var index:integer):pointer;
var
  block:integer;
begin
  block:=PointsMemMng.GetBlock(point2d(key^));
  if block=PointsMemMng.usedBlocks then
    index:=FindInDPointsArrayHiBound(PointsMemMng.MemArray[block],point2d(key^),
         0,PointsMemMng.usedItems-1)
  else
    index:=FindInDPointsArrayHiBound(PointsMemMng.MemArray[block],point2d(key^),
         0,PointsMemMng.m_BlockCapacity-1);
  result:=@PointsMemMng.MemArray[block, index];
  index:=index+block*PointsMemMng.m_BlockCapacity;
end;

// найти ближайший объект справа от ключа
function cPointList.GetHight(key:pointer; var index:integer):pointer;
var
  block:integer;
begin
  block:=PointsMemMng.GetBlock(point2d(key^));
  if block=PointsMemMng.m_BlockCapacity then
    index:=FindInDPointsArrayHiBound(PointsMemMng.MemArray[block],point2d(key^),
         0,PointsMemMng.usedItems-1)
  else
    index:=FindInDPointsArrayHiBound(PointsMemMng.MemArray[block],point2d(key^),
         0,PointsMemMng.m_BlockCapacity-1);
  result:=@PointsMemMng.MemArray[block, index];
  index:=index+block*PointsMemMng.m_BlockCapacity;
end;

function cPointList.Count:integer;
begin
  result:=PointsMemMng.count;
end;

procedure cPointList.clear;
begin
  //BldMemMng.clearmem;
  PointsMemMng.usedBlocks:=0;
  PointsMemMng.useditems:=0;
end;

function cPointList.GetBlockIndex(i:integer; var block:integer):integer;
begin
  result:=PointsMemMng.GetBlockIndex(i, block);
end;

function cPointList.GetPInBlock(i:integer; block:integer):point2d;
begin
  result:=PointsMemMng.MemArray[block,i];
end;


// ==========================================================================

Constructor cPointsMemMng.Create(blockCapacity:cardinal);
begin
  setlength(memarray, c_blockCount);
  usedBlocks:=0;
  useditems:=0;
  m_BlockCapacity:=blockCapacity;
  allocateBlock;
end;


Destructor cPointsMemMng.Destroy;
begin
  clearMem;
  setlength(memarray,0);
end;

function cPointsMemMng.count:integer;
begin
  result:=usedItems;
  if usedBlocks>0 then
  begin
    result:=result+usedBlocks*m_BlockCapacity;
  end;
end;

procedure cPointsMemMng.clearMem;
var
  i:integer;
begin
  for I := 0 to usedBlocks do
  begin
    setlength(MemArray[i],0);
  end;
  usedBlocks:=0;
end;

procedure cPointsMemMng.allocateBlock;
begin
  setlength(MemArray[usedBlocks],m_BlockCapacity);
end;

procedure cPointsMemMng.IncUsedItems;
begin
  inc(usedItems);
  if usedItems>=m_BlockCapacity then
  begin
    inc(usedBlocks);
    allocateBlock;
    usedItems:=0;
  end;
end;

function cPointsMemMng.AddP2(p2:point2d):pointer;
begin
  MemArray[usedBlocks,usedItems]:=p2;
  result:=@MemArray[usedBlocks,usedItems];
  IncUsedItems;
end;

function cPointsMemMng.GetBlockIndex(i:integer; var block:integer):integer;
begin
  block:=0;
  while i>=m_BlockCapacity do
  begin
    inc(block);
    i:=i-m_BlockCapacity;
  end;
  result:=i;
end;

function compareD(x1,x2:double):integer;
begin
  if x1>p2.x then
    result:=1
  else
  begin
    if x1<x2 then
      result:=-1
    else
      result:=0;
  end;
end;

function cPointsMemMng.GetBlock(x:double):integer;
var
  res,block:integer;
  lp:point2d;
begin
  block:=0;
  while block<>usedBlocks do
  begin
    if block<=usedBlocks then
    begin
      lp:=MemArray[block,m_BlockCapacity-1];
      res:=compareD(lp.x,x);
      if res=1 then
      begin
        break;
      end;
    end;
    inc(block);
  end;
  result:=block;
end;


{ cP2dList }

function cP2dList.add(p: point2d): integer;
var
  lp:pointer;
begin
  mem.AddP2(p);
  AddObj(lp);
end;

constructor cP2dList.create;
begin
  inherited;
  comparator:=ResComparator;
end;

procedure cP2dList.deletechild(node: pointer);
begin
  inherited;
end;

destructor cP2dList.destroy;
begin
  mem.Destroy;
  inherited;
end;

end.
