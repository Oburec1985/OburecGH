unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Math, uHardwareMath;

type

  TpackVector = packed array [0..3] of Single;
  PpackVector = ^TpackVector;

  TVector = array [0..3] of Single;
  PVector = ^TVector;


  TForm1 = class(TForm)
    Memo1: TMemo;
    Button2: TButton;
    Memo2: TMemo;
    Memo3: TMemo;
    TestSummSkripnik: TButton;
    procedure Button2Click(Sender: TObject);
    procedure TestSummSkripnikClick(Sender: TObject);
  private
    Fr, t1, t2: Int64;
    Dt: Extended;
  private
    procedure StartTimer(comment:string);
    procedure StopTimer(comment:string);
  public
    { Public declarations }
  end;

const
  iTimes = 10;
  iSize = 100000000;
  sseRegCount = 4; // количество регистров
  sseRegSize = 4; // размер регистра sse (4 числа с плав. точкой)
  sseRegSize_1 = 3; // размер регистра sse (4 числа с плав. точкой)
  SizeAligned = SizeOf(TVector);

var
  Form1: TForm1;

implementation

//{$ALIGN 16}
{$R *.dfm}


procedure TForm1.Button2Click(Sender: TObject);
var
  i : integer;
begin
  Memo2.Text := '';
  for i := 0 to 27 do
    Memo2.Text := Memo2.Text + IntToStr(i) + ' = ' + BoolToStr( IsProcessorFeaturePresent(i), true ) + #13#10;
end;


function sumSSE_s(arr_single:pointer):single;register; assembler;
asm
     // IN: EAX = ptr to Data, EDX = High(Data) = Count - 1
     // Uses 4 accumulators to minimize read-after-write delays and loop overhead
     // 5 clocks per loop, 4 items per loop = 1.2 clocks per item
       FLDZ
       MOV      ECX, EDX
       FLD      ST(0)
       AND      EDX, not 3
       FLD      ST(0)
       AND      ECX, 3
       FLD      ST(0)
       SHL      EDX, 3      // count * sizeof(Double) = count * 8
       JMP      @Vector.Pointer[ECX*4]
@Vector:
       DD @@1
       DD @@2
       DD @@3
       DD @@4
@@4:   FADD     qword ptr [EAX+EDX+24]    // 1
       FXCH     ST(3)                     // 0
@@3:   FADD     qword ptr [EAX+EDX+16]    // 1
       FXCH     ST(2)                     // 0
@@2:   FADD     qword ptr [EAX+EDX+8]     // 1
       FXCH     ST(1)                     // 0
@@1:   FADD     qword ptr [EAX+EDX]       // 1
       FXCH     ST(2)                     // 0
       SUB      EDX, 32
       JNS      @@4
       FADDP    ST(3),ST                  // ST(3) := ST + ST(3); Pop ST
       FADD                               // ST(1) := ST + ST(1); Pop ST
       FADD                               // ST(1) := ST + ST(1); Pop ST
       FWAIT
end;

function sumSSE_d(arr_single:pointer):single;register; assembler;
asm
     // IN: EAX = ptr to Data, EDX = High(Data) = Count - 1
     // Uses 4 accumulators to minimize read-after-write delays and loop overhead
     // 5 clocks per loop, 4 items per loop = 1.2 clocks per item
       FLDZ
       MOV      ECX, EDX
       FLD      ST(0)
       AND      EDX, not 3
       FLD      ST(0)
       AND      ECX, 3
       FLD      ST(0)
       SHL      EDX, 3      // count * sizeof(Double) = count * 8
       JMP      @Vector.Pointer[ECX*4]
@Vector:
       DD @@1
       DD @@2
       DD @@3
       DD @@4
@@4:   FADD     qword ptr [EAX+EDX+24]    // 1
       FXCH     ST(3)                     // 0
@@3:   FADD     qword ptr [EAX+EDX+16]    // 1
       FXCH     ST(2)                     // 0
@@2:   FADD     qword ptr [EAX+EDX+8]     // 1
       FXCH     ST(1)                     // 0
@@1:   FADD     qword ptr [EAX+EDX]       // 1
       FXCH     ST(2)                     // 0
       SUB      EDX, 32
       JNS      @@4
       FADDP    ST(3),ST                  // ST(3) := ST + ST(3); Pop ST
       FADD                               // ST(1) := ST + ST(1); Pop ST
       FADD                               // ST(1) := ST + ST(1); Pop ST
       FWAIT
end;

// MATH
function SUM(const Data: array of Double): Extended;
asm  // IN: EAX = ptr to Data, EDX = High(Data) = Count - 1
     // Uses 4 accumulators to minimize read-after-write delays and loop overhead
     // 5 clocks per loop, 4 items per loop = 1.2 clocks per item
       FLDZ               // записать в посл пустой регистр 0
       MOV      ECX, EDX  // в edx почему то длина массива (точнее hight)
       FLD      ST(0)     // записать в след регистр 0 из регистра который положили в первой стркое
       AND      EDX, not 3 // убираем остаток 3 (т.к. в регистре 4 элемента, делаем кратным делению 4-м)
       FLD      ST(0)     // занул€ем очередной регистр
       AND      ECX, 3    // ¬ ecx сохран€ем отброшенный 3€ строками выше остаток
       FLD      ST(0)
       SHL      EDX, 3      // count * sizeof(Double) = count * 8 (преобразуем в смещение в байтах последний элемент кратный 4м)
       // прыгаем сперва в конец массива (EAX+EDX - конец массива (кратный кусок)+ECX*4 (некратный кусок))
       JMP      @Vec.Pointer[ECX*4]
@Vec:
       DD @@1
       DD @@2
       DD @@3
       DD @@4
@@4:   FADD     qword ptr [EAX+EDX+24]    // 1  qword (8 байт) eax (адрес массива)+edx (смещение к посл элементу+)
       FXCH     ST(3)                     // 0 обмент€ть регистр стека 0 и регистр стека номер 3
@@3:   FADD     qword ptr [EAX+EDX+16]    // 1
       FXCH     ST(2)                     // 0
@@2:   FADD     qword ptr [EAX+EDX+8]     // 1
       FXCH     ST(1)                     // 0
@@1:   FADD     qword ptr [EAX+EDX]       // 1
       FXCH     ST(2)                     // 0
       SUB      EDX, 32                   // смещаемс€ на 4 дабла назад, если элементы не кончились продолжаем суммировать
                                          // если разница отрицательна взводитс€ флаг sf
       JNS      @@4                       // переход если sf=0
       FADDP    ST(3),ST                  // ST(3) := ST + ST(3); Pop ST —ложение с извлечением из стека
       FADD                               // ST(1) := ST + ST(1); Pop ST
       FADD                               // ST(1) := ST + ST(1); Pop ST
       FWAIT
end;

procedure TForm1.StartTimer(comment: string);
begin
  // „тение показани€ счЄтчика тактов.
  Memo3.Text := Memo3.Text + comment + #13#10;
  QueryPerformanceFrequency(Fr);
  QueryPerformanceCounter(t1);
end;

procedure TForm1.StopTimer(comment: string);
begin
  Memo3.Text := Memo3.Text + '–езультат: '#9#9 + comment + #13#10;
  // ѕоказание счЄтчика тактов.
  QueryPerformanceCounter(t2);
  Memo3.Text := Memo3.Text + 'ƒлительность в тиках: '#9 + FloatToStrF(t2 - t1, ffnumber, 20, 0) + #13#10;
  Dt := (t2 - t1)/Fr;
  Memo1.Text := Memo1.Text + 'ƒлительность в микросекундах: '#9 + FloatToStrF(Dt*1000000, ffnumber, 20, 10) + #13#10 + #13#10;
end;

procedure TForm1.TestSummSkripnikClick(Sender: TObject);
var
  i, j, k, SseCount:integer;
  ars:array of single;
  ard: array of double;
  Fr, t: Int64;
  res, Dt: Extended;

  DataUnaligned1, DataAligned1, DataUnaligned2, DataAligned2: Pointer;
  SizeUnaligned1, SizeUnaligned2:integer;

  v1, v2:pVector;
begin
  setlength(ard, iSize);
  //setlength(ars, iSize);
  //SizeAligned:=iSize;
  // align by 4 bits, i.e. by 16 bytes
  GetMemAligned(4 , nil, sizeof(single)*isize,
                pointer(ars),
                DataUnaligned1,
                SizeUnaligned1);
  GetMemAligned(4 , nil, sizeof(single)*sizeof(tvector),
                pointer(v1),
                DataUnaligned1,
                SizeUnaligned1);

  // инициализаци€ массива
  for I := 0 to iSize-1 do
  begin
    ard[I] := i;
  end;
  // инициализаци€ массива
  for I := 0 to iSize-1 do
  begin
    ars[I] := i;
  end;

  /////////////////////// Math
  StartTimer('Math:');
  // считаем сумму iTimes раз
  for i := 1 to iTimes do
  begin
    res := SUM(ard);
  end;
  StopTimer('Math:'+floattostr(res));

  /////////////////////// Math
  StartTimer('SSE_d:');
  // считаем сумму iTimes раз
  for i := 1 to iTimes do
  begin
    //res := sumSSE_d(ard);
    res := sum_SSE_d(ard);
  end;
  StopTimer('SSE_d:'+floattostr(res));
end;



end.
