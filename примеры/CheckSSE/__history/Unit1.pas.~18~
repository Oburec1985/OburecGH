unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, Math, uHardwareMath;

type

  TpackVector = packed array [0..3] of Single;
  PpackVector = ^TpackVector;

  TVector = array [0..3] of Single;
  PVector = ^TVector;


  TForm1 = class(TForm)
    Memo1: TMemo;
    Button2: TButton;
    Memo2: TMemo;
    Memo3: TMemo;
    TestSummSkripnik: TButton;
    procedure Button2Click(Sender: TObject);
    procedure TestSummSkripnikClick(Sender: TObject);
  private
    Fr, t1, t2: Int64;
    Dt: Extended;
  private
    procedure StartTimer(comment:string);
    procedure StopTimer(comment:string);
  public
    { Public declarations }
  end;

const
  iTimes = 1;
  iSize = 30;
  sseRegCount = 4; // количество регистров
  sseRegSize = 4; // размер регистра sse (4 числа с плав. точкой)
  sseRegSize_1 = 3; // размер регистра sse (4 числа с плав. точкой)
  SizeAligned = SizeOf(TVector);

var
  Form1: TForm1;

implementation

//{$ALIGN 16}
{$R *.dfm}


procedure TForm1.Button2Click(Sender: TObject);
var
  i : integer;
begin
  Memo2.Text := '';
  for i := 0 to 27 do
    Memo2.Text := Memo2.Text + IntToStr(i) + ' = ' + BoolToStr( IsProcessorFeaturePresent(i), true ) + #13#10;
end;

procedure TForm1.StartTimer(comment: string);
begin
  // Чтение показания счётчика тактов.
  Memo3.Text := Memo3.Text + comment + #13#10;
  QueryPerformanceFrequency(Fr);
  QueryPerformanceCounter(t1);
end;

procedure TForm1.StopTimer(comment: string);
begin
  Memo3.Text := Memo3.Text + 'Результат: '#9#9 + comment + #13#10;
  // Показание счётчика тактов.
  QueryPerformanceCounter(t2);
  Memo3.Text := Memo3.Text + 'Длительность в тиках: '#9 + FloatToStrF(t2 - t1, ffnumber, 20, 0) + #13#10;
  Dt := (t2 - t1)/Fr;
  Memo1.Text := Memo1.Text + 'Длительность в микросекундах: '#9 + FloatToStrF(Dt*1000000, ffnumber, 20, 10) + #13#10 + #13#10;
end;

procedure TForm1.TestSummSkripnikClick(Sender: TObject);
var
  i, j, k, SseCount:integer;
  ars:array of single;
  ard: array of double;
  Fr, t: Int64;
  res, Dt: Extended;

  DataUnaligned1, DataAligned1, DataUnaligned2, DataAligned2: Pointer;
  SizeUnaligned1, SizeUnaligned2:integer;

  v1, v2:pVector;
begin
  setlength(ard, iSize);
  //setlength(ars, iSize);
  //SizeAligned:=iSize;
  // align by 4 bits, i.e. by 16 bytes
  GetMemAligned(4 , nil, sizeof(single)*isize,
                pointer(ars),
                DataUnaligned1,
                SizeUnaligned1);
  GetMemAligned(4 , nil, sizeof(single)*sizeof(tvector),
                pointer(v1),
                DataUnaligned1,
                SizeUnaligned1);

  // инициализация массива
  for I := 0 to iSize-1 do
  begin
    ard[I] := i;
  end;
  // инициализация массива
  for I := 0 to iSize-1 do
  begin
    ars[I] := i;
  end;

  /////////////////////// Math
  StartTimer('Math:');
  // считаем сумму iTimes раз
  for i := 1 to iTimes do
  begin
    res := SUM(ard);
  end;
  StopTimer('Math:'+floattostr(res));

  /////////////////////// Math
  StartTimer('SSE_d:');
  // считаем сумму iTimes раз
  for i := 1 to iTimes do
  begin
    //res := sumSSE_d(ard);
    res := sum_SSE_d(ard, 3, 9);
    //res := sum_SSE_d(ard);
  end;
  StopTimer('SSE_d:'+floattostr(res));
end;



end.
