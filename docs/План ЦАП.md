# План реализации управления ЦАП (версия 3)

Этот план описывает шаги по созданию универсальной системы управления ЦАП, дополненный с учетом требований к потоковой передаче, плавной остановке и **конкретным режимам воспроизведения.**

### Шаг 1: Создание базового абстрактного класса для ЦАП

1.  **Создать новый модуль (unit):** `uDacDevice.pas`.
2.  **Определить класс `TDacDevice`:**
    *   Свойства: `SampleRate`, `BitsPerSample`, `Channels`.
    *   **Измененный набор методов:**
        *   `procedure Open; virtual; abstract;`
        *   `procedure Close; virtual; abstract;`
        *   `procedure Start(ALoopCount: Cardinal = 1); virtual; abstract;` - **(Изменено)** Запускает воспроизведение. `ALoopCount=1` - однократное, `ALoopCount > 1` - заданное число раз, `ALoopCount = 0` - бесконечное зацикливание.
        *   `procedure Stop(AGraceful: Boolean = True); virtual; abstract;`
        *   `procedure QueueBuffer(const ABuffer; ASize: Integer); virtual; abstract;`
        *   `function IsActive: Boolean; virtual; abstract;`
    *   **Событие:** `OnBufferEnd: TNotifyEvent;`

### Шаг 2: Реализация класса для ЦАП звуковой карты

1.  **Создать новый модуль:** `uSoundCardDac.pas`.
2.  **Определить класс `TSoundCardDac`:**
    *   Реализация на основе **двойной буферизации и callback-функции**.
    *   **`Start`**: Реализация будет использовать поле `dwLoops` в структуре `WAVEHDR` для поддержки зацикливания, как того требует `waveOut` API.
    *   **`Stop`**: Реализует как плавную, так и мгновенную остановку.
    *   **`QueueBuffer`**: Добавляет данные в очередь на воспроизведение.
    *   **Callback-функция (`WOM_DONE`)**: Управляет очередью буферов и вызывает событие `OnBufferEnd`.

### Шаг 3: Интеграция в форму `uDacFrm` и реализация режимов

1.  **Модификация `uDacFrm.dfm`:**
    *   Добавить `TRadioGroup` для выбора режима: `rgMode` ("Sin", "SweepSin").
    *   Добавить панели (`TPanel`) или группы (`TGroupBox`) для параметров каждого режима, которые будут показываться/скрываться в зависимости от выбора в `rgMode`.
    *   **Параметры "Sin"**: `TEdit` для частоты и амплитуды.
    *   **Параметры "SweepSin"**: `TEdit` для начальной/конечной частоты, скорости развертки (октав/мин), выбор закона (линейный/логарифмический).
2.  **Модификация `uDacFrm.pas`:**
    *   Инициализация `FDacDevice` и назначение обработчика `FDacDevice.OnBufferEnd := DacBufferEndHandler;`.
    *   **Реализация логики режимов:**
        *   **`btnPlayStop.OnClick` (при запуске):**
            *   Прочитать общие параметры (амплитуда и т.д.).
            *   **Если `rgMode.ItemIndex = 0` (Sin):**
                1.  Сгенерировать **один** буфер, содержащий **целое число периодов** синусоиды с заданной частотой.
                2.  Поставить его в очередь: `FDacDevice.QueueBuffer(...)`.
                3.  Запустить зацикленное воспроизведение: `FDacDevice.Start(ALoopCount := 0)`. В этом режиме обработчик `OnBufferEnd` не используется.
            *   **Если `rgMode.ItemIndex = 1` (SweepSin):**
                1.  Инициализировать переменные для расчета "качания" частоты.
                2.  Запустить потоковый режим: `FDacDevice.Start(ALoopCount := 1)`.
                3.  Вызвать `GenerateAndQueueData`, чтобы сгенерировать и отправить первый блок данных.
        *   **`DacBufferEndHandler(Sender: TObject)` (обработчик события):**
            *   Проверить, что активен режим `SweepSin`.
            *   Если да, вызвать `GenerateAndQueueData` для подачи следующего блока.
        *   **`GenerateAndQueueData` (процедура генерации):**
            *   Проверить, что активен режим `SweepSin`.
            *   Рассчитать новое значение частоты согласно закону развертки.
            *   Сгенерировать следующий блок данных с новой частотой.
            *   Отправить его в ЦАП: `FDacDevice.QueueBuffer(...)`.

### Шаг 4: Тестирование

1.  **Проверить режим "Sin"**: убедиться, что генерируется стабильный тон. Проверить изменение тона при изменении частоты и перезапуске.
2.  **Проверить режим "SweepSin"**: убедиться, что частота плавно меняется от начальной до конечной. Проверить непрерывность сигнала.
3.  **Проверить плавную остановку** в обоих режимах.
